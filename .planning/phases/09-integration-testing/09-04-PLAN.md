---
phase: 09-integration-testing
plan: 04
type: execute
wave: 1
depends_on: [09-03]
files_modified:
  - src/web/dashboard.py
  - src/web/__init__.py
  - src/web/static/index.html
  - src/web/static/dashboard.js
  - src/web/static/styles.css
  - src/monitoring/alerting.py
  - scripts/start_dashboard.sh
autonomous: true
must_haves:
  truths:
    - "Real-time dashboard provides visibility into system health"
    - "Alert system notifies on anomalies without alert fatigue"
    - "Emotional state visualization helps understand Demi's mood"
    - "Dashboard must be lightweight and not impact system performance"
  artifacts:
    - path: "src/web/dashboard.py"
      provides: "Web dashboard for system health monitoring"
      exports: ["HealthDashboard", "DashboardServer"]
      min_lines: 300
    - path: "src/monitoring/alerting.py"
      provides: "Alert system for health anomalies"
      exports: ["AlertManager", "AlertRule", "Alert"]
      min_lines: 200
    - path: "src/web/static/index.html"
      provides: "Dashboard HTML frontend"
      exports: []
      min_lines: 150
    - path: "src/web/static/dashboard.js"
      provides: "Dashboard JavaScript for real-time updates"
      exports: []
      min_lines: 200
    - path: "src/web/static/styles.css"
      provides: "Dashboard styling"
      exports: []
      min_lines: 100
    - path: "scripts/start_dashboard.sh"
      provides: "Script to start dashboard server"
      exports: []
      min_lines: 40
  key_links:
    - from: "src/web/dashboard.py"
      to: "src/conductor/resource_monitor.py"
      via: "Fetches resource metrics for display"
      pattern: "ResourceMonitor.get_resource_summary"
    - from: "src/web/dashboard.py"
      to: "src/emotion/persistence.py"
      via: "Fetches emotional state for visualization"
      pattern: "EmotionPersistence.load_latest_state"
    - from: "src/monitoring/alerting.py"
      to: "src/conductor/health.py"
      via: "Uses health status for alerting"
      pattern: "HealthMonitor.get_all_statuses"
---

<objective>
Build System Health Monitoring Dashboard that provides real-time visibility into Demi's operational status, resource usage, emotional state, and health metrics. Includes an alert system for anomaly detection and emotional state visualization to understand Demi's current mood.

Purpose: Provide operational visibility for the 7-day stability test and ongoing system monitoring. Enable quick detection of issues and understanding of Demi's emotional state at a glance.

Output: Web-based dashboard accessible via browser, real-time health metrics, emotional state visualization, and configurable alert system.
</objective>

<execution_context>
@.planning/REQUIREMENTS.md
@src/conductor/resource_monitor.py
@src/conductor/health.py
@src/emotion/models.py
</execution_context>

<context>
@src/conductor/orchestrator.py
@src/conductor/resource_monitor.py
@src/conductor/health.py
@src/conductor/metrics.py
@src/emotion/persistence.py
@src/emotion/models.py
</context>

<tasks>

<task type="auto">
  <name>Create alert system for health anomalies</name>
  <files>src/monitoring/alerting.py</files>
  <action>Create `src/monitoring/alerting.py` with alerting infrastructure:

**Imports:**
- `import asyncio`
- `import time`
- `from typing import Dict, List, Optional, Callable, Any`
- `from dataclasses import dataclass, field`
- `from datetime import datetime, timedelta`
- `from enum import Enum`
- `from src.core.logger import get_logger`
- `from src.conductor.health import HealthStatus`
- `from src.conductor.resource_monitor import ResourceMonitor`

**Class AlertSeverity:**
```python
class AlertSeverity(Enum):
    """Alert severity levels."""
    INFO = "info"
    WARNING = "warning"
    CRITICAL = "critical"
```

**Dataclass Alert:**
```python
@dataclass
class Alert:
    """An active or resolved alert."""
    id: str
    rule_name: str
    severity: AlertSeverity
    message: str
    timestamp: datetime
    resolved_at: Optional[datetime] = None
    metadata: Dict[str, Any] = field(default_factory=dict)
    
    @property
    def is_active(self) -> bool:
        return self.resolved_at is None
    
    @property
    def duration_seconds(self) -> float:
        end = self.resolved_at or datetime.now()
        return (end - self.timestamp).total_seconds()
```

**Dataclass AlertRule:**
```python
@dataclass
class AlertRule:
    """Rule for triggering alerts."""
    name: str
    description: str
    severity: AlertSeverity
    condition_fn: Callable[[Dict[str, Any]], bool]
    cooldown_minutes: int = 30  # Minimum time between alerts for same rule
    auto_resolve: bool = True
    last_triggered: Optional[datetime] = None
    
    def check_condition(self, data: Dict[str, Any]) -> bool:
        """Check if alert condition is met, respecting cooldown."""
        if self.last_triggered:
            cooldown_end = self.last_triggered + timedelta(minutes=self.cooldown_minutes)
            if datetime.now() < cooldown_end:
                return False
        
        if self.condition_fn(data):
            self.last_triggered = datetime.now()
            return True
        return False
```

**Class AlertManager:**
- `__init__(self, max_alerts: int = 100)`:
  - Initialize alert storage
  - Setup default alert rules
  - Configure notification channels
  
- `def add_rule(self, rule: AlertRule)`:
  - Register an alert rule
  
- `def remove_rule(self, rule_name: str)`:
  - Remove an alert rule
  
- `async def evaluate_rules(self, data: Dict[str, Any])`:
  - Check all rules against current data
  - Trigger alerts for matching rules
  - Auto-resolve cleared conditions
  
- `def trigger_alert(self, rule: AlertRule, data: Dict[str, Any]) -> Alert`:
  - Create new alert
  - Send notifications
  - Store in history
  
- `def resolve_alert(self, alert_id: str)`:
  - Mark alert as resolved
  
- `def get_active_alerts(self, severity: Optional[AlertSeverity] = None) -> List[Alert]`:
  - Get currently active alerts
  - Optionally filter by severity
  
- `def get_alert_history(self, limit: int = 100) -> List[Alert]`:
  - Get historical alerts
  
- `async def start_monitoring(self, data_source: Callable, interval_seconds: int = 30)`:
  - Start background monitoring loop
  - Periodically evaluate rules
  
- `async def _alert_loop(self, data_source: Callable, interval_seconds: int)`:
  - Background evaluation loop

**Default alert rules:**
```python
DEFAULT_ALERT_RULES = [
    # Memory alerts
    AlertRule(
        name="high_memory_usage",
        description="Memory usage exceeds 80%",
        severity=AlertSeverity.WARNING,
        condition_fn=lambda data: data.get("memory_percent", 0) > 80,
        cooldown_minutes=10,
    ),
    AlertRule(
        name="critical_memory_usage",
        description="Memory usage exceeds 90% (approaching 10GB limit)",
        severity=AlertSeverity.CRITICAL,
        condition_fn=lambda data: data.get("memory_percent", 0) > 90,
        cooldown_minutes=5,
    ),
    
    # CPU alerts
    AlertRule(
        name="high_cpu_usage",
        description="CPU usage exceeds 85% for extended period",
        severity=AlertSeverity.WARNING,
        condition_fn=lambda data: data.get("cpu_percent", 0) > 85,
        cooldown_minutes=15,
    ),
    
    # Health alerts
    AlertRule(
        name="platform_unhealthy",
        description="One or more platforms are unhealthy",
        severity=AlertSeverity.WARNING,
        condition_fn=lambda data: data.get("unhealthy_platforms", 0) > 0,
        cooldown_minutes=5,
    ),
    
    # Memory growth alert
    AlertRule(
        name="memory_growth_detected",
        description="Memory growing faster than expected (possible leak)",
        severity=AlertSeverity.WARNING,
        condition_fn=lambda data: data.get("memory_growth_percent_24h", 0) > 10,
        cooldown_minutes=60,
    ),
    
    # Emotional state alerts (for monitoring)
    AlertRule(
        name="extreme_loneliness",
        description="Demi's loneliness is very high (>0.9)",
        severity=AlertSeverity.INFO,
        condition_fn=lambda data: data.get("emotions", {}).get("loneliness", 0) > 0.9,
        cooldown_minutes=60,
    ),
    AlertRule(
        name="extreme_frustration",
        description="Demi's frustration is very high (>0.9)",
        severity=AlertSeverity.INFO,
        condition_fn=lambda data: data.get("emotions", {}).get("frustration", 0) > 0.9,
        cooldown_minutes=60,
    ),
]
```

**Notification channels:**
```python
class NotificationChannel:
    """Base class for alert notifications."""
    
    async def send(self, alert: Alert):
        raise NotImplementedError


class LogNotificationChannel(NotificationChannel):
    """Send alerts to log."""
    
    async def send(self, alert: Alert):
        logger.warning(
            "alert_triggered",
            alert_id=alert.id,
            rule=alert.rule_name,
            severity=alert.severity.value,
            message=alert.message,
        )


class DiscordNotificationChannel(NotificationChannel):
    """Send alerts to Discord channel."""
    
    def __init__(self, webhook_url: str):
        self.webhook_url = webhook_url
    
    async def send(self, alert: Alert):
        # Implementation for Discord webhook
        import aiohttp
        
        color_map = {
            AlertSeverity.INFO: 3447003,      # Blue
            AlertSeverity.WARNING: 15158332,  # Yellow/Orange
            AlertSeverity.CRITICAL: 15158332, # Red
        }
        
        embed = {
            "title": f"ðŸš¨ Alert: {alert.rule_name}",
            "description": alert.message,
            "color": color_map.get(alert.severity, 0),
            "timestamp": alert.timestamp.isoformat(),
            "fields": [
                {"name": "Severity", "value": alert.severity.value.upper(), "inline": True},
                {"name": "Alert ID", "value": alert.id[:8], "inline": True},
            ],
        }
        
        async with aiohttp.ClientSession() as session:
            await session.post(self.webhook_url, json={"embeds": [embed]})
```

**Global instance:**
```python
_alert_manager_instance: Optional[AlertManager] = None


def get_alert_manager() -> AlertManager:
    """Get global alert manager instance."""
    global _alert_manager_instance
    if _alert_manager_instance is None:
        _alert_manager_instance = AlertManager()
        # Add default rules
        for rule in DEFAULT_ALERT_RULES:
            _alert_manager_instance.add_rule(rule)
    return _alert_manager_instance
```
</action>
  <verify>
1. Import check: `python -c "from src.monitoring.alerting import AlertManager, AlertRule, Alert, AlertSeverity; print('Alerting import OK')"`
2. Alert creation:
   ```python
   from datetime import datetime
   from src.monitoring.alerting import Alert, AlertSeverity
   
   alert = Alert(
       id="test-123",
       rule_name="test_rule",
       severity=AlertSeverity.WARNING,
       message="Test alert",
       timestamp=datetime.now()
   )
   assert alert.is_active
   print(f"Alert created: {alert.severity.value}")
   ```
3. Rule condition:
   ```python
   from src.monitoring.alerting import AlertRule, AlertSeverity
   
   rule = AlertRule(
       name="test_rule",
       description="Test",
       severity=AlertSeverity.INFO,
       condition_fn=lambda data: data.get("test") > 5,
       cooldown_minutes=0
   )
   assert rule.check_condition({"test": 10})
   assert not rule.check_condition({"test": 3})
   print("Rule condition test passed")
   ```
4. Default rules:
   ```python
   from src.monitoring.alerting import DEFAULT_ALERT_RULES
   print(f"Default rules: {len(DEFAULT_ALERT_RULES)}")
   for rule in DEFAULT_ALERT_RULES:
       print(f"  - {rule.name} ({rule.severity.value})")
   ```
  </verify>
  <done>AlertManager created with configurable rules, notification channels, and cooldown support</done>
</task>

<task type="auto">
  <name>Create web dashboard server with API endpoints</name>
  <files>src/web/dashboard.py</files>
  <action>Create `src/web/dashboard.py` with dashboard backend:

**Imports:**
- `import asyncio`
- `import json`
- `from typing import Dict, List, Optional, Any`
- `from datetime import datetime`
- `from pathlib import Path`
- `import aiohttp`
- `from aiohttp import web`
- `from src.core.logger import get_logger`
- `from src.conductor.resource_monitor import ResourceMonitor`
- `from src.conductor.health import HealthMonitor, get_health_monitor`
- `from src.emotion.persistence import EmotionPersistence`
- `from src.emotion.models import EmotionalState`
- `from src.monitoring.alerting import AlertManager, get_alert_manager`

**Routes definition:**
```python
routes = web.RouteTableDef()
```

**Class DashboardServer:**
- `__init__(self, host: str = "localhost", port: int = 8080)`:
  - Initialize web server
  - Setup routes
  - Configure data sources
  
- `async def start(self)`:
  - Start aiohttp server
  - Begin background data collection
  
- `async def stop(self)`:
  - Graceful shutdown
  - Cleanup resources
  
- `async def _get_system_metrics(self) -> Dict`:
  - Collect current system metrics
  - Format for dashboard
  
- `async def _get_emotional_state(self) -> Optional[Dict]`:
  - Fetch current emotional state
  - Format for visualization

**API Endpoints:**
```python
@routes.get('/api/health')
async def api_health(request: web.Request) -> web.Response:
    """Get overall system health status."""
    health_monitor = get_health_monitor()
    
    status = {
        "status": "healthy",  # aggregated
        "timestamp": datetime.now().isoformat(),
        "platforms": {},
        "resources": {},
    }
    
    # Get platform statuses
    for platform, result in health_monitor.get_all_statuses().items():
        status["platforms"][platform] = {
            "status": result.status.value,
            "duration_ms": result.duration * 1000,
            "error": result.error,
        }
    
    # Get resource metrics
    resource_metrics = health_monitor.get_resource_metrics()
    if resource_metrics:
        status["resources"] = {
            "ram_percent": resource_metrics.ram_percent,
            "cpu_percent": resource_metrics.cpu_percent,
            "disk_percent": resource_metrics.disk_percent,
        }
    
    return web.json_response(status)


@routes.get('/api/metrics')
async def api_metrics(request: web.Request) -> web.Response:
    """Get current resource metrics."""
    dashboard = request.app['dashboard']
    metrics = await dashboard._get_system_metrics()
    return web.json_response(metrics)


@routes.get('/api/emotions')
async def api_emotions(request: web.Request) -> web.Response:
    """Get current emotional state."""
    dashboard = request.app['dashboard']
    emotions = await dashboard._get_emotional_state()
    
    if emotions is None:
        return web.json_response(
            {"error": "No emotional state available"},
            status=404
        )
    
    return web.json_response(emotions)


@routes.get('/api/emotions/history')
async def api_emotions_history(request: web.Request) -> web.Response:
    """Get emotional state history."""
    hours = int(request.query.get('hours', 24))
    
    # This would fetch from EmotionPersistence
    # For now, return empty or mock data
    history = {
        "hours": hours,
        "data": [],  # Would be populated from database
    }
    
    return web.json_response(history)


@routes.get('/api/alerts')
async def api_alerts(request: web.Request) -> web.Response:
    """Get active and recent alerts."""
    alert_manager = get_alert_manager()
    
    active_only = request.query.get('active', 'false').lower() == 'true'
    
    if active_only:
        alerts = alert_manager.get_active_alerts()
    else:
        alerts = alert_manager.get_alert_history(limit=50)
    
    return web.json_response({
        "alerts": [
            {
                "id": alert.id,
                "rule": alert.rule_name,
                "severity": alert.severity.value,
                "message": alert.message,
                "timestamp": alert.timestamp.isoformat(),
                "resolved": not alert.is_active,
                "duration_seconds": alert.duration_seconds,
            }
            for alert in alerts
        ]
    })


@routes.post('/api/alerts/{alert_id}/resolve')
async def api_resolve_alert(request: web.Request) -> web.Response:
    """Manually resolve an alert."""
    alert_id = request.match_info['alert_id']
    alert_manager = get_alert_manager()
    
    alert_manager.resolve_alert(alert_id)
    
    return web.json_response({"status": "resolved", "alert_id": alert_id})


@routes.get('/api/uptime')
async def api_uptime(request: web.Request) -> web.Response:
    """Get system uptime information."""
    # This would track actual uptime
    # For now, return placeholder
    return web.json_response({
        "uptime_seconds": 0,  # Would be calculated
        "started_at": datetime.now().isoformat(),
    })


@routes.get('/')
async def index(request: web.Request) -> web.Response:
    """Serve dashboard HTML."""
    static_dir = Path(__file__).parent / "static"
    index_file = static_dir / "index.html"
    
    if index_file.exists():
        return web.FileResponse(index_file)
    else:
        return web.Response(
            text="Dashboard not built. Please ensure static files exist.",
            status=404
        )
```

**WebSocket for real-time updates:**
```python
@routes.get('/ws')
async def websocket_handler(request: web.Request) -> web.WebSocketResponse:
    """WebSocket for real-time dashboard updates."""
    ws = web.WebSocketResponse()
    await ws.prepare(request)
    
    # Register connection
    dashboard = request.app['dashboard']
    dashboard.websocket_connections.add(ws)
    
    try:
        async for msg in ws:
            if msg.type == aiohttp.WSMsgType.TEXT:
                # Handle client messages (e.g., subscription changes)
                data = json.loads(msg.data)
                if data.get('action') == 'ping':
                    await ws.send_json({'type': 'pong'})
            elif msg.type == aiohttp.WSMsgType.ERROR:
                logger.error(f"WebSocket error: {ws.exception()}")
    finally:
        dashboard.websocket_connections.discard(ws)
    
    return ws


async def broadcast_update(app: web.Application, data: Dict):
    """Broadcast update to all connected WebSocket clients."""
    dashboard = app.get('dashboard')
    if not dashboard:
        return
    
    message = json.dumps(data)
    dead_connections = set()
    
    for ws in dashboard.websocket_connections:
        try:
            await ws.send_str(message)
        except:
            dead_connections.add(ws)
    
    # Cleanup dead connections
    dashboard.websocket_connections -= dead_connections
```

**Dashboard implementation:**
```python
class DashboardServer:
    """Web dashboard server for health monitoring."""
    
    def __init__(
        self,
        host: str = "localhost",
        port: int = 8080,
        update_interval: int = 5,
    ):
        self.host = host
        self.port = port
        self.update_interval = update_interval
        
        self.app = web.Application()
        self.app['dashboard'] = self
        self.app.router.add_routes(routes)
        
        # Static files
        static_dir = Path(__file__).parent / "static"
        if static_dir.exists():
            self.app.router.add_static('/static', static_dir)
        
        self.runner: Optional[web.AppRunner] = None
        self.site: Optional[web.TCPSite] = None
        self.websocket_connections: set = set()
        
        self._update_task: Optional[asyncio.Task] = None
        self._running = False
        
        logger.info("DashboardServer initialized", host=host, port=port)
    
    async def start(self):
        """Start the dashboard server."""
        self.runner = web.AppRunner(self.app)
        await self.runner.setup()
        
        self.site = web.TCPSite(self.runner, self.host, self.port)
        await self.site.start()
        
        self._running = True
        self._update_task = asyncio.create_task(self._update_loop())
        
        logger.info(f"Dashboard server started at http://{self.host}:{self.port}")
    
    async def stop(self):
        """Stop the dashboard server."""
        self._running = False
        
        if self._update_task:
            self._update_task.cancel()
            try:
                await self._update_task
            except asyncio.CancelledError:
                pass
        
        # Close all WebSocket connections
        for ws in self.websocket_connections:
            await ws.close()
        self.websocket_connections.clear()
        
        if self.runner:
            await self.runner.cleanup()
        
        logger.info("Dashboard server stopped")
    
    async def _update_loop(self):
        """Background loop to push updates to clients."""
        while self._running:
            try:
                # Collect data
                metrics = await self._get_system_metrics()
                emotions = await self._get_emotional_state()
                
                # Broadcast to all connected clients
                await broadcast_update(self.app, {
                    "type": "update",
                    "timestamp": datetime.now().isoformat(),
                    "metrics": metrics,
                    "emotions": emotions,
                })
                
                await asyncio.sleep(self.update_interval)
                
            except asyncio.CancelledError:
                break
            except Exception as e:
                logger.error("Dashboard update error", error=str(e))
                await asyncio.sleep(self.update_interval)
    
    async def _get_system_metrics(self) -> Dict:
        """Collect current system metrics."""
        try:
            import psutil
            memory = psutil.virtual_memory()
            cpu = psutil.cpu_percent(interval=0.1)
            
            return {
                "memory_percent": memory.percent,
                "memory_used_gb": memory.used / (1024**3),
                "memory_available_gb": memory.available / (1024**3),
                "cpu_percent": cpu,
                "timestamp": datetime.now().isoformat(),
            }
        except Exception as e:
            logger.error("Failed to get metrics", error=str(e))
            return {"error": str(e)}
    
    async def _get_emotional_state(self) -> Optional[Dict]:
        """Fetch current emotional state."""
        try:
            # This would integrate with actual emotion system
            # For now, return placeholder
            return {
                "loneliness": 0.5,
                "excitement": 0.5,
                "frustration": 0.5,
                "jealousy": 0.5,
                "vulnerability": 0.5,
                "confidence": 0.5,
                "curiosity": 0.5,
                "affection": 0.5,
                "defensiveness": 0.5,
                "last_updated": datetime.now().isoformat(),
            }
        except Exception as e:
            logger.error("Failed to get emotions", error=str(e))
            return None


# Convenience function
async def start_dashboard(host: str = "localhost", port: int = 8080) -> DashboardServer:
    """Start dashboard server."""
    server = DashboardServer(host=host, port=port)
    await server.start()
    return server
```
</action>
  <verify>
1. Import check: `python -c "from src.web.dashboard import DashboardServer, start_dashboard; print('Dashboard import OK')"`
2. Route count:
   ```python
   from src.web.dashboard import routes
   print(f"Routes defined: {len(list(routes))}")
   for route in routes:
       print(f"  {route.method} {route.path}")
   ```
3. Server creation:
   ```python
   import asyncio
   from src.web.dashboard import DashboardServer
   
   async def test():
       server = DashboardServer(host="localhost", port=8081)
       print(f"Server created: {server.host}:{server.port}")
       # Don't actually start in test
   
   asyncio.run(test())
   ```
4. API endpoint list: Verify all required endpoints exist
  </verify>
  <done>DashboardServer created with REST API, WebSocket support, and background update loop</done>
</task>

<task type="auto">
  <name>Create dashboard HTML frontend</name>
  <files>src/web/static/index.html</files>
  <action>Create `src/web/static/index.html`:

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Demi Health Dashboard</title>
    <link rel="stylesheet" href="/static/styles.css">
</head>
<body>
    <div class="container">
        <header>
            <h1>ðŸ”® Demi Health Dashboard</h1>
            <div class="connection-status" id="connection-status">Connecting...</div>
        </header>

        <main>
            <!-- System Health Overview -->
            <section class="card health-overview">
                <h2>System Health</h2>
                <div class="health-grid">
                    <div class="health-item">
                        <span class="label">Status</span>
                        <span class="value" id="health-status">Unknown</span>
                    </div>
                    <div class="health-item">
                        <span class="label">Uptime</span>
                        <span class="value" id="uptime">--</span>
                    </div>
                    <div class="health-item">
                        <span class="label">Last Update</span>
                        <span class="value" id="last-update">--</span>
                    </div>
                </div>
            </section>

            <!-- Resource Metrics -->
            <section class="card resources">
                <h2>Resource Usage</h2>
                <div class="metrics-grid">
                    <div class="metric">
                        <div class="metric-label">Memory</div>
                        <div class="metric-bar">
                            <div class="metric-fill" id="memory-bar"></div>
                        </div>
                        <div class="metric-value" id="memory-value">--</div>
                    </div>
                    <div class="metric">
                        <div class="metric-label">CPU</div>
                        <div class="metric-bar">
                            <div class="metric-fill" id="cpu-bar"></div>
                        </div>
                        <div class="metric-value" id="cpu-value">--</div>
                    </div>
                </div>
                <div class="memory-details">
                    <span>Used: <span id="memory-used">--</span> GB</span>
                    <span>Available: <span id="memory-available">--</span> GB</span>
                </div>
            </section>

            <!-- Emotional State Visualization -->
            <section class="card emotions">
                <h2>Demi's Emotional State</h2>
                <div class="emotion-radar-container">
                    <canvas id="emotion-radar" width="300" height="300"></canvas>
                </div>
                <div class="emotion-legend">
                    <div class="emotion-item">
                        <span class="emotion-dot" style="background: #ff6b6b;"></span>
                        <span>Loneliness</span>
                        <span class="emotion-value" id="emotion-loneliness">--</span>
                    </div>
                    <div class="emotion-item">
                        <span class="emotion-dot" style="background: #4ecdc4;"></span>
                        <span>Excitement</span>
                        <span class="emotion-value" id="emotion-excitement">--</span>
                    </div>
                    <div class="emotion-item">
                        <span class="emotion-dot" style="background: #ffe66d;"></span>
                        <span>Frustration</span>
                        <span class="emotion-value" id="emotion-frustration">--</span>
                    </div>
                    <div class="emotion-item">
                        <span class="emotion-dot" style="background: #95e1d3;"></span>
                        <span>Confidence</span>
                        <span class="emotion-value" id="emotion-confidence">--</span>
                    </div>
                    <div class="emotion-item">
                        <span class="emotion-dot" style="background: #f38181;"></span>
                        <span>Affection</span>
                        <span class="emotion-value" id="emotion-affection">--</span>
                    </div>
                </div>
            </section>

            <!-- Active Alerts -->
            <section class="card alerts">
                <h2>Active Alerts</h2>
                <div id="alerts-container">
                    <div class="alert-placeholder">No active alerts</div>
                </div>
            </section>

            <!-- Platform Status -->
            <section class="card platforms">
                <h2>Platform Status</h2>
                <div class="platform-grid" id="platform-grid">
                    <div class="platform-item unknown">
                        <span class="platform-name">Discord</span>
                        <span class="platform-status">Unknown</span>
                    </div>
                    <div class="platform-item unknown">
                        <span class="platform-name">Android</span>
                        <span class="platform-status">Unknown</span>
                    </div>
                    <div class="platform-item unknown">
                        <span class="platform-name">Ollama</span>
                        <span class="platform-status">Unknown</span>
                    </div>
                </div>
            </section>

            <!-- Memory History Chart -->
            <section class="card chart">
                <h2>Memory Usage History</h2>
                <canvas id="memory-chart" width="600" height="200"></canvas>
            </section>
        </main>

        <footer>
            <p>Demi Health Dashboard v1.0 | <span id="websocket-status">Disconnected</span></p>
        </footer>
    </div>

    <script src="/static/dashboard.js"></script>
</body>
</html>
```
</action>
  <verify>
1. HTML validation: Verify structure and class names
2. Element IDs: Check all required IDs exist for JS binding
3. Canvas elements: Verify emotion radar and memory chart canvases
4. Section coverage: All major sections present (health, resources, emotions, alerts, platforms)
  </verify>
  <done>Dashboard HTML created with all required sections and data binding points</done>
</task>

<task type="auto">
  <name>Create dashboard JavaScript for real-time updates</name>
  <files>src/web/static/dashboard.js</files>
  <action>Create `src/web/static/dashboard.js`:

```javascript
/**
 * Demi Health Dashboard - Real-time updates and visualization
 */

class DemiDashboard {
    constructor() {
        this.ws = null;
        this.reconnectInterval = 5000;
        this.updateInterval = null;
        this.memoryHistory = [];
        this.maxHistoryPoints = 60; // 5 minutes at 5s intervals
        
        this.init();
    }
    
    init() {
        this.connectWebSocket();
        this.setupEventListeners();
        this.fetchInitialData();
    }
    
    connectWebSocket() {
        const wsUrl = `ws://${window.location.host}/ws`;
        this.ws = new WebSocket(wsUrl);
        
        this.ws.onopen = () => {
            console.log('WebSocket connected');
            this.updateConnectionStatus('connected');
        };
        
        this.ws.onmessage = (event) => {
            const data = JSON.parse(event.data);
            this.handleMessage(data);
        };
        
        this.ws.onclose = () => {
            console.log('WebSocket disconnected');
            this.updateConnectionStatus('disconnected');
            
            // Attempt to reconnect
            setTimeout(() => this.connectWebSocket(), this.reconnectInterval);
        };
        
        this.ws.onerror = (error) => {
            console.error('WebSocket error:', error);
            this.updateConnectionStatus('error');
        };
    }
    
    updateConnectionStatus(status) {
        const statusEl = document.getElementById('connection-status');
        const wsStatusEl = document.getElementById('websocket-status');
        
        const statusMap = {
            'connected': { text: 'â— Live', class: 'connected' },
            'disconnected': { text: 'â—‹ Disconnected', class: 'disconnected' },
            'connecting': { text: 'â‹¯ Connecting', class: 'connecting' },
            'error': { text: 'âœ• Error', class: 'error' },
        };
        
        const statusInfo = statusMap[status] || statusMap['disconnected'];
        
        if (statusEl) {
            statusEl.textContent = statusInfo.text;
            statusEl.className = `connection-status ${statusInfo.class}`;
        }
        
        if (wsStatusEl) {
            wsStatusEl.textContent = statusInfo.text;
            wsStatusEl.className = statusInfo.class;
        }
    }
    
    handleMessage(data) {
        if (data.type === 'update') {
            this.updateMetrics(data.metrics);
            this.updateEmotions(data.emotions);
            this.updateTimestamp(data.timestamp);
        } else if (data.type === 'alert') {
            this.addAlert(data.alert);
        }
    }
    
    async fetchInitialData() {
        try {
            // Fetch health status
            const healthRes = await fetch('/api/health');
            if (healthRes.ok) {
                const health = await healthRes.json();
                this.updateHealthStatus(health);
            }
            
            // Fetch emotions
            const emotionsRes = await fetch('/api/emotions');
            if (emotionsRes.ok) {
                const emotions = await emotionsRes.json();
                this.updateEmotions(emotions);
            }
            
            // Fetch alerts
            const alertsRes = await fetch('/api/alerts?active=true');
            if (alertsRes.ok) {
                const alerts = await alertsRes.json();
                this.updateAlerts(alerts.alerts);
            }
            
        } catch (error) {
            console.error('Failed to fetch initial data:', error);
        }
    }
    
    updateMetrics(metrics) {
        if (!metrics || metrics.error) return;
        
        // Update memory
        const memoryPercent = metrics.memory_percent || 0;
        const memoryBar = document.getElementById('memory-bar');
        const memoryValue = document.getElementById('memory-value');
        const memoryUsed = document.getElementById('memory-used');
        const memoryAvailable = document.getElementById('memory-available');
        
        if (memoryBar) {
            memoryBar.style.width = `${memoryPercent}%`;
            memoryBar.className = 'metric-fill';
            if (memoryPercent > 90) memoryBar.classList.add('critical');
            else if (memoryPercent > 80) memoryBar.classList.add('warning');
        }
        
        if (memoryValue) memoryValue.textContent = `${memoryPercent.toFixed(1)}%`;
        if (memoryUsed) memoryUsed.textContent = (metrics.memory_used_gb || 0).toFixed(2);
        if (memoryAvailable) memoryAvailable.textContent = (metrics.memory_available_gb || 0).toFixed(2);
        
        // Update CPU
        const cpuPercent = metrics.cpu_percent || 0;
        const cpuBar = document.getElementById('cpu-bar');
        const cpuValue = document.getElementById('cpu-value');
        
        if (cpuBar) {
            cpuBar.style.width = `${cpuPercent}%`;
            cpuBar.className = 'metric-fill';
            if (cpuPercent > 90) cpuBar.classList.add('critical');
            else if (cpuPercent > 80) cpuBar.classList.add('warning');
        }
        
        if (cpuValue) cpuValue.textContent = `${cpuPercent.toFixed(1)}%`;
        
        // Update memory history chart
        this.updateMemoryHistory(metrics.memory_used_gb || 0);
    }
    
    updateMemoryHistory(memoryGb) {
        this.memoryHistory.push({
            time: new Date(),
            value: memoryGb
        });
        
        // Keep only recent history
        if (this.memoryHistory.length > this.maxHistoryPoints) {
            this.memoryHistory.shift();
        }
        
        this.drawMemoryChart();
    }
    
    drawMemoryChart() {
        const canvas = document.getElementById('memory-chart');
        if (!canvas || this.memoryHistory.length < 2) return;
        
        const ctx = canvas.getContext('2d');
        const width = canvas.width;
        const height = canvas.height;
        
        // Clear canvas
        ctx.clearRect(0, 0, width, height);
        
        // Find min/max for scaling
        const values = this.memoryHistory.map(h => h.value);
        const min = Math.min(...values) * 0.9;
        const max = Math.max(...values) * 1.1;
        const range = max - min || 1;
        
        // Draw grid
        ctx.strokeStyle = '#eee';
        ctx.lineWidth = 1;
        for (let i = 0; i <= 4; i++) {
            const y = height - (i / 4) * height * 0.8 - height * 0.1;
            ctx.beginPath();
            ctx.moveTo(40, y);
            ctx.lineTo(width - 10, y);
            ctx.stroke();
            
            // Y-axis labels
            ctx.fillStyle = '#666';
            ctx.font = '10px sans-serif';
            ctx.textAlign = 'right';
            const label = (min + (i / 4) * range).toFixed(1);
            ctx.fillText(`${label}GB`, 35, y + 3);
        }
        
        // Draw line
        ctx.strokeStyle = '#4a90d9';
        ctx.lineWidth = 2;
        ctx.beginPath();
        
        this.memoryHistory.forEach((point, index) => {
            const x = 40 + (index / (this.maxHistoryPoints - 1)) * (width - 50);
            const y = height - ((point.value - min) / range) * height * 0.8 - height * 0.1;
            
            if (index === 0) {
                ctx.moveTo(x, y);
            } else {
                ctx.lineTo(x, y);
            }
        });
        
        ctx.stroke();
        
        // Draw fill
        ctx.fillStyle = 'rgba(74, 144, 217, 0.1)';
        ctx.lineTo(width - 10, height - height * 0.1);
        ctx.lineTo(40, height - height * 0.1);
        ctx.closePath();
        ctx.fill();
    }
    
    updateEmotions(emotions) {
        if (!emotions) return;
        
        // Update emotion values
        const emotionNames = ['loneliness', 'excitement', 'frustration', 'jealousy', 
                              'vulnerability', 'confidence', 'curiosity', 'affection', 'defensiveness'];
        
        emotionNames.forEach(name => {
            const el = document.getElementById(`emotion-${name}`);
            if (el && emotions[name] !== undefined) {
                const value = emotions[name];
                el.textContent = (value * 100).toFixed(0) + '%';
                
                // Color code based on intensity
                if (value > 0.8) el.className = 'emotion-value high';
                else if (value > 0.6) el.className = 'emotion-value medium';
                else el.className = 'emotion-value low';
            }
        });
        
        // Draw emotion radar chart
        this.drawEmotionRadar(emotions);
    }
    
    drawEmotionRadar(emotions) {
        const canvas = document.getElementById('emotion-radar');
        if (!canvas || !emotions) return;
        
        const ctx = canvas.getContext('2d');
        const centerX = canvas.width / 2;
        const centerY = canvas.height / 2;
        const radius = Math.min(centerX, centerY) - 40;
        
        const emotionsList = [
            'loneliness', 'excitement', 'frustration', 
            'jealousy', 'vulnerability', 'confidence',
            'curiosity', 'affection', 'defensiveness'
        ];
        
        const angleStep = (2 * Math.PI) / emotionsList.length;
        
        // Clear
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // Draw grid circles
        ctx.strokeStyle = '#ddd';
        ctx.lineWidth = 1;
        for (let i = 1; i <= 4; i++) {
            ctx.beginPath();
            ctx.arc(centerX, centerY, (radius / 4) * i, 0, 2 * Math.PI);
            ctx.stroke();
        }
        
        // Draw axis lines
        emotionsList.forEach((_, i) => {
            const angle = i * angleStep - Math.PI / 2;
            const x = centerX + Math.cos(angle) * radius;
            const y = centerY + Math.sin(angle) * radius;
            
            ctx.beginPath();
            ctx.moveTo(centerX, centerY);
            ctx.lineTo(x, y);
            ctx.stroke();
            
            // Labels
            const labelX = centerX + Math.cos(angle) * (radius + 20);
            const labelY = centerY + Math.sin(angle) * (radius + 20);
            
            ctx.fillStyle = '#666';
            ctx.font = '11px sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(emotionsList[i].substring(0, 3), labelX, labelY);
        });
        
        // Draw emotion polygon
        ctx.fillStyle = 'rgba(74, 144, 217, 0.3)';
        ctx.strokeStyle = '#4a90d9';
        ctx.lineWidth = 2;
        ctx.beginPath();
        
        emotionsList.forEach((name, i) => {
            const value = emotions[name] || 0.5;
            const angle = i * angleStep - Math.PI / 2;
            const x = centerX + Math.cos(angle) * radius * value;
            const y = centerY + Math.sin(angle) * radius * value;
            
            if (i === 0) {
                ctx.moveTo(x, y);
            } else {
                ctx.lineTo(x, y);
            }
        });
        
        ctx.closePath();
        ctx.fill();
        ctx.stroke();
    }
    
    updateHealthStatus(health) {
        const statusEl = document.getElementById('health-status');
        if (statusEl && health.status) {
            statusEl.textContent = health.status.toUpperCase();
            statusEl.className = `value status-${health.status}`;
        }
        
        // Update platform statuses
        if (health.platforms) {
            const platformGrid = document.getElementById('platform-grid');
            if (platformGrid) {
                platformGrid.innerHTML = '';
                
                Object.entries(health.platforms).forEach(([name, info]) => {
                    const div = document.createElement('div');
                    div.className = `platform-item ${info.status}`;
                    div.innerHTML = `
                        <span class="platform-name">${name}</span>
                        <span class="platform-status">${info.status}</span>
                    `;
                    platformGrid.appendChild(div);
                });
            }
        }
    }
    
    updateAlerts(alerts) {
        const container = document.getElementById('alerts-container');
        if (!container) return;
        
        if (!alerts || alerts.length === 0) {
            container.innerHTML = '<div class="alert-placeholder">No active alerts</div>';
            return;
        }
        
        container.innerHTML = '';
        alerts.forEach(alert => {
            const div = document.createElement('div');
            div.className = `alert-item ${alert.severity}`;
            div.innerHTML = `
                <div class="alert-header">
                    <span class="alert-severity">${alert.severity.toUpperCase()}</span>
                    <span class="alert-time">${new Date(alert.timestamp).toLocaleTimeString()}</span>
                </div>
                <div class="alert-message">${alert.message}</div>
                <div class="alert-rule">Rule: ${alert.rule}</div>
            `;
            container.appendChild(div);
        });
    }
    
    addAlert(alert) {
        // Refresh alerts list
        this.fetchInitialData();
    }
    
    updateTimestamp(timestamp) {
        const el = document.getElementById('last-update');
        if (el && timestamp) {
            const date = new Date(timestamp);
            el.textContent = date.toLocaleTimeString();
        }
    }
    
    setupEventListeners() {
        // Handle window resize for canvas
        window.addEventListener('resize', () => {
            this.drawEmotionRadar();
            this.drawMemoryChart();
        });
    }
}

// Initialize dashboard when DOM is ready
document.addEventListener('DOMContentLoaded', () => {
    window.dashboard = new DemiDashboard();
});
```
</action>
  <verify>
1. JavaScript syntax: `node --check /dev/stdin << 'EOF'` (or manual check)
2. Class structure: Verify DemiDashboard class has all required methods
3. Canvas drawing: Verify drawEmotionRadar and drawMemoryChart methods
4. WebSocket handling: Check connection lifecycle management
5. API endpoints: Verify all fetch calls match backend routes
  </verify>
  <done>Dashboard JavaScript created with WebSocket support, real-time updates, and canvas visualization</done>
</task>

<task type="auto">
  <name>Create dashboard CSS styles</name>
  <files>src/web/static/styles.css</files>
  <action>Create `src/web/static/styles.css`:

```css
/* Demi Health Dashboard Styles */

:root {
    --primary-color: #6c5ce7;
    --secondary-color: #a29bfe;
    --success-color: #00b894;
    --warning-color: #fdcb6e;
    --danger-color: #e17055;
    --info-color: #74b9ff;
    --bg-color: #f8f9fa;
    --card-bg: #ffffff;
    --text-color: #2d3436;
    --text-muted: #636e72;
    --border-color: #dfe6e9;
}

* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
    background-color: var(--bg-color);
    color: var(--text-color);
    line-height: 1.6;
}

.container {
    max-width: 1200px;
    margin: 0 auto;
    padding: 20px;
}

/* Header */
header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 30px;
    padding-bottom: 20px;
    border-bottom: 2px solid var(--border-color);
}

header h1 {
    font-size: 1.8rem;
    color: var(--primary-color);
}

.connection-status {
    padding: 6px 12px;
    border-radius: 20px;
    font-size: 0.85rem;
    font-weight: 500;
}

.connection-status.connected {
    background: var(--success-color);
    color: white;
}

.connection-status.disconnected {
    background: var(--danger-color);
    color: white;
}

.connection-status.connecting {
    background: var(--warning-color);
    color: var(--text-color);
}

.connection-status.error {
    background: var(--danger-color);
    color: white;
}

/* Cards */
.card {
    background: var(--card-bg);
    border-radius: 12px;
    padding: 24px;
    margin-bottom: 24px;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
}

.card h2 {
    font-size: 1.2rem;
    margin-bottom: 16px;
    color: var(--text-color);
}

/* Main Grid */
main {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
    gap: 24px;
}

/* Health Overview */
.health-grid {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 16px;
}

.health-item {
    text-align: center;
}

.health-item .label {
    display: block;
    font-size: 0.85rem;
    color: var(--text-muted);
    margin-bottom: 4px;
}

.health-item .value {
    font-size: 1.3rem;
    font-weight: 600;
}

.status-healthy { color: var(--success-color); }
.status-degraded { color: var(--warning-color); }
.status-unhealthy { color: var(--danger-color); }

/* Resource Metrics */
.metrics-grid {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    gap: 20px;
    margin-bottom: 16px;
}

.metric {
    text-align: center;
}

.metric-label {
    font-size: 0.9rem;
    color: var(--text-muted);
    margin-bottom: 8px;
}

.metric-bar {
    height: 24px;
    background: var(--bg-color);
    border-radius: 12px;
    overflow: hidden;
    margin-bottom: 8px;
}

.metric-fill {
    height: 100%;
    background: var(--success-color);
    transition: width 0.3s ease, background 0.3s ease;
}

.metric-fill.warning {
    background: var(--warning-color);
}

.metric-fill.critical {
    background: var(--danger-color);
}

.metric-value {
    font-size: 1.2rem;
    font-weight: 600;
}

.memory-details {
    display: flex;
    justify-content: space-around;
    font-size: 0.9rem;
    color: var(--text-muted);
}

.memory-details span span {
    color: var(--text-color);
    font-weight: 500;
}

/* Emotional State */
.emotion-radar-container {
    display: flex;
    justify-content: center;
    margin-bottom: 20px;
}

#emotion-radar {
    max-width: 100%;
    height: auto;
}

.emotion-legend {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    gap: 8px;
}

.emotion-item {
    display: flex;
    align-items: center;
    gap: 8px;
    font-size: 0.9rem;
}

.emotion-dot {
    width: 12px;
    height: 12px;
    border-radius: 50%;
}

.emotion-value {
    margin-left: auto;
    font-weight: 600;
    font-size: 0.85rem;
}

.emotion-value.high { color: var(--danger-color); }
.emotion-value.medium { color: var(--warning-color); }
.emotion-value.low { color: var(--success-color); }

/* Alerts */
#alerts-container {
    max-height: 300px;
    overflow-y: auto;
}

.alert-placeholder {
    text-align: center;
    color: var(--text-muted);
    padding: 20px;
}

.alert-item {
    padding: 12px;
    border-radius: 8px;
    margin-bottom: 8px;
    border-left: 4px solid;
}

.alert-item.info {
    background: rgba(116, 185, 255, 0.1);
    border-left-color: var(--info-color);
}

.alert-item.warning {
    background: rgba(253, 203, 110, 0.1);
    border-left-color: var(--warning-color);
}

.alert-item.critical {
    background: rgba(225, 112, 85, 0.1);
    border-left-color: var(--danger-color);
}

.alert-header {
    display: flex;
    justify-content: space-between;
    margin-bottom: 4px;
}

.alert-severity {
    font-size: 0.75rem;
    font-weight: 600;
    text-transform: uppercase;
}

.alert-time {
    font-size: 0.75rem;
    color: var(--text-muted);
}

.alert-message {
    font-size: 0.9rem;
    margin-bottom: 4px;
}

.alert-rule {
    font-size: 0.75rem;
    color: var(--text-muted);
}

/* Platform Status */
.platform-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
    gap: 12px;
}

.platform-item {
    padding: 12px;
    border-radius: 8px;
    text-align: center;
    border: 2px solid var(--border-color);
}

.platform-item.healthy {
    border-color: var(--success-color);
    background: rgba(0, 184, 148, 0.05);
}

.platform-item.degraded {
    border-color: var(--warning-color);
    background: rgba(253, 203, 110, 0.05);
}

.platform-item.unhealthy {
    border-color: var(--danger-color);
    background: rgba(225, 112, 85, 0.05);
}

.platform-item.unknown {
    border-color: var(--border-color);
    background: var(--bg-color);
}

.platform-name {
    display: block;
    font-weight: 600;
    margin-bottom: 4px;
}

.platform-status {
    font-size: 0.8rem;
    color: var(--text-muted);
    text-transform: capitalize;
}

/* Charts */
.chart canvas {
    width: 100%;
    height: auto;
}

/* Footer */
footer {
    margin-top: 40px;
    padding-top: 20px;
    border-top: 1px solid var(--border-color);
    text-align: center;
    font-size: 0.85rem;
    color: var(--text-muted);
}

/* Responsive */
@media (max-width: 768px) {
    .container {
        padding: 12px;
    }
    
    header {
        flex-direction: column;
        gap: 12px;
        text-align: center;
    }
    
    .health-grid {
        grid-template-columns: 1fr;
    }
    
    .metrics-grid {
        grid-template-columns: 1fr;
    }
    
    .emotion-legend {
        grid-template-columns: 1fr;
    }
}

/* Scrollbar styling */
::-webkit-scrollbar {
    width: 8px;
}

::-webkit-scrollbar-track {
    background: var(--bg-color);
}

::-webkit-scrollbar-thumb {
    background: var(--border-color);
    border-radius: 4px;
}

::-webkit-scrollbar-thumb:hover {
    background: var(--text-muted);
}
```
</action>
  <verify>
1. CSS validation: Verify no syntax errors
2. Variable definitions: Check all CSS variables defined
3. Responsive design: Verify media query for mobile
4. Component coverage: All card types styled
5. Color scheme: Consistent use of status colors
  </verify>
  <done>Dashboard CSS created with responsive design, dark theme support, and all component styling</done>
</task>

<task type="auto">
  <name>Create web module initialization and dashboard startup script</name>
  <files>src/web/__init__.py, scripts/start_dashboard.sh</files>
  <action>Create `src/web/__init__.py` and `scripts/start_dashboard.sh`:

**File: src/web/__init__.py**
```python
"""Web interface module for Demi.

Provides health monitoring dashboard and API endpoints.
"""

from src.web.dashboard import DashboardServer, start_dashboard

__all__ = ["DashboardServer", "start_dashboard"]
__version__ = "1.0.0"
```

**File: scripts/start_dashboard.sh**
```bash
#!/bin/bash
#
# Start the Demi Health Dashboard
#

set -e

# Configuration
HOST=${1:-localhost}
PORT=${2:-8080}

# Colors
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
NC='\033[0m'

echo -e "${GREEN}Starting Demi Health Dashboard...${NC}"
echo "Host: $HOST"
echo "Port: $PORT"
echo ""

# Check Python
if ! command -v python3 &> /dev/null; then
    echo -e "${RED}Error: python3 not found${NC}"
    exit 1
fi

# Check if required files exist
if [ ! -f "src/web/dashboard.py" ]; then
    echo -e "${RED}Error: Dashboard module not found${NC}"
    exit 1
fi

# Start dashboard
python3 << EOF
import asyncio
import sys
sys.path.insert(0, '/home/mystiatech/projects/Demi')

from src.web import start_dashboard

async def main():
    try:
        server = await start_dashboard(host="$HOST", port=$PORT)
        print(f"Dashboard running at http://$HOST:$PORT")
        print("Press Ctrl+C to stop")
        
        # Keep running
        while True:
            await asyncio.sleep(1)
            
    except KeyboardInterrupt:
        print("\nStopping dashboard...")
        await server.stop()
        print("Dashboard stopped")

asyncio.run(main())
EOF
```

Make executable:
```bash
chmod +x scripts/start_dashboard.sh
```
</action>
  <verify>
1. Web module import: `python -c "from src.web import DashboardServer, start_dashboard; print('Web module import OK')"`
2. Script syntax: `bash -n /home/mystiatech/projects/Demi/scripts/start_dashboard.sh && echo "Script syntax OK"`
3. Script help: `bash scripts/start_dashboard.sh 2>&1 | head -10`
4. Exports check: `python -c "from src.web import __all__; print(f'Exports: {__all__}')"`
  </verify>
  <done>Web module initialization and dashboard startup script created</done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Alert system:** Test alert rules trigger correctly
2. **Dashboard server:** Verify starts and serves requests
3. **API endpoints:** Test all endpoints return expected data
4. **WebSocket:** Verify real-time updates work
5. **Frontend:** Verify HTML, CSS, JS load without errors
6. **Integration:** Test full dashboard flow

**Dashboard targets:**
- Server starts in <5 seconds
- API responds in <100ms
- WebSocket updates every 5 seconds
- Frontend renders all components
- Alerts display and can be resolved
- Emotional radar updates in real-time
</verification>

<success_criteria>
- AlertManager triggers alerts based on configurable rules
- DashboardServer provides REST API and WebSocket endpoints
- Dashboard frontend displays real-time metrics
- Emotional state visualization shows all 9 dimensions
- Memory usage chart shows historical trend
- Alert panel displays active alerts with severity
- Platform status shows health of each integration
- Dashboard accessible at http://localhost:8080
- Updates propagate in real-time via WebSocket
- Alert system prevents alert fatigue with cooldowns
</success_criteria>

<output>
After completion, create `.planning/phases/09-integration-testing/09-04-SUMMARY.md`
</output>
