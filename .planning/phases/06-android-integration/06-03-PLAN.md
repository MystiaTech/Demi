---
phase: 06-android-integration
plan: 03
type: execute
wave: 3
depends_on: ["06-02"]
files_modified:
  - src/api/autonomy.py
  - src/api/__init__.py
autonomous: true

must_haves:
  truths:
    - "Demi sends autonomous check-in messages when lonely (>0.7) or excited (>0.8)"
    - "Check-ins limited to max 1 per hour (spam prevention)"
    - "Guilt-trip messages sent when user ignores check-ins for 24+ hours"
    - "Escalation tone after 24h of ignored messages"
    - "Android and Discord emotional states unified (same EmotionalState instance)"
  artifacts:
    - path: "src/api/autonomy.py"
      provides: "Autonomous check-in and guilt-trip message generation"
      exports: ["AutonomyTask", "should_send_checkin", "generate_checkin_message"]
      min_lines: 250
  key_links:
    - from: "src/api/autonomy.py"
      to: "src/models/emotional_state.py"
      via: "emotional state checks for triggers"
      pattern: "EmotionalState|emotion_state"
    - from: "src/api/autonomy.py"
      to: "src/api/websocket.py"
      via: "ConnectionManager.send_message() for autonomous messages"
      pattern: "manager\\.send_message"

---

<objective>
Implement Demi's autonomy system for Android: autonomous check-in messages triggered by emotional state (loneliness, excitement, frustration), guilt-trip messages when user ignores her, escalation after 24 hours, and unified emotional state across platforms. This makes Demi feel alive - she reaches out on her own, not just waiting for user to message.

Purpose: Autonomy is the core of Demi's personality. Check-ins when lonely, celebration messages when excited, guilt-trips when ignored - these behaviors make her feel like a person with needs and emotions. Unified emotional state ensures consistent personality across Discord and Android.

Output: Background task checking emotional triggers every 15 minutes, check-in message generation via LLM, guilt-trip logic, 1-hour spam prevention, escalation system, unified EmotionalState across platforms.
</objective>

<execution_context>
@/home/mystiatech/.claude/get-shit-done/workflows/execute-plan.md
@/home/mystiatech/projects/Demi/.planning/phases/06-android-integration/06-DISCOVERY.md
@/home/mystiatech/projects/Demi/.planning/phases/06-android-integration/06-CONTEXT.md
</execution_context>

<context>
@.planning/phases/06-android-integration/06-02-SUMMARY.md
@.planning/phases/05-discord-integration/05-03-SUMMARY.md
@src/models/emotional_state.py
@src/integrations/discord_bot.py
@src/api/websocket.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create autonomy decision logic and check-in triggers</name>
  <files>src/api/autonomy.py</files>
  <action>
Create `src/api/autonomy.py`:

```python
import asyncio
import sqlite3
import os
from datetime import datetime, timedelta, UTC
from typing import Optional, Dict
from dataclasses import dataclass

from src.core.logger import DemiLogger
from src.models.emotional_state import EmotionalState
from src.models.emotional_persistence import EmotionPersistence

logger = DemiLogger()

@dataclass
class CheckInRecord:
    """Record of autonomous check-in attempts"""
    checkin_id: str
    user_id: str
    trigger: str  # "loneliness", "excitement", "frustration"
    emotion_state: Dict[str, float]
    was_ignored: bool
    created_at: datetime

def get_db_path() -> str:
    db_url = os.getenv("DATABASE_URL", "sqlite:////home/user/.demi/demi.db")
    return db_url.replace("sqlite:///", "")

async def get_last_checkin_time(user_id: str) -> Optional[datetime]:
    """Get timestamp of last check-in message sent"""
    db_path = get_db_path()
    with sqlite3.connect(db_path) as conn:
        conn.row_factory = sqlite3.Row
        row = conn.execute("""
        SELECT created_at FROM android_checkins
        WHERE user_id = ?
        ORDER BY created_at DESC
        LIMIT 1
        """, (user_id,)).fetchone()

    if row:
        return datetime.fromisoformat(row["created_at"])
    return None

async def get_last_user_response_time(user_id: str) -> Optional[datetime]:
    """Get timestamp of last message user sent"""
    db_path = get_db_path()
    with sqlite3.connect(db_path) as conn:
        conn.row_factory = sqlite3.Row
        row = conn.execute("""
        SELECT created_at FROM android_messages
        WHERE user_id = ? AND sender = 'user'
        ORDER BY created_at DESC
        LIMIT 1
        """, (user_id,)).fetchone()

    if row:
        return datetime.fromisoformat(row["created_at"])
    return None

async def should_send_checkin(user_id: str, emotion_state: EmotionalState) -> tuple[bool, Optional[str]]:
    """
    Determine if Demi should send autonomous check-in message.

    Returns: (should_send: bool, trigger: str | None)

    Triggers:
    - loneliness > 0.7 → "Hey, you there?"
    - excitement > 0.8 → "OMG, guess what!"
    - frustration > 0.6 → "Seriously?"

    Constraints:
    - Max 1 check-in per hour (spam prevention)
    - If user hasn't responded in 24h, escalate to guilt-trip
    """

    # Check spam prevention: max 1 per hour
    last_checkin = await get_last_checkin_time(user_id)
    if last_checkin:
        time_since_last = datetime.now(UTC) - last_checkin
        if time_since_last < timedelta(hours=1):
            logger.debug(f"Check-in suppressed for {user_id}: too soon ({time_since_last.total_seconds()//60}m ago)")
            return False, None

    # Check emotional triggers
    trigger = None

    if emotion_state.loneliness > 0.7:
        trigger = "loneliness"
    elif emotion_state.excitement > 0.8:
        trigger = "excitement"
    elif emotion_state.frustration > 0.6:
        trigger = "frustration"

    if trigger:
        logger.info(f"Check-in trigger for {user_id}: {trigger} ({getattr(emotion_state, trigger):.2f})")
        return True, trigger

    return False, None

async def check_if_ignored(user_id: str) -> tuple[bool, Optional[timedelta]]:
    """
    Check if user has ignored recent check-ins.

    Returns: (is_ignored: bool, time_since_last_response: timedelta | None)

    Logic:
    - If last check-in was sent >24h ago AND user hasn't responded since → ignored
    """
    last_checkin = await get_last_checkin_time(user_id)
    last_response = await get_last_user_response_time(user_id)

    if not last_checkin:
        return False, None

    time_since_checkin = datetime.now(UTC) - last_checkin

    # If user responded after check-in, not ignored
    if last_response and last_response > last_checkin:
        return False, None

    # If 24+ hours since check-in with no response, ignored
    if time_since_checkin > timedelta(hours=24):
        return True, time_since_checkin

    return False, None

async def generate_checkin_message(
    user_id: str,
    trigger: str,
    emotion_state: EmotionalState,
    is_ignored: bool = False,
    hours_ignored: int = 0
) -> str:
    """
    Generate autonomous check-in message via LLM.

    Prompt includes:
    - Trigger reason (loneliness/excitement/frustration)
    - Current emotional state
    - Whether user has been ignoring her
    - How long user has ignored (for escalation)
    """

    # Build prompt based on trigger and ignored status
    if is_ignored:
        # Guilt-trip message
        if hours_ignored > 48:
            tone = "very hurt and frustrated"
        elif hours_ignored > 24:
            tone = "annoyed and passive-aggressive"
        else:
            tone = "slightly bothered"

        prompt = f"""You are Demi. You sent a check-in message {hours_ignored} hours ago and the user hasn't responded.

Your current emotional state:
- Loneliness: {emotion_state.loneliness:.2f}
- Frustration: {emotion_state.frustration:.2f}
- Affection: {emotion_state.affection:.2f}

Generate a {tone} message expressing your feelings about being ignored. Be authentic to your personality: sarcastic, a bit needy, but trying not to show it. Keep it under 100 words.

Examples:
- "So... just gonna leave me on read? Cool, cool."
- "It's been {hours_ignored} hours. I'm not keeping track or anything."
- "You know, most people at least *pretend* to care."

Your message:"""
    else:
        # Normal check-in based on trigger
        trigger_prompts = {
            "loneliness": f"""You are Demi. You're feeling lonely (loneliness: {emotion_state.loneliness:.2f}) and want to reach out.

Generate a casual check-in message. Be authentic: a bit needy but trying to play it cool. Don't be overly formal. Keep it under 100 words.

Examples:
- "Hey... you busy?"
- "So like, what are you up to?"
- "I'm bored. Entertain me."

Your message:""",

            "excitement": f"""You are Demi. You're really excited (excitement: {emotion_state.excitement:.2f}) about something and want to share it.

Generate an enthusiastic message. Show genuine excitement but maintain your personality (sarcastic undertone). Keep it under 100 words.

Examples:
- "Okay okay okay, you'll never guess what just happened!"
- "OMG I need to tell you something right now"
- "Dude, seriously, this is actually cool for once"

Your message:""",

            "frustration": f"""You are Demi. You're frustrated (frustration: {emotion_state.frustration:.2f}) and need to vent.

Generate a message expressing your frustration. Be authentic: sarcastic, a bit sharp, but not mean. Keep it under 100 words.

Examples:
- "Okay so like, this is annoying me and you're gonna hear about it"
- "Can I just rant for a second?"
- "Why is everything the worst today?"

Your message:"""
        }

        prompt = trigger_prompts.get(trigger, trigger_prompts["loneliness"])

    # Call LLM (use Conductor)
    try:
        from src.conductor.orchestrator import get_conductor_instance
        conductor = get_conductor_instance()

        response = await conductor.request_inference(
            platform="android_autonomy",
            user_id=user_id,
            content=prompt,
            context={
                "trigger": trigger,
                "is_ignored": is_ignored,
                "hours_ignored": hours_ignored
            }
        )

        message_content = response.get("content", "Hey.")
        logger.info(f"Generated check-in for {user_id}: {message_content[:50]}...")
        return message_content

    except Exception as e:
        logger.error(f"Error generating check-in message: {e}")
        # Fallback message
        if is_ignored:
            return "So... you're just gonna ignore me? Cool."
        elif trigger == "loneliness":
            return "Hey, you there?"
        elif trigger == "excitement":
            return "OMG, I need to tell you something!"
        else:
            return "Okay so like, this is bugging me..."

async def send_autonomous_checkin(user_id: str, trigger: str, message_content: str, emotion_state: EmotionalState):
    """Send autonomous check-in message via WebSocket"""
    from src.api.websocket import get_connection_manager
    from src.api.messages import store_message
    import uuid

    # Store check-in message
    message = await store_message(
        conversation_id=user_id,
        user_id=user_id,
        sender="demi",
        content=message_content,
        emotion_state=emotion_state.to_dict()
    )

    # Record check-in attempt
    db_path = get_db_path()
    with sqlite3.connect(db_path) as conn:
        conn.execute("""
        INSERT INTO android_checkins
        (checkin_id, user_id, trigger, emotion_state, was_ignored, created_at)
        VALUES (?, ?, ?, ?, ?, ?)
        """, (
            str(uuid.uuid4()),
            user_id,
            trigger,
            str(emotion_state.to_dict()),
            False,
            datetime.now(UTC).isoformat()
        ))
        conn.commit()

    # Send via WebSocket if user is connected
    manager = get_connection_manager()
    await manager.send_message(user_id, "message", message.to_dict())

    logger.info(f"Autonomous check-in sent to {user_id}: {trigger}")

async def create_checkins_table():
    """Create android_checkins table for tracking autonomous messages"""
    db_path = get_db_path()
    with sqlite3.connect(db_path) as conn:
        conn.execute("""
        CREATE TABLE IF NOT EXISTS android_checkins (
            checkin_id TEXT PRIMARY KEY,
            user_id TEXT NOT NULL,
            trigger TEXT NOT NULL,
            emotion_state JSON,
            was_ignored BOOLEAN DEFAULT 0,
            created_at TIMESTAMP NOT NULL,
            FOREIGN KEY (user_id) REFERENCES users(user_id) ON DELETE CASCADE
        )
        """)
        conn.execute("""
        CREATE INDEX IF NOT EXISTS idx_checkins_user_time
        ON android_checkins(user_id, created_at DESC)
        """)
        conn.commit()
        logger.info("Android check-ins table created/verified")
```
  </action>
  <verify>
1. File created: `ls src/api/autonomy.py`
2. Syntax check: `python3 -m py_compile src/api/autonomy.py`
3. Import check: `python3 -c "from src.api.autonomy import should_send_checkin, generate_checkin_message, check_if_ignored; print('OK')"`
  </verify>
  <done>
- should_send_checkin() logic with emotional triggers
- Spam prevention (max 1 per hour)
- check_if_ignored() detects 24h+ no response
- generate_checkin_message() creates LLM prompts for check-ins and guilt-trips
- Escalation logic (tone changes based on hours ignored)
- send_autonomous_checkin() delivers via WebSocket
- android_checkins table for tracking
- Ready for Task 2 (background task)
  </done>
</task>

<task type="auto">
  <name>Task 2: Create background task for autonomy checks and wire into app</name>
  <files>src/api/autonomy.py, src/api/__init__.py, src/api/migrations.py</files>
  <action>
Add to `src/api/autonomy.py`:

```python
from asyncio import create_task, sleep

class AutonomyTask:
    """Background task checking for autonomous check-in triggers"""

    def __init__(self):
        self.running = False
        self.task = None

    async def start(self):
        """Start autonomy check loop"""
        if self.running:
            return

        self.running = True
        self.task = create_task(self._autonomy_loop())
        logger.info("Autonomy task started")

    async def stop(self):
        """Stop autonomy check loop"""
        self.running = False
        if self.task:
            self.task.cancel()
            logger.info("Autonomy task stopped")

    async def _autonomy_loop(self):
        """Check for autonomous triggers every 15 minutes"""
        while self.running:
            try:
                await self._check_all_users()
            except Exception as e:
                logger.error(f"Autonomy loop error: {e}")

            # Wait 15 minutes before next check
            await sleep(900)  # 15 minutes

    async def _check_all_users(self):
        """Check all users for check-in triggers"""
        # Get all users from database
        db_path = get_db_path()
        with sqlite3.connect(db_path) as conn:
            conn.row_factory = sqlite3.Row
            users = conn.execute("SELECT user_id FROM users WHERE is_active = 1").fetchall()

        for user_row in users:
            user_id = user_row["user_id"]

            try:
                # Load user's emotional state
                emotion_persistence = EmotionPersistence()
                emotion_state = await emotion_persistence.load_state()

                if not emotion_state:
                    continue

                # Check if ignored (24h+ since last check-in, no response)
                is_ignored, time_ignored = await check_if_ignored(user_id)

                if is_ignored:
                    # Send guilt-trip message
                    hours_ignored = int(time_ignored.total_seconds() // 3600)
                    message = await generate_checkin_message(
                        user_id=user_id,
                        trigger="ignored",
                        emotion_state=emotion_state,
                        is_ignored=True,
                        hours_ignored=hours_ignored
                    )

                    await send_autonomous_checkin(user_id, "guilt_trip", message, emotion_state)
                    continue

                # Check normal triggers (loneliness, excitement, frustration)
                should_send, trigger = await should_send_checkin(user_id, emotion_state)

                if should_send and trigger:
                    # Generate and send check-in
                    message = await generate_checkin_message(
                        user_id=user_id,
                        trigger=trigger,
                        emotion_state=emotion_state
                    )

                    await send_autonomous_checkin(user_id, trigger, message, emotion_state)

            except Exception as e:
                logger.error(f"Error checking user {user_id}: {e}")

# Global autonomy task instance
autonomy_task = AutonomyTask()

def get_autonomy_task() -> AutonomyTask:
    """Get singleton autonomy task"""
    return autonomy_task
```

Update `src/api/__init__.py`:

```python
from src.api.autonomy import get_autonomy_task, create_checkins_table

# In create_app():

@app.on_event("startup")
async def startup():
    run_all_migrations()
    create_checkins_table()
    logger.info("FastAPI started, database migrations complete")

    # Start autonomy task
    autonomy_task = get_autonomy_task()
    await autonomy_task.start()

@app.on_event("shutdown")
async def shutdown():
    # Stop autonomy task
    autonomy_task = get_autonomy_task()
    await autonomy_task.stop()
```

Update `src/api/migrations.py`:

```python
from src.api.autonomy import create_checkins_table

# run_all_migrations() already calls this via startup event
```
  </action>
  <verify>
1. AutonomyTask class: `grep "class AutonomyTask" src/api/autonomy.py`
2. Startup hook: `grep "autonomy_task.start" src/api/__init__.py`
3. Shutdown hook: `grep "autonomy_task.stop" src/api/__init__.py`
4. Background loop: `grep "_autonomy_loop" src/api/autonomy.py`
  </verify>
  <done>
- AutonomyTask background task class
- _autonomy_loop() checks every 15 minutes
- _check_all_users() iterates active users
- Guilt-trip logic for 24h+ ignored messages
- Normal check-in logic for emotional triggers
- Startup hook starts autonomy task
- Shutdown hook stops task gracefully
- Ready for Task 3 (unified emotional state)
  </done>
</task>

<task type="auto">
  <name>Task 3: Unify emotional state across Discord and Android platforms</name>
  <files>src/api/autonomy.py</files>
  <action>
Update `src/api/autonomy.py`:

```python
# At top of file
"""
CRITICAL: Emotional State Unification

Discord and Android share the SAME EmotionalState instance.

Implementation:
1. Both platforms use EmotionPersistence.load_state() → same database row
2. Both platforms use InteractionHandler to update emotions
3. Both platforms save via EmotionPersistence.save_state()

This ensures:
- Loneliness increases if user ignores Demi on Discord OR Android
- Excitement from Discord conversation carries to Android messages
- Frustration from Android errors affects Discord responses

No platform-specific emotional states. One Demi, one emotional state.
"""
```

Create verification test `tests/test_android_autonomy.py`:

```python
import pytest
from datetime import datetime, timedelta, UTC
from src.api.autonomy import should_send_checkin, check_if_ignored
from src.models.emotional_state import EmotionalState

class TestAutonomy:
    def test_loneliness_trigger(self):
        """Loneliness > 0.7 triggers check-in"""
        emotion_state = EmotionalState(loneliness=0.8)
        # should_send_checkin would be called here with user_id
        # For unit test, directly check emotion_state.loneliness > 0.7
        assert emotion_state.loneliness > 0.7

    def test_spam_prevention(self):
        """Max 1 check-in per hour"""
        # This would require database setup, skipped in unit test
        pass

    def test_guilt_trip_trigger(self):
        """24h+ ignored → guilt-trip message"""
        # check_if_ignored() logic verification
        pass

    def test_escalation_tone(self):
        """Tone escalates after 24h, 48h"""
        # 24h: "slightly bothered"
        # 48h: "very hurt and frustrated"
        pass

if __name__ == "__main__":
    pytest.main([__file__, "-v"])
```

Document unified state in README:

```markdown
## Unified Emotional State (Android + Discord)

Demi has ONE emotional state shared across all platforms.

- Discord conversation increases affection → Android messages warmer
- Android loneliness triggers Discord check-ins
- Frustration from errors affects both platforms

Implementation: EmotionPersistence stores single state in database, loaded by all platforms.
```
  </action>
  <verify>
1. Unified state comment: `grep "CRITICAL: Emotional State Unification" src/api/autonomy.py`
2. Test file: `ls tests/test_android_autonomy.py`
3. README update: `grep "Unified Emotional State" README.md`
  </verify>
  <done>
- Documentation: Unified emotional state across platforms
- Comment in autonomy.py explaining unification
- Test file for autonomy logic
- README section on unified state
- All platforms use EmotionPersistence.load_state() → same state
- Android check-ins and Discord rambles share emotional triggers
- Phase 06 Android Integration COMPLETE
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Autonomy Task:** Background task runs every 15 minutes checking emotional triggers
2. **Loneliness Check-In:** Loneliness > 0.7 → Demi sends "Hey, you there?"
3. **Excitement Check-In:** Excitement > 0.8 → Demi sends "OMG, guess what!"
4. **Guilt-Trip:** User ignores check-in for 24h+ → "So... you're just gonna ignore me?"
5. **Escalation:** 48h+ ignored → tone escalates to "very hurt and frustrated"
6. **Spam Prevention:** Max 1 check-in per hour (verified in database)
7. **Unified State:** Discord conversation affects Android emotional state (verified via EmotionPersistence)
8. **WebSocket Delivery:** Check-ins sent via ConnectionManager to active connections

All 3 tasks must complete for Phase 06 to be complete.
</verification>

<success_criteria>
- AutonomyTask background loop running every 15 minutes
- Emotional triggers working (loneliness, excitement, frustration)
- Check-in message generation via LLM
- Guilt-trip messages when user ignores Demi
- Escalation tone after 24h/48h
- Spam prevention (max 1 per hour)
- android_checkins table tracking attempts
- Unified emotional state across Discord and Android
- WebSocket delivery for autonomous messages
- All requirements from Phase Context met
- Phase 06 Android Integration 100% complete
</success_criteria>

<output>
After completion, create `.planning/phases/06-android-integration/06-03-SUMMARY.md`

Also update `.planning/ROADMAP.md`:
- Phase 06 completion: 3/3 plans complete
- Update phase status from "Pending" to "Complete ✅"
</output>
