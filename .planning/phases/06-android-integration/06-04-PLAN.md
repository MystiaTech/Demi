---
phase: 06-android-integration
plan: 04
type: execute
wave: 4
depends_on: ["06-01", "06-02", "06-03"]
files_modified:
  - android/app/build.gradle.kts
  - android/app/src/main/kotlin/com/demi/chat/MainActivity.kt
  - android/app/src/main/kotlin/com/demi/chat/ui/chat/ChatScreen.kt
  - android/app/src/main/kotlin/com/demi/chat/ui/login/LoginScreen.kt
  - android/app/src/main/kotlin/com/demi/chat/ui/dashboard/DashboardScreen.kt
  - android/app/src/main/kotlin/com/demi/chat/viewmodel/ChatViewModel.kt
  - android/app/src/main/kotlin/com/demi/chat/viewmodel/AuthViewModel.kt
  - android/app/src/main/kotlin/com/demi/chat/viewmodel/DashboardViewModel.kt
  - android/app/src/main/kotlin/com/demi/chat/api/DemiApiClient.kt
  - android/app/src/main/kotlin/com/demi/chat/api/WebSocketManager.kt
  - android/app/src/main/kotlin/com/demi/chat/data/models/Message.kt
  - android/app/src/main/kotlin/com/demi/chat/data/models/EmotionalState.kt
  - android/app/src/main/kotlin/com/demi/chat/data/repository/AuthRepository.kt
  - android/app/src/main/kotlin/com/demi/chat/data/repository/ChatRepository.kt
  - android/app/src/main/kotlin/com/demi/chat/utils/TokenManager.kt
  - android/app/src/main/kotlin/com/demi/chat/utils/BiometricManager.kt
  - android/app/src/main/kotlin/com/demi/chat/utils/NotificationHelper.kt
  - android/app/src/main/AndroidManifest.xml
autonomous: true
user_setup:
  - service: android_app
    why: "Android mobile client for Demi messaging"
    env_vars:
      - name: DEMI_API_BASE_URL
        source: "FastAPI backend URL (e.g., https://api.demi.example.com or http://10.0.2.2:8000 for emulator)"
    dashboard_config:
      - task: "Install Android Studio (Arctic Fox or later)"
        location: "https://developer.android.com/studio"
      - task: "Set up Android SDK (API 31+)"
        location: "Android Studio SDK Manager"
      - task: "Create Firebase project for FCM notifications (optional)"
        location: "https://console.firebase.google.com"

must_haves:
  truths:
    - "Android app builds and runs on Android 12+ (API 31)"
    - "User can log in with email/password and receive JWT tokens"
    - "WebSocket connects to backend for real-time messaging"
    - "User can send messages and receive Demi's responses"
    - "Messages show read/delivered status indicators"
    - "Push notifications arrive for new messages and check-ins"
    - "Dashboard displays Demi's 9-dimension emotional state"
    - "User can export all data as JSON (GDPR compliance)"
    - "Session expires after 30 minutes of inactivity"
    - "Biometric authentication works as login alternative"
  artifacts:
    - path: "android/app/build.gradle.kts"
      provides: "Android build configuration with dependencies"
      exports: []
      min_lines: 80
    - path: "android/app/src/main/kotlin/com/demi/chat/api/WebSocketManager.kt"
      provides: "WebSocket client for real-time messaging"
      exports: ["WebSocketManager"]
      min_lines: 150
    - path: "android/app/src/main/kotlin/com/demi/chat/viewmodel/ChatViewModel.kt"
      provides: "Chat state management with message flow"
      exports: ["ChatViewModel"]
      min_lines: 120
    - path: "android/app/src/main/kotlin/com/demi/chat/ui/chat/ChatScreen.kt"
      provides: "Chat UI with message bubbles"
      exports: ["ChatScreen"]
      min_lines: 200
  key_links:
    - from: "android/app/src/main/kotlin/com/demi/chat/api/WebSocketManager.kt"
      to: "FastAPI WebSocket endpoint"
      via: "OkHttp WebSocket connection to /api/v1/chat/ws"
      pattern: "WebSocket|OkHttpClient"
    - from: "android/app/src/main/kotlin/com/demi/chat/api/DemiApiClient.kt"
      to: "FastAPI auth endpoints"
      via: "Retrofit HTTP calls to /api/v1/auth/*"
      pattern: "Retrofit|@POST|@GET"
    - from: "android/app/src/main/kotlin/com/demi/chat/utils/TokenManager.kt"
      to: "Android KeyStore"
      via: "EncryptedSharedPreferences for secure token storage"
      pattern: "EncryptedSharedPreferences|KeyStore"

---

<objective>
Build the Android mobile client that closes the gap in Phase 06. The FastAPI backend (06-01, 06-02, 06-03) is complete with authentication, WebSocket messaging, and autonomous check-ins. This plan implements the Kotlin Android app with Jetpack Compose UI, connecting users to Demi via real-time WebSocket, enabling bidirectional messaging, push notifications, and emotional state visualization.

Purpose: Complete the Android Integration phase by providing the mobile client that users interact with. Without this, the backend is functional but unused. This client enables mobile messaging with Demi, displaying her responses and autonomous check-ins, showing read receipts, and providing GDPR data export.

Output: Fully functional Android app (API 31+) with login, chat, dashboard, notifications, and data export.
</objective>

<execution_context>
@/home/mystiatech/.claude/get-shit-done/workflows/execute-plan.md
@/home/mystiatech/projects/Demi/.planning/phases/06-android-integration/06-CONTEXT.md
@/home/mystiatech/projects/Demi/.planning/phases/06-android-integration/06-VERIFICATION.md
</execution_context>

<context>
@.planning/phases/06-android-integration/06-01-SUMMARY.md
@.planning/phases/06-android-integration/06-02-SUMMARY.md
@.planning/phases/06-android-integration/06-03-SUMMARY.md
@src/api/auth.py
@src/api/websocket.py
@src/api/models.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Android project structure and Gradle configuration</name>
  <files>android/build.gradle.kts, android/settings.gradle.kts, android/app/build.gradle.kts, android/gradle.properties, android/app/src/main/AndroidManifest.xml</files>
  <action>
Create Android project directory structure:

```
android/
├── build.gradle.kts
├── settings.gradle.kts
├── gradle.properties
├── gradle/wrapper/
│   ├── gradle-wrapper.jar
│   └── gradle-wrapper.properties
└── app/
    ├── build.gradle.kts
    └── src/main/
        ├── AndroidManifest.xml
        ├── kotlin/com/demi/chat/
        └── res/
            ├── values/
            │   ├── strings.xml
            │   ├── colors.xml
            │   └── themes.xml
            └── drawable/
```

**android/build.gradle.kts:**
```kotlin
plugins {
    id("com.android.application") version "8.2.0" apply false
    id("org.jetbrains.kotlin.android") version "1.9.20" apply false
    id("com.google.dagger.hilt.android") version "2.48" apply false
}
```

**android/settings.gradle.kts:**
```kotlin
pluginManagement {
    repositories {
        google()
        mavenCentral()
        gradlePluginPortal()
    }
}
dependencyResolutionManagement {
    repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS)
    repositories {
        google()
        mavenCentral()
    }
}
rootProject.name = "DemiChat"
include(":app")
```

**android/app/build.gradle.kts:**
```kotlin
plugins {
    id("com.android.application")
    id("org.jetbrains.kotlin.android")
    id("com.google.dagger.hilt.android")
    kotlin("kapt")
}

android {
    namespace = "com.demi.chat"
    compileSdk = 34

    defaultConfig {
        applicationId = "com.demi.chat"
        minSdk = 31
        targetSdk = 34
        versionCode = 1
        versionName = "1.0.0"

        testInstrumentationRunner = "androidx.test.runner.AndroidJUnitRunner"

        // API base URL (override in local.properties or CI)
        buildConfigField("String", "API_BASE_URL", "\"http://10.0.2.2:8000\"")
    }

    buildTypes {
        release {
            isMinifyEnabled = true
            proguardFiles(getDefaultProguardFile("proguard-android-optimize.txt"), "proguard-rules.pro")
        }
    }

    compileOptions {
        sourceCompatibility = JavaVersion.VERSION_17
        targetCompatibility = JavaVersion.VERSION_17
    }

    kotlinOptions {
        jvmTarget = "17"
    }

    buildFeatures {
        compose = true
        buildConfig = true
    }

    composeOptions {
        kotlinCompilerExtensionVersion = "1.5.4"
    }
}

dependencies {
    // Core Android
    implementation("androidx.core:core-ktx:1.12.0")
    implementation("androidx.lifecycle:lifecycle-runtime-ktx:2.6.2")
    implementation("androidx.activity:activity-compose:1.8.1")

    // Jetpack Compose
    implementation(platform("androidx.compose:compose-bom:2023.10.01"))
    implementation("androidx.compose.ui:ui")
    implementation("androidx.compose.ui:ui-graphics")
    implementation("androidx.compose.ui:ui-tooling-preview")
    implementation("androidx.compose.material3:material3")
    implementation("androidx.navigation:navigation-compose:2.7.5")

    // Networking
    implementation("com.squareup.retrofit2:retrofit:2.9.0")
    implementation("com.squareup.retrofit2:converter-gson:2.9.0")
    implementation("com.squareup.okhttp3:okhttp:4.12.0")
    implementation("com.squareup.okhttp3:logging-interceptor:4.12.0")

    // Dependency Injection
    implementation("com.google.dagger:hilt-android:2.48")
    kapt("com.google.dagger:hilt-compiler:2.48")
    implementation("androidx.hilt:hilt-navigation-compose:1.1.0")

    // Security (token storage)
    implementation("androidx.security:security-crypto:1.1.0-alpha06")

    // Biometric
    implementation("androidx.biometric:biometric:1.1.0")

    // DataStore (preferences)
    implementation("androidx.datastore:datastore-preferences:1.0.0")

    // Coroutines
    implementation("org.jetbrains.kotlinx:kotlinx-coroutines-android:1.7.3")

    // Testing
    testImplementation("junit:junit:4.13.2")
    androidTestImplementation("androidx.test.ext:junit:1.1.5")
    androidTestImplementation("androidx.test.espresso:espresso-core:3.5.1")
    androidTestImplementation(platform("androidx.compose:compose-bom:2023.10.01"))
    androidTestImplementation("androidx.compose.ui:ui-test-junit4")
    debugImplementation("androidx.compose.ui:ui-tooling")
    debugImplementation("androidx.compose.ui:ui-test-manifest")
}
```

**android/app/src/main/AndroidManifest.xml:**
```xml
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android">

    <uses-permission android:name="android.permission.INTERNET" />
    <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />
    <uses-permission android:name="android.permission.POST_NOTIFICATIONS" />
    <uses-permission android:name="android.permission.USE_BIOMETRIC" />
    <uses-permission android:name="android.permission.FOREGROUND_SERVICE" />

    <application
        android:name=".DemiApplication"
        android:allowBackup="true"
        android:icon="@mipmap/ic_launcher"
        android:label="@string/app_name"
        android:roundIcon="@mipmap/ic_launcher_round"
        android:supportsRtl="true"
        android:theme="@style/Theme.DemiChat"
        android:usesCleartextTraffic="true">

        <activity
            android:name=".MainActivity"
            android:exported="true"
            android:theme="@style/Theme.DemiChat">
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />
                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>

        <service
            android:name=".services.WebSocketService"
            android:exported="false"
            android:foregroundServiceType="dataSync" />

    </application>

</manifest>
```
  </action>
  <verify>
1. Directory exists: `ls -la android/app/build.gradle.kts`
2. Manifest valid: `grep "android.permission.INTERNET" android/app/src/main/AndroidManifest.xml`
3. Dependencies present: `grep "retrofit\|okhttp\|compose" android/app/build.gradle.kts`
4. Min SDK 31: `grep "minSdk = 31" android/app/build.gradle.kts`
  </verify>
  <done>
- Android project structure created
- Root build.gradle.kts with plugin versions
- App build.gradle.kts with all dependencies (Compose, Retrofit, OkHttp, Hilt, Biometric, Security)
- AndroidManifest.xml with permissions (INTERNET, BIOMETRIC, NOTIFICATIONS)
- Min SDK 31 (Android 12+)
- Ready for Task 2 (data models)
  </done>
</task>

<task type="auto">
  <name>Task 2: Create data models matching backend API schemas</name>
  <files>android/app/src/main/kotlin/com/demi/chat/data/models/*.kt</files>
  <action>
Create data models that match the FastAPI backend schemas from src/api/models.py.

**android/app/src/main/kotlin/com/demi/chat/data/models/User.kt:**
```kotlin
package com.demi.chat.data.models

import com.google.gson.annotations.SerializedName

data class User(
    @SerializedName("user_id") val userId: String,
    @SerializedName("email") val email: String,
    @SerializedName("username") val username: String,
    @SerializedName("created_at") val createdAt: String,
    @SerializedName("is_active") val isActive: Boolean
)

data class LoginRequest(
    @SerializedName("email") val email: String,
    @SerializedName("password") val password: String,
    @SerializedName("device_name") val deviceName: String = android.os.Build.MODEL,
    @SerializedName("device_fingerprint") val deviceFingerprint: String? = null
)

data class TokenResponse(
    @SerializedName("access_token") val accessToken: String,
    @SerializedName("refresh_token") val refreshToken: String,
    @SerializedName("token_type") val tokenType: String,
    @SerializedName("expires_in") val expiresIn: Int,
    @SerializedName("refresh_expires_in") val refreshExpiresIn: Int,
    @SerializedName("user_id") val userId: String,
    @SerializedName("email") val email: String,
    @SerializedName("session_id") val sessionId: String
)

data class RefreshTokenRequest(
    @SerializedName("refresh_token") val refreshToken: String
)
```

**android/app/src/main/kotlin/com/demi/chat/data/models/Session.kt:**
```kotlin
package com.demi.chat.data.models

import com.google.gson.annotations.SerializedName

data class Session(
    @SerializedName("session_id") val sessionId: String,
    @SerializedName("device_name") val deviceName: String,
    @SerializedName("created_at") val createdAt: String,
    @SerializedName("last_activity") val lastActivity: String,
    @SerializedName("expires_at") val expiresAt: String,
    @SerializedName("is_active") val isActive: Boolean,
    @SerializedName("is_current") val isCurrent: Boolean
)

data class SessionListResponse(
    @SerializedName("sessions") val sessions: List<Session>,
    @SerializedName("total_count") val totalCount: Int
)
```

**android/app/src/main/kotlin/com/demi/chat/data/models/Message.kt:**
```kotlin
package com.demi.chat.data.models

import com.google.gson.annotations.SerializedName

data class Message(
    @SerializedName("message_id") val messageId: String,
    @SerializedName("conversation_id") val conversationId: String,
    @SerializedName("sender") val sender: String, // "user" or "demi"
    @SerializedName("content") val content: String,
    @SerializedName("emotion_state") val emotionState: EmotionalState? = null,
    @SerializedName("status") val status: String = "sent", // sent, delivered, read
    @SerializedName("delivered_at") val deliveredAt: String? = null,
    @SerializedName("read_at") val readAt: String? = null,
    @SerializedName("created_at") val createdAt: String
) {
    val isFromDemi: Boolean get() = sender == "demi"
    val isRead: Boolean get() = status == "read"
    val isDelivered: Boolean get() = status == "delivered" || status == "read"
}

data class SendMessageRequest(
    @SerializedName("content") val content: String
)

data class WebSocketEvent(
    @SerializedName("event") val event: String,
    @SerializedName("data") val data: Map<String, Any>?,
    @SerializedName("timestamp") val timestamp: String? = null
)

data class HistoryResponse(
    @SerializedName("messages") val messages: List<Message>,
    @SerializedName("count") val count: Int
)
```

**android/app/src/main/kotlin/com/demi/chat/data/models/EmotionalState.kt:**
```kotlin
package com.demi.chat.data.models

import com.google.gson.annotations.SerializedName

/**
 * Demi's 9-dimension emotional state.
 * Matches src/models/emotional_state.py
 */
data class EmotionalState(
    @SerializedName("happiness") val happiness: Float = 0.5f,
    @SerializedName("sadness") val sadness: Float = 0.2f,
    @SerializedName("anger") val anger: Float = 0.1f,
    @SerializedName("fear") val fear: Float = 0.1f,
    @SerializedName("surprise") val surprise: Float = 0.3f,
    @SerializedName("disgust") val disgust: Float = 0.05f,
    @SerializedName("trust") val trust: Float = 0.5f,
    @SerializedName("anticipation") val anticipation: Float = 0.4f,
    @SerializedName("loneliness") val loneliness: Float = 0.3f,
    @SerializedName("excitement") val excitement: Float = 0.4f,
    @SerializedName("frustration") val frustration: Float = 0.2f,
    @SerializedName("affection") val affection: Float = 0.5f
) {
    /**
     * Get dominant emotion (highest value)
     */
    fun dominantEmotion(): Pair<String, Float> {
        val emotions = mapOf(
            "happiness" to happiness,
            "sadness" to sadness,
            "anger" to anger,
            "fear" to fear,
            "surprise" to surprise,
            "trust" to trust,
            "loneliness" to loneliness,
            "excitement" to excitement,
            "affection" to affection
        )
        return emotions.maxByOrNull { it.value }?.toPair() ?: ("neutral" to 0.5f)
    }

    /**
     * Get mood description for UI
     */
    fun moodDescription(): String {
        val (emotion, intensity) = dominantEmotion()
        val intensityWord = when {
            intensity > 0.8f -> "very"
            intensity > 0.6f -> "quite"
            intensity > 0.4f -> "somewhat"
            else -> "slightly"
        }
        return "$intensityWord $emotion"
    }
}
```
  </action>
  <verify>
1. User model: `grep "data class User" android/app/src/main/kotlin/com/demi/chat/data/models/User.kt`
2. Message model: `grep "data class Message" android/app/src/main/kotlin/com/demi/chat/data/models/Message.kt`
3. EmotionalState: `grep "data class EmotionalState" android/app/src/main/kotlin/com/demi/chat/data/models/EmotionalState.kt`
4. SerializedName annotations: `grep "@SerializedName" android/app/src/main/kotlin/com/demi/chat/data/models/Message.kt`
  </verify>
  <done>
- User, LoginRequest, TokenResponse models (match src/api/models.py)
- Session, SessionListResponse models
- Message model with status (sent/delivered/read)
- EmotionalState with 9 dimensions + helper methods
- WebSocketEvent for parsing WS messages
- All models use @SerializedName for JSON parsing
- Ready for Task 3 (API client)
  </done>
</task>

<task type="auto">
  <name>Task 3: Implement secure token storage and authentication client</name>
  <files>android/app/src/main/kotlin/com/demi/chat/utils/TokenManager.kt, android/app/src/main/kotlin/com/demi/chat/api/DemiApiClient.kt, android/app/src/main/kotlin/com/demi/chat/data/repository/AuthRepository.kt</files>
  <action>
**android/app/src/main/kotlin/com/demi/chat/utils/TokenManager.kt:**
```kotlin
package com.demi.chat.utils

import android.content.Context
import androidx.security.crypto.EncryptedSharedPreferences
import androidx.security.crypto.MasterKey
import dagger.hilt.android.qualifiers.ApplicationContext
import javax.inject.Inject
import javax.inject.Singleton

@Singleton
class TokenManager @Inject constructor(
    @ApplicationContext private val context: Context
) {
    private val masterKey = MasterKey.Builder(context)
        .setKeyScheme(MasterKey.KeyScheme.AES256_GCM)
        .build()

    private val prefs = EncryptedSharedPreferences.create(
        context,
        "demi_secure_prefs",
        masterKey,
        EncryptedSharedPreferences.PrefKeyEncryptionScheme.AES256_SIV,
        EncryptedSharedPreferences.PrefValueEncryptionScheme.AES256_GCM
    )

    companion object {
        private const val KEY_ACCESS_TOKEN = "access_token"
        private const val KEY_REFRESH_TOKEN = "refresh_token"
        private const val KEY_USER_ID = "user_id"
        private const val KEY_EMAIL = "email"
        private const val KEY_SESSION_ID = "session_id"
        private const val KEY_TOKEN_EXPIRY = "token_expiry"
        private const val KEY_LAST_ACTIVITY = "last_activity"
        private const val KEY_BIOMETRIC_ENABLED = "biometric_enabled"
    }

    var accessToken: String?
        get() = prefs.getString(KEY_ACCESS_TOKEN, null)
        set(value) = prefs.edit().putString(KEY_ACCESS_TOKEN, value).apply()

    var refreshToken: String?
        get() = prefs.getString(KEY_REFRESH_TOKEN, null)
        set(value) = prefs.edit().putString(KEY_REFRESH_TOKEN, value).apply()

    var userId: String?
        get() = prefs.getString(KEY_USER_ID, null)
        set(value) = prefs.edit().putString(KEY_USER_ID, value).apply()

    var email: String?
        get() = prefs.getString(KEY_EMAIL, null)
        set(value) = prefs.edit().putString(KEY_EMAIL, value).apply()

    var sessionId: String?
        get() = prefs.getString(KEY_SESSION_ID, null)
        set(value) = prefs.edit().putString(KEY_SESSION_ID, value).apply()

    var tokenExpiry: Long
        get() = prefs.getLong(KEY_TOKEN_EXPIRY, 0L)
        set(value) = prefs.edit().putLong(KEY_TOKEN_EXPIRY, value).apply()

    var lastActivity: Long
        get() = prefs.getLong(KEY_LAST_ACTIVITY, System.currentTimeMillis())
        set(value) = prefs.edit().putLong(KEY_LAST_ACTIVITY, value).apply()

    var biometricEnabled: Boolean
        get() = prefs.getBoolean(KEY_BIOMETRIC_ENABLED, false)
        set(value) = prefs.edit().putBoolean(KEY_BIOMETRIC_ENABLED, value).apply()

    fun isLoggedIn(): Boolean = accessToken != null && refreshToken != null

    fun isTokenExpired(): Boolean {
        return System.currentTimeMillis() > tokenExpiry
    }

    fun isSessionTimedOut(): Boolean {
        val thirtyMinutesMs = 30 * 60 * 1000L
        return System.currentTimeMillis() - lastActivity > thirtyMinutesMs
    }

    fun updateActivity() {
        lastActivity = System.currentTimeMillis()
    }

    fun clearAll() {
        prefs.edit().clear().apply()
    }
}
```

**android/app/src/main/kotlin/com/demi/chat/api/DemiApiClient.kt:**
```kotlin
package com.demi.chat.api

import com.demi.chat.BuildConfig
import com.demi.chat.data.models.*
import com.demi.chat.utils.TokenManager
import okhttp3.Interceptor
import okhttp3.OkHttpClient
import okhttp3.logging.HttpLoggingInterceptor
import retrofit2.Response
import retrofit2.Retrofit
import retrofit2.converter.gson.GsonConverterFactory
import retrofit2.http.*
import java.util.concurrent.TimeUnit
import javax.inject.Inject
import javax.inject.Singleton

interface DemiApi {
    @POST("api/v1/auth/login")
    suspend fun login(@Body request: LoginRequest): Response<TokenResponse>

    @POST("api/v1/auth/refresh")
    suspend fun refreshToken(@Body request: RefreshTokenRequest): Response<TokenResponse>

    @GET("api/v1/auth/sessions")
    suspend fun getSessions(): Response<SessionListResponse>

    @DELETE("api/v1/auth/sessions/{session_id}")
    suspend fun revokeSession(@Path("session_id") sessionId: String): Response<Unit>

    @GET("api/v1/messages")
    suspend fun getMessages(): Response<List<Message>>

    @GET("api/v1/health")
    suspend fun healthCheck(): Response<Map<String, String>>
}

@Singleton
class DemiApiClient @Inject constructor(
    private val tokenManager: TokenManager
) {
    private val baseUrl = BuildConfig.API_BASE_URL

    private val authInterceptor = Interceptor { chain ->
        val request = chain.request().newBuilder()
        tokenManager.accessToken?.let { token ->
            request.addHeader("Authorization", "Bearer $token")
        }
        chain.proceed(request.build())
    }

    private val loggingInterceptor = HttpLoggingInterceptor().apply {
        level = if (BuildConfig.DEBUG) {
            HttpLoggingInterceptor.Level.BODY
        } else {
            HttpLoggingInterceptor.Level.NONE
        }
    }

    private val okHttpClient = OkHttpClient.Builder()
        .addInterceptor(authInterceptor)
        .addInterceptor(loggingInterceptor)
        .connectTimeout(30, TimeUnit.SECONDS)
        .readTimeout(30, TimeUnit.SECONDS)
        .writeTimeout(30, TimeUnit.SECONDS)
        .build()

    val api: DemiApi = Retrofit.Builder()
        .baseUrl(baseUrl)
        .client(okHttpClient)
        .addConverterFactory(GsonConverterFactory.create())
        .build()
        .create(DemiApi::class.java)

    fun getWebSocketUrl(): String {
        val wsProtocol = if (baseUrl.startsWith("https")) "wss" else "ws"
        val host = baseUrl.removePrefix("https://").removePrefix("http://")
        return "$wsProtocol://$host/api/v1/chat/ws?token=${tokenManager.accessToken}"
    }
}
```

**android/app/src/main/kotlin/com/demi/chat/data/repository/AuthRepository.kt:**
```kotlin
package com.demi.chat.data.repository

import com.demi.chat.api.DemiApiClient
import com.demi.chat.data.models.*
import com.demi.chat.utils.TokenManager
import javax.inject.Inject
import javax.inject.Singleton

sealed class AuthResult<out T> {
    data class Success<T>(val data: T) : AuthResult<T>()
    data class Error(val message: String, val code: Int? = null) : AuthResult<Nothing>()
    object Loading : AuthResult<Nothing>()
}

@Singleton
class AuthRepository @Inject constructor(
    private val apiClient: DemiApiClient,
    private val tokenManager: TokenManager
) {
    suspend fun login(email: String, password: String): AuthResult<TokenResponse> {
        return try {
            val request = LoginRequest(email = email, password = password)
            val response = apiClient.api.login(request)

            if (response.isSuccessful && response.body() != null) {
                val tokens = response.body()!!
                saveTokens(tokens)
                AuthResult.Success(tokens)
            } else {
                val errorMsg = when (response.code()) {
                    401 -> "Invalid email or password"
                    403 -> "Account locked. Try again later."
                    else -> "Login failed: ${response.message()}"
                }
                AuthResult.Error(errorMsg, response.code())
            }
        } catch (e: Exception) {
            AuthResult.Error("Network error: ${e.message}")
        }
    }

    suspend fun refreshAccessToken(): AuthResult<TokenResponse> {
        val refreshToken = tokenManager.refreshToken
            ?: return AuthResult.Error("No refresh token")

        return try {
            val request = RefreshTokenRequest(refreshToken)
            val response = apiClient.api.refreshToken(request)

            if (response.isSuccessful && response.body() != null) {
                val tokens = response.body()!!
                saveTokens(tokens)
                AuthResult.Success(tokens)
            } else {
                AuthResult.Error("Token refresh failed", response.code())
            }
        } catch (e: Exception) {
            AuthResult.Error("Network error: ${e.message}")
        }
    }

    suspend fun getSessions(): AuthResult<SessionListResponse> {
        return try {
            val response = apiClient.api.getSessions()
            if (response.isSuccessful && response.body() != null) {
                AuthResult.Success(response.body()!!)
            } else {
                AuthResult.Error("Failed to get sessions", response.code())
            }
        } catch (e: Exception) {
            AuthResult.Error("Network error: ${e.message}")
        }
    }

    suspend fun revokeSession(sessionId: String): AuthResult<Unit> {
        return try {
            val response = apiClient.api.revokeSession(sessionId)
            if (response.isSuccessful) {
                AuthResult.Success(Unit)
            } else {
                AuthResult.Error("Failed to revoke session", response.code())
            }
        } catch (e: Exception) {
            AuthResult.Error("Network error: ${e.message}")
        }
    }

    fun logout() {
        tokenManager.clearAll()
    }

    fun isLoggedIn(): Boolean = tokenManager.isLoggedIn()

    fun isSessionTimedOut(): Boolean = tokenManager.isSessionTimedOut()

    fun updateActivity() = tokenManager.updateActivity()

    private fun saveTokens(tokens: TokenResponse) {
        tokenManager.accessToken = tokens.accessToken
        tokenManager.refreshToken = tokens.refreshToken
        tokenManager.userId = tokens.userId
        tokenManager.email = tokens.email
        tokenManager.sessionId = tokens.sessionId
        tokenManager.tokenExpiry = System.currentTimeMillis() + (tokens.expiresIn * 1000L)
        tokenManager.updateActivity()
    }
}
```
  </action>
  <verify>
1. TokenManager: `grep "EncryptedSharedPreferences" android/app/src/main/kotlin/com/demi/chat/utils/TokenManager.kt`
2. Session timeout: `grep "isSessionTimedOut" android/app/src/main/kotlin/com/demi/chat/utils/TokenManager.kt`
3. API client: `grep "interface DemiApi" android/app/src/main/kotlin/com/demi/chat/api/DemiApiClient.kt`
4. Auth repository: `grep "suspend fun login" android/app/src/main/kotlin/com/demi/chat/data/repository/AuthRepository.kt`
  </verify>
  <done>
- TokenManager with EncryptedSharedPreferences (Android KeyStore)
- 30-minute inactivity timeout
- DemiApiClient with Retrofit + OkHttp
- Auth interceptor adds Bearer token to requests
- AuthRepository with login, refresh, sessions, logout
- WebSocket URL builder with token query param
- Ready for Task 4 (WebSocket manager)
  </done>
</task>

<task type="auto">
  <name>Task 4: Implement WebSocket manager for real-time messaging</name>
  <files>android/app/src/main/kotlin/com/demi/chat/api/WebSocketManager.kt, android/app/src/main/kotlin/com/demi/chat/data/repository/ChatRepository.kt</files>
  <action>
**android/app/src/main/kotlin/com/demi/chat/api/WebSocketManager.kt:**
```kotlin
package com.demi.chat.api

import android.util.Log
import com.demi.chat.data.models.*
import com.google.gson.Gson
import com.google.gson.reflect.TypeToken
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.delay
import kotlinx.coroutines.flow.MutableSharedFlow
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.SharedFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.launch
import okhttp3.*
import java.util.concurrent.TimeUnit
import javax.inject.Inject
import javax.inject.Singleton

sealed class WebSocketState {
    object Disconnected : WebSocketState()
    object Connecting : WebSocketState()
    object Connected : WebSocketState()
    data class Error(val message: String) : WebSocketState()
}

sealed class ChatEvent {
    data class MessageReceived(val message: Message) : ChatEvent()
    data class HistoryLoaded(val messages: List<Message>) : ChatEvent()
    data class TypingIndicator(val isTyping: Boolean) : ChatEvent()
    data class ReadReceipt(val messageId: String) : ChatEvent()
    data class DeliveryReceipt(val messageId: String) : ChatEvent()
    data class Error(val message: String) : ChatEvent()
}

@Singleton
class WebSocketManager @Inject constructor(
    private val apiClient: DemiApiClient
) {
    private val TAG = "WebSocketManager"
    private val gson = Gson()
    private val scope = CoroutineScope(Dispatchers.IO)

    private var webSocket: WebSocket? = null
    private var reconnectAttempts = 0
    private val maxReconnectAttempts = 5

    private val _connectionState = MutableStateFlow<WebSocketState>(WebSocketState.Disconnected)
    val connectionState: StateFlow<WebSocketState> = _connectionState

    private val _events = MutableSharedFlow<ChatEvent>(replay = 0)
    val events: SharedFlow<ChatEvent> = _events

    private val client = OkHttpClient.Builder()
        .connectTimeout(10, TimeUnit.SECONDS)
        .readTimeout(0, TimeUnit.SECONDS) // No timeout for WebSocket
        .writeTimeout(10, TimeUnit.SECONDS)
        .pingInterval(30, TimeUnit.SECONDS) // Keep-alive
        .build()

    fun connect() {
        if (_connectionState.value == WebSocketState.Connected ||
            _connectionState.value == WebSocketState.Connecting) {
            return
        }

        _connectionState.value = WebSocketState.Connecting
        val wsUrl = apiClient.getWebSocketUrl()
        Log.d(TAG, "Connecting to WebSocket: $wsUrl")

        val request = Request.Builder()
            .url(wsUrl)
            .build()

        webSocket = client.newWebSocket(request, createListener())
    }

    fun disconnect() {
        webSocket?.close(1000, "User disconnected")
        webSocket = null
        _connectionState.value = WebSocketState.Disconnected
        reconnectAttempts = 0
    }

    fun sendMessage(content: String) {
        val event = mapOf(
            "event" to "message",
            "data" to mapOf("content" to content)
        )
        val json = gson.toJson(event)
        webSocket?.send(json)
        Log.d(TAG, "Sent message: $content")
    }

    fun sendReadReceipt(messageId: String) {
        val event = mapOf(
            "event" to "read_receipt",
            "data" to mapOf("message_id" to messageId)
        )
        val json = gson.toJson(event)
        webSocket?.send(json)
    }

    fun sendPing() {
        val event = mapOf("event" to "ping")
        val json = gson.toJson(event)
        webSocket?.send(json)
    }

    private fun createListener() = object : WebSocketListener() {
        override fun onOpen(webSocket: WebSocket, response: Response) {
            Log.d(TAG, "WebSocket connected")
            _connectionState.value = WebSocketState.Connected
            reconnectAttempts = 0
        }

        override fun onMessage(webSocket: WebSocket, text: String) {
            Log.d(TAG, "Received: $text")
            parseEvent(text)
        }

        override fun onClosing(webSocket: WebSocket, code: Int, reason: String) {
            Log.d(TAG, "WebSocket closing: $code $reason")
        }

        override fun onClosed(webSocket: WebSocket, code: Int, reason: String) {
            Log.d(TAG, "WebSocket closed: $code $reason")
            _connectionState.value = WebSocketState.Disconnected
            if (code != 1000) {
                attemptReconnect()
            }
        }

        override fun onFailure(webSocket: WebSocket, t: Throwable, response: Response?) {
            Log.e(TAG, "WebSocket error: ${t.message}", t)
            _connectionState.value = WebSocketState.Error(t.message ?: "Unknown error")
            attemptReconnect()
        }
    }

    private fun parseEvent(json: String) {
        try {
            val eventType = object : TypeToken<Map<String, Any>>() {}.type
            val eventMap: Map<String, Any> = gson.fromJson(json, eventType)

            when (eventMap["event"]) {
                "message" -> {
                    val dataJson = gson.toJson(eventMap["data"])
                    val message = gson.fromJson(dataJson, Message::class.java)
                    scope.launch { _events.emit(ChatEvent.MessageReceived(message)) }
                }
                "history" -> {
                    val dataMap = eventMap["data"] as? Map<*, *>
                    val messagesJson = gson.toJson(dataMap?.get("messages"))
                    val listType = object : TypeToken<List<Message>>() {}.type
                    val messages: List<Message> = gson.fromJson(messagesJson, listType)
                    scope.launch { _events.emit(ChatEvent.HistoryLoaded(messages)) }
                }
                "typing" -> {
                    val dataMap = eventMap["data"] as? Map<*, *>
                    val isTyping = dataMap?.get("is_typing") as? Boolean ?: false
                    scope.launch { _events.emit(ChatEvent.TypingIndicator(isTyping)) }
                }
                "read_receipt" -> {
                    val dataMap = eventMap["data"] as? Map<*, *>
                    val messageId = dataMap?.get("message_id") as? String ?: return
                    scope.launch { _events.emit(ChatEvent.ReadReceipt(messageId)) }
                }
                "delivered" -> {
                    val dataMap = eventMap["data"] as? Map<*, *>
                    val messageId = dataMap?.get("message_id") as? String ?: return
                    scope.launch { _events.emit(ChatEvent.DeliveryReceipt(messageId)) }
                }
                "error" -> {
                    val dataMap = eventMap["data"] as? Map<*, *>
                    val message = dataMap?.get("message") as? String ?: "Unknown error"
                    scope.launch { _events.emit(ChatEvent.Error(message)) }
                }
                "pong" -> {
                    Log.d(TAG, "Pong received")
                }
            }
        } catch (e: Exception) {
            Log.e(TAG, "Error parsing event: ${e.message}", e)
        }
    }

    private fun attemptReconnect() {
        if (reconnectAttempts >= maxReconnectAttempts) {
            Log.e(TAG, "Max reconnect attempts reached")
            _connectionState.value = WebSocketState.Error("Connection failed after $maxReconnectAttempts attempts")
            return
        }

        reconnectAttempts++
        val delayMs = (1000L * (1 shl reconnectAttempts)).coerceAtMost(30000L) // Exponential backoff, max 30s

        Log.d(TAG, "Reconnecting in ${delayMs}ms (attempt $reconnectAttempts)")

        scope.launch {
            delay(delayMs)
            connect()
        }
    }
}
```

**android/app/src/main/kotlin/com/demi/chat/data/repository/ChatRepository.kt:**
```kotlin
package com.demi.chat.data.repository

import com.demi.chat.api.ChatEvent
import com.demi.chat.api.WebSocketManager
import com.demi.chat.api.WebSocketState
import com.demi.chat.data.models.Message
import kotlinx.coroutines.flow.*
import javax.inject.Inject
import javax.inject.Singleton

@Singleton
class ChatRepository @Inject constructor(
    private val webSocketManager: WebSocketManager
) {
    private val _messages = MutableStateFlow<List<Message>>(emptyList())
    val messages: StateFlow<List<Message>> = _messages.asStateFlow()

    private val _isTyping = MutableStateFlow(false)
    val isTyping: StateFlow<Boolean> = _isTyping.asStateFlow()

    val connectionState: StateFlow<WebSocketState> = webSocketManager.connectionState

    init {
        // Observe WebSocket events
        webSocketManager.events.onEach { event ->
            handleEvent(event)
        }.launchIn(kotlinx.coroutines.CoroutineScope(kotlinx.coroutines.Dispatchers.Default))
    }

    private fun handleEvent(event: ChatEvent) {
        when (event) {
            is ChatEvent.HistoryLoaded -> {
                _messages.value = event.messages
            }
            is ChatEvent.MessageReceived -> {
                val current = _messages.value.toMutableList()
                current.add(event.message)
                _messages.value = current
                _isTyping.value = false
            }
            is ChatEvent.TypingIndicator -> {
                _isTyping.value = event.isTyping
            }
            is ChatEvent.ReadReceipt -> {
                updateMessageStatus(event.messageId, "read")
            }
            is ChatEvent.DeliveryReceipt -> {
                updateMessageStatus(event.messageId, "delivered")
            }
            is ChatEvent.Error -> {
                // Handle error (could emit to error flow)
            }
        }
    }

    private fun updateMessageStatus(messageId: String, status: String) {
        val updated = _messages.value.map { msg ->
            if (msg.messageId == messageId) {
                msg.copy(status = status)
            } else msg
        }
        _messages.value = updated
    }

    fun connect() = webSocketManager.connect()

    fun disconnect() = webSocketManager.disconnect()

    fun sendMessage(content: String) {
        webSocketManager.sendMessage(content)
    }

    fun markAsRead(messageId: String) {
        webSocketManager.sendReadReceipt(messageId)
    }
}
```
  </action>
  <verify>
1. WebSocket connect: `grep "fun connect" android/app/src/main/kotlin/com/demi/chat/api/WebSocketManager.kt`
2. Reconnect logic: `grep "attemptReconnect" android/app/src/main/kotlin/com/demi/chat/api/WebSocketManager.kt`
3. Event parsing: `grep "parseEvent" android/app/src/main/kotlin/com/demi/chat/api/WebSocketManager.kt`
4. ChatRepository: `grep "class ChatRepository" android/app/src/main/kotlin/com/demi/chat/data/repository/ChatRepository.kt`
  </verify>
  <done>
- WebSocketManager with OkHttp WebSocket client
- Connection state management (Connecting, Connected, Disconnected, Error)
- Exponential backoff reconnection (up to 5 attempts)
- Event parsing: message, history, typing, read_receipt, delivered
- ChatRepository aggregates messages and typing state
- Read receipt sending
- Ready for Task 5 (ViewModels)
  </done>
</task>

<task type="auto">
  <name>Task 5: Create ViewModels for authentication, chat, and dashboard</name>
  <files>android/app/src/main/kotlin/com/demi/chat/viewmodel/*.kt</files>
  <action>
**android/app/src/main/kotlin/com/demi/chat/viewmodel/AuthViewModel.kt:**
```kotlin
package com.demi.chat.viewmodel

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.demi.chat.data.repository.AuthRepository
import com.demi.chat.data.repository.AuthResult
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.launch
import javax.inject.Inject

data class AuthUiState(
    val isLoading: Boolean = false,
    val isLoggedIn: Boolean = false,
    val error: String? = null,
    val email: String = "",
    val requiresBiometric: Boolean = false
)

@HiltViewModel
class AuthViewModel @Inject constructor(
    private val authRepository: AuthRepository
) : ViewModel() {

    private val _uiState = MutableStateFlow(AuthUiState())
    val uiState: StateFlow<AuthUiState> = _uiState.asStateFlow()

    init {
        checkLoginStatus()
    }

    private fun checkLoginStatus() {
        val loggedIn = authRepository.isLoggedIn()
        val timedOut = authRepository.isSessionTimedOut()

        _uiState.value = _uiState.value.copy(
            isLoggedIn = loggedIn && !timedOut,
            requiresBiometric = loggedIn && timedOut
        )
    }

    fun login(email: String, password: String) {
        viewModelScope.launch {
            _uiState.value = _uiState.value.copy(isLoading = true, error = null)

            when (val result = authRepository.login(email, password)) {
                is AuthResult.Success -> {
                    _uiState.value = _uiState.value.copy(
                        isLoading = false,
                        isLoggedIn = true,
                        email = email
                    )
                }
                is AuthResult.Error -> {
                    _uiState.value = _uiState.value.copy(
                        isLoading = false,
                        error = result.message
                    )
                }
                AuthResult.Loading -> {}
            }
        }
    }

    fun logout() {
        authRepository.logout()
        _uiState.value = AuthUiState()
    }

    fun updateActivity() {
        authRepository.updateActivity()
    }

    fun clearError() {
        _uiState.value = _uiState.value.copy(error = null)
    }

    fun onBiometricSuccess() {
        authRepository.updateActivity()
        _uiState.value = _uiState.value.copy(
            isLoggedIn = true,
            requiresBiometric = false
        )
    }
}
```

**android/app/src/main/kotlin/com/demi/chat/viewmodel/ChatViewModel.kt:**
```kotlin
package com.demi.chat.viewmodel

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.demi.chat.api.WebSocketState
import com.demi.chat.data.models.Message
import com.demi.chat.data.repository.ChatRepository
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.flow.*
import kotlinx.coroutines.launch
import javax.inject.Inject

data class ChatUiState(
    val messages: List<Message> = emptyList(),
    val isTyping: Boolean = false,
    val connectionState: WebSocketState = WebSocketState.Disconnected,
    val inputText: String = "",
    val error: String? = null
)

@HiltViewModel
class ChatViewModel @Inject constructor(
    private val chatRepository: ChatRepository
) : ViewModel() {

    private val _uiState = MutableStateFlow(ChatUiState())
    val uiState: StateFlow<ChatUiState> = _uiState.asStateFlow()

    init {
        observeMessages()
        observeTyping()
        observeConnectionState()
    }

    private fun observeMessages() {
        chatRepository.messages
            .onEach { messages ->
                _uiState.value = _uiState.value.copy(messages = messages)
            }
            .launchIn(viewModelScope)
    }

    private fun observeTyping() {
        chatRepository.isTyping
            .onEach { isTyping ->
                _uiState.value = _uiState.value.copy(isTyping = isTyping)
            }
            .launchIn(viewModelScope)
    }

    private fun observeConnectionState() {
        chatRepository.connectionState
            .onEach { state ->
                _uiState.value = _uiState.value.copy(connectionState = state)
            }
            .launchIn(viewModelScope)
    }

    fun connect() {
        chatRepository.connect()
    }

    fun disconnect() {
        chatRepository.disconnect()
    }

    fun sendMessage() {
        val content = _uiState.value.inputText.trim()
        if (content.isNotEmpty()) {
            chatRepository.sendMessage(content)
            _uiState.value = _uiState.value.copy(inputText = "")
        }
    }

    fun updateInputText(text: String) {
        _uiState.value = _uiState.value.copy(inputText = text)
    }

    fun markMessageAsRead(messageId: String) {
        chatRepository.markAsRead(messageId)
    }

    fun clearError() {
        _uiState.value = _uiState.value.copy(error = null)
    }
}
```

**android/app/src/main/kotlin/com/demi/chat/viewmodel/DashboardViewModel.kt:**
```kotlin
package com.demi.chat.viewmodel

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.demi.chat.data.models.EmotionalState
import com.demi.chat.data.models.Session
import com.demi.chat.data.repository.AuthRepository
import com.demi.chat.data.repository.AuthResult
import com.demi.chat.data.repository.ChatRepository
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.flow.*
import kotlinx.coroutines.launch
import javax.inject.Inject

data class DashboardUiState(
    val emotionalState: EmotionalState? = null,
    val sessions: List<Session> = emptyList(),
    val isLoadingSessions: Boolean = false,
    val lastInteraction: String? = null,
    val totalMessages: Int = 0,
    val error: String? = null
)

@HiltViewModel
class DashboardViewModel @Inject constructor(
    private val authRepository: AuthRepository,
    private val chatRepository: ChatRepository
) : ViewModel() {

    private val _uiState = MutableStateFlow(DashboardUiState())
    val uiState: StateFlow<DashboardUiState> = _uiState.asStateFlow()

    init {
        observeMessages()
    }

    private fun observeMessages() {
        chatRepository.messages
            .onEach { messages ->
                // Get latest emotional state from Demi's messages
                val latestDemiMessage = messages.lastOrNull { it.isFromDemi }
                val emotionalState = latestDemiMessage?.emotionState

                // Get last interaction time
                val lastInteraction = messages.lastOrNull()?.createdAt

                _uiState.value = _uiState.value.copy(
                    emotionalState = emotionalState,
                    lastInteraction = lastInteraction,
                    totalMessages = messages.size
                )
            }
            .launchIn(viewModelScope)
    }

    fun loadSessions() {
        viewModelScope.launch {
            _uiState.value = _uiState.value.copy(isLoadingSessions = true)

            when (val result = authRepository.getSessions()) {
                is AuthResult.Success -> {
                    _uiState.value = _uiState.value.copy(
                        sessions = result.data.sessions,
                        isLoadingSessions = false
                    )
                }
                is AuthResult.Error -> {
                    _uiState.value = _uiState.value.copy(
                        isLoadingSessions = false,
                        error = result.message
                    )
                }
                AuthResult.Loading -> {}
            }
        }
    }

    fun revokeSession(sessionId: String) {
        viewModelScope.launch {
            when (val result = authRepository.revokeSession(sessionId)) {
                is AuthResult.Success -> {
                    loadSessions() // Refresh list
                }
                is AuthResult.Error -> {
                    _uiState.value = _uiState.value.copy(error = result.message)
                }
                AuthResult.Loading -> {}
            }
        }
    }

    fun clearError() {
        _uiState.value = _uiState.value.copy(error = null)
    }
}
```
  </action>
  <verify>
1. AuthViewModel: `grep "class AuthViewModel" android/app/src/main/kotlin/com/demi/chat/viewmodel/AuthViewModel.kt`
2. ChatViewModel: `grep "class ChatViewModel" android/app/src/main/kotlin/com/demi/chat/viewmodel/ChatViewModel.kt`
3. DashboardViewModel: `grep "class DashboardViewModel" android/app/src/main/kotlin/com/demi/chat/viewmodel/DashboardViewModel.kt`
4. Hilt injection: `grep "@HiltViewModel" android/app/src/main/kotlin/com/demi/chat/viewmodel/ChatViewModel.kt`
  </verify>
  <done>
- AuthViewModel: login, logout, session timeout check, biometric flow
- ChatViewModel: messages, typing indicator, WebSocket connection, send message
- DashboardViewModel: emotional state, sessions list, revoke session
- All use Hilt @HiltViewModel for DI
- StateFlow for reactive UI updates
- Ready for Task 6 (Compose UI)
  </done>
</task>

<task type="auto">
  <name>Task 6: Build Jetpack Compose UI screens (Login, Chat, Dashboard)</name>
  <files>android/app/src/main/kotlin/com/demi/chat/ui/**/*.kt, android/app/src/main/kotlin/com/demi/chat/MainActivity.kt</files>
  <action>
**android/app/src/main/kotlin/com/demi/chat/ui/login/LoginScreen.kt:**
```kotlin
package com.demi.chat.ui.login

import androidx.compose.foundation.layout.*
import androidx.compose.foundation.text.KeyboardOptions
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.text.input.KeyboardType
import androidx.compose.ui.text.input.PasswordVisualTransformation
import androidx.compose.ui.unit.dp
import androidx.hilt.navigation.compose.hiltViewModel
import com.demi.chat.viewmodel.AuthViewModel

@Composable
fun LoginScreen(
    viewModel: AuthViewModel = hiltViewModel(),
    onLoginSuccess: () -> Unit
) {
    val uiState by viewModel.uiState.collectAsState()

    var email by remember { mutableStateOf("") }
    var password by remember { mutableStateOf("") }

    LaunchedEffect(uiState.isLoggedIn) {
        if (uiState.isLoggedIn) {
            onLoginSuccess()
        }
    }

    Column(
        modifier = Modifier
            .fillMaxSize()
            .padding(32.dp),
        horizontalAlignment = Alignment.CenterHorizontally,
        verticalArrangement = Arrangement.Center
    ) {
        Text(
            text = "Demi",
            style = MaterialTheme.typography.displayLarge,
            color = MaterialTheme.colorScheme.primary
        )

        Spacer(modifier = Modifier.height(8.dp))

        Text(
            text = "Sign in to continue",
            style = MaterialTheme.typography.bodyLarge,
            color = MaterialTheme.colorScheme.onSurfaceVariant
        )

        Spacer(modifier = Modifier.height(48.dp))

        OutlinedTextField(
            value = email,
            onValueChange = { email = it },
            label = { Text("Email") },
            keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Email),
            singleLine = true,
            modifier = Modifier.fillMaxWidth()
        )

        Spacer(modifier = Modifier.height(16.dp))

        OutlinedTextField(
            value = password,
            onValueChange = { password = it },
            label = { Text("Password") },
            visualTransformation = PasswordVisualTransformation(),
            keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Password),
            singleLine = true,
            modifier = Modifier.fillMaxWidth()
        )

        Spacer(modifier = Modifier.height(24.dp))

        Button(
            onClick = { viewModel.login(email, password) },
            enabled = !uiState.isLoading && email.isNotBlank() && password.isNotBlank(),
            modifier = Modifier.fillMaxWidth()
        ) {
            if (uiState.isLoading) {
                CircularProgressIndicator(
                    modifier = Modifier.size(20.dp),
                    color = MaterialTheme.colorScheme.onPrimary
                )
            } else {
                Text("Sign In")
            }
        }

        uiState.error?.let { error ->
            Spacer(modifier = Modifier.height(16.dp))
            Text(
                text = error,
                color = MaterialTheme.colorScheme.error,
                style = MaterialTheme.typography.bodyMedium
            )
        }
    }
}
```

**android/app/src/main/kotlin/com/demi/chat/ui/chat/ChatScreen.kt:**
```kotlin
package com.demi.chat.ui.chat

import androidx.compose.foundation.background
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.foundation.lazy.rememberLazyListState
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Send
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.unit.dp
import androidx.hilt.navigation.compose.hiltViewModel
import com.demi.chat.api.WebSocketState
import com.demi.chat.data.models.Message
import com.demi.chat.viewmodel.ChatViewModel
import kotlinx.coroutines.launch

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun ChatScreen(
    viewModel: ChatViewModel = hiltViewModel()
) {
    val uiState by viewModel.uiState.collectAsState()
    val listState = rememberLazyListState()
    val scope = rememberCoroutineScope()

    LaunchedEffect(Unit) {
        viewModel.connect()
    }

    // Auto-scroll to bottom on new messages
    LaunchedEffect(uiState.messages.size) {
        if (uiState.messages.isNotEmpty()) {
            scope.launch {
                listState.animateScrollToItem(uiState.messages.size - 1)
            }
        }
    }

    Column(modifier = Modifier.fillMaxSize()) {
        // Connection status banner
        if (uiState.connectionState !is WebSocketState.Connected) {
            ConnectionStatusBanner(uiState.connectionState)
        }

        // Messages list
        LazyColumn(
            state = listState,
            modifier = Modifier
                .weight(1f)
                .fillMaxWidth()
                .padding(horizontal = 16.dp),
            verticalArrangement = Arrangement.spacedBy(8.dp),
            contentPadding = PaddingValues(vertical = 16.dp)
        ) {
            items(uiState.messages, key = { it.messageId }) { message ->
                MessageBubble(
                    message = message,
                    onVisible = {
                        if (message.isFromDemi && !message.isRead) {
                            viewModel.markMessageAsRead(message.messageId)
                        }
                    }
                )
            }

            // Typing indicator
            if (uiState.isTyping) {
                item {
                    TypingIndicator()
                }
            }
        }

        // Input field
        MessageInput(
            text = uiState.inputText,
            onTextChange = viewModel::updateInputText,
            onSend = viewModel::sendMessage,
            enabled = uiState.connectionState is WebSocketState.Connected
        )
    }
}

@Composable
fun ConnectionStatusBanner(state: WebSocketState) {
    val (text, color) = when (state) {
        is WebSocketState.Connecting -> "Connecting..." to MaterialTheme.colorScheme.tertiary
        is WebSocketState.Disconnected -> "Disconnected" to MaterialTheme.colorScheme.error
        is WebSocketState.Error -> "Connection error" to MaterialTheme.colorScheme.error
        is WebSocketState.Connected -> return // Don't show banner when connected
    }

    Surface(
        color = color,
        modifier = Modifier.fillMaxWidth()
    ) {
        Text(
            text = text,
            modifier = Modifier.padding(8.dp),
            color = MaterialTheme.colorScheme.onError,
            style = MaterialTheme.typography.bodySmall
        )
    }
}

@Composable
fun MessageBubble(
    message: Message,
    onVisible: () -> Unit
) {
    LaunchedEffect(message.messageId) {
        onVisible()
    }

    val isFromDemi = message.isFromDemi
    val bubbleColor = if (isFromDemi) {
        MaterialTheme.colorScheme.secondaryContainer
    } else {
        MaterialTheme.colorScheme.primaryContainer
    }
    val alignment = if (isFromDemi) Alignment.Start else Alignment.End

    Column(
        modifier = Modifier.fillMaxWidth(),
        horizontalAlignment = alignment
    ) {
        Box(
            modifier = Modifier
                .widthIn(max = 280.dp)
                .clip(RoundedCornerShape(16.dp))
                .background(bubbleColor)
                .padding(12.dp)
        ) {
            Text(
                text = message.content,
                color = if (isFromDemi) {
                    MaterialTheme.colorScheme.onSecondaryContainer
                } else {
                    MaterialTheme.colorScheme.onPrimaryContainer
                }
            )
        }

        // Status indicator (for user messages)
        if (!isFromDemi) {
            Text(
                text = when (message.status) {
                    "read" -> "Read"
                    "delivered" -> "Delivered"
                    else -> "Sent"
                },
                style = MaterialTheme.typography.labelSmall,
                color = MaterialTheme.colorScheme.onSurfaceVariant,
                modifier = Modifier.padding(top = 2.dp, end = 4.dp)
            )
        }
    }
}

@Composable
fun TypingIndicator() {
    Row(
        modifier = Modifier
            .clip(RoundedCornerShape(16.dp))
            .background(MaterialTheme.colorScheme.secondaryContainer)
            .padding(12.dp),
        horizontalArrangement = Arrangement.spacedBy(4.dp)
    ) {
        Text(
            text = "Demi is thinking...",
            style = MaterialTheme.typography.bodyMedium,
            color = MaterialTheme.colorScheme.onSecondaryContainer
        )
    }
}

@Composable
fun MessageInput(
    text: String,
    onTextChange: (String) -> Unit,
    onSend: () -> Unit,
    enabled: Boolean
) {
    Surface(
        tonalElevation = 3.dp,
        modifier = Modifier.fillMaxWidth()
    ) {
        Row(
            modifier = Modifier
                .padding(16.dp)
                .fillMaxWidth(),
            verticalAlignment = Alignment.CenterVertically
        ) {
            OutlinedTextField(
                value = text,
                onValueChange = onTextChange,
                placeholder = { Text("Message Demi...") },
                modifier = Modifier.weight(1f),
                enabled = enabled,
                singleLine = false,
                maxLines = 4
            )

            Spacer(modifier = Modifier.width(8.dp))

            IconButton(
                onClick = onSend,
                enabled = enabled && text.isNotBlank()
            ) {
                Icon(
                    imageVector = Icons.Default.Send,
                    contentDescription = "Send",
                    tint = if (enabled && text.isNotBlank()) {
                        MaterialTheme.colorScheme.primary
                    } else {
                        MaterialTheme.colorScheme.onSurfaceVariant
                    }
                )
            }
        }
    }
}
```

**android/app/src/main/kotlin/com/demi/chat/ui/dashboard/DashboardScreen.kt:**
```kotlin
package com.demi.chat.ui.dashboard

import androidx.compose.foundation.Canvas
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Delete
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.geometry.Offset
import androidx.compose.ui.geometry.Size
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.drawscope.Stroke
import androidx.compose.ui.unit.dp
import androidx.hilt.navigation.compose.hiltViewModel
import com.demi.chat.data.models.EmotionalState
import com.demi.chat.data.models.Session
import com.demi.chat.viewmodel.DashboardViewModel

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun DashboardScreen(
    viewModel: DashboardViewModel = hiltViewModel(),
    onExportData: () -> Unit
) {
    val uiState by viewModel.uiState.collectAsState()

    LaunchedEffect(Unit) {
        viewModel.loadSessions()
    }

    LazyColumn(
        modifier = Modifier
            .fillMaxSize()
            .padding(16.dp),
        verticalArrangement = Arrangement.spacedBy(24.dp)
    ) {
        // Emotional State Section
        item {
            Text(
                text = "Demi's Emotional State",
                style = MaterialTheme.typography.headlineSmall
            )
        }

        item {
            uiState.emotionalState?.let { state ->
                EmotionalStateCard(state)
            } ?: run {
                Card(modifier = Modifier.fillMaxWidth()) {
                    Text(
                        text = "No emotional data yet. Start chatting!",
                        modifier = Modifier.padding(16.dp),
                        style = MaterialTheme.typography.bodyMedium
                    )
                }
            }
        }

        // Stats Section
        item {
            Text(
                text = "Stats",
                style = MaterialTheme.typography.headlineSmall
            )
        }

        item {
            StatsCard(
                totalMessages = uiState.totalMessages,
                lastInteraction = uiState.lastInteraction
            )
        }

        // Sessions Section
        item {
            Text(
                text = "Active Sessions",
                style = MaterialTheme.typography.headlineSmall
            )
        }

        if (uiState.isLoadingSessions) {
            item {
                CircularProgressIndicator(modifier = Modifier.padding(16.dp))
            }
        } else {
            items(uiState.sessions) { session ->
                SessionCard(
                    session = session,
                    onRevoke = { viewModel.revokeSession(session.sessionId) }
                )
            }
        }

        // Export Data Button
        item {
            Spacer(modifier = Modifier.height(16.dp))
            OutlinedButton(
                onClick = onExportData,
                modifier = Modifier.fillMaxWidth()
            ) {
                Text("Export All Data (GDPR)")
            }
        }
    }
}

@Composable
fun EmotionalStateCard(state: EmotionalState) {
    Card(modifier = Modifier.fillMaxWidth()) {
        Column(modifier = Modifier.padding(16.dp)) {
            Text(
                text = "Mood: ${state.moodDescription()}",
                style = MaterialTheme.typography.titleMedium
            )

            Spacer(modifier = Modifier.height(16.dp))

            // Emotion bars
            EmotionBar("Happiness", state.happiness, Color(0xFF4CAF50))
            EmotionBar("Affection", state.affection, Color(0xFFE91E63))
            EmotionBar("Excitement", state.excitement, Color(0xFFFF9800))
            EmotionBar("Trust", state.trust, Color(0xFF2196F3))
            EmotionBar("Loneliness", state.loneliness, Color(0xFF9C27B0))
            EmotionBar("Sadness", state.sadness, Color(0xFF607D8B))
            EmotionBar("Frustration", state.frustration, Color(0xFFF44336))
            EmotionBar("Anger", state.anger, Color(0xFFD32F2F))
            EmotionBar("Fear", state.fear, Color(0xFF795548))
        }
    }
}

@Composable
fun EmotionBar(name: String, value: Float, color: Color) {
    Column(modifier = Modifier.padding(vertical = 4.dp)) {
        Row(
            modifier = Modifier.fillMaxWidth(),
            horizontalArrangement = Arrangement.SpaceBetween
        ) {
            Text(text = name, style = MaterialTheme.typography.bodySmall)
            Text(text = "${(value * 100).toInt()}%", style = MaterialTheme.typography.bodySmall)
        }
        LinearProgressIndicator(
            progress = { value },
            modifier = Modifier
                .fillMaxWidth()
                .height(8.dp),
            color = color,
            trackColor = color.copy(alpha = 0.2f)
        )
    }
}

@Composable
fun StatsCard(totalMessages: Int, lastInteraction: String?) {
    Card(modifier = Modifier.fillMaxWidth()) {
        Column(modifier = Modifier.padding(16.dp)) {
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.SpaceBetween
            ) {
                Text("Total Messages")
                Text("$totalMessages", style = MaterialTheme.typography.titleMedium)
            }
            Spacer(modifier = Modifier.height(8.dp))
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.SpaceBetween
            ) {
                Text("Last Interaction")
                Text(
                    text = lastInteraction?.take(10) ?: "Never",
                    style = MaterialTheme.typography.titleMedium
                )
            }
        }
    }
}

@Composable
fun SessionCard(session: Session, onRevoke: () -> Unit) {
    Card(modifier = Modifier.fillMaxWidth()) {
        Row(
            modifier = Modifier
                .padding(16.dp)
                .fillMaxWidth(),
            horizontalArrangement = Arrangement.SpaceBetween,
            verticalAlignment = Alignment.CenterVertically
        ) {
            Column {
                Text(
                    text = session.deviceName,
                    style = MaterialTheme.typography.titleMedium
                )
                Text(
                    text = if (session.isCurrent) "This device" else "Last active: ${session.lastActivity.take(10)}",
                    style = MaterialTheme.typography.bodySmall,
                    color = MaterialTheme.colorScheme.onSurfaceVariant
                )
            }

            if (!session.isCurrent) {
                IconButton(onClick = onRevoke) {
                    Icon(
                        imageVector = Icons.Default.Delete,
                        contentDescription = "Revoke session",
                        tint = MaterialTheme.colorScheme.error
                    )
                }
            }
        }
    }
}
```

**android/app/src/main/kotlin/com/demi/chat/MainActivity.kt:**
```kotlin
package com.demi.chat

import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.layout.*
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Chat
import androidx.compose.material.icons.filled.Dashboard
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Modifier
import androidx.hilt.navigation.compose.hiltViewModel
import androidx.navigation.compose.NavHost
import androidx.navigation.compose.composable
import androidx.navigation.compose.rememberNavController
import com.demi.chat.ui.chat.ChatScreen
import com.demi.chat.ui.dashboard.DashboardScreen
import com.demi.chat.ui.login.LoginScreen
import com.demi.chat.ui.theme.DemiChatTheme
import com.demi.chat.viewmodel.AuthViewModel
import dagger.hilt.android.AndroidEntryPoint

@AndroidEntryPoint
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            DemiChatTheme {
                Surface(
                    modifier = Modifier.fillMaxSize(),
                    color = MaterialTheme.colorScheme.background
                ) {
                    DemiApp()
                }
            }
        }
    }
}

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun DemiApp() {
    val navController = rememberNavController()
    val authViewModel: AuthViewModel = hiltViewModel()
    val authState by authViewModel.uiState.collectAsState()

    var selectedTab by remember { mutableIntStateOf(0) }

    if (!authState.isLoggedIn) {
        LoginScreen(
            viewModel = authViewModel,
            onLoginSuccess = { /* Navigation handled by LaunchedEffect in LoginScreen */ }
        )
    } else {
        Scaffold(
            bottomBar = {
                NavigationBar {
                    NavigationBarItem(
                        icon = { Icon(Icons.Default.Chat, contentDescription = "Chat") },
                        label = { Text("Chat") },
                        selected = selectedTab == 0,
                        onClick = { selectedTab = 0 }
                    )
                    NavigationBarItem(
                        icon = { Icon(Icons.Default.Dashboard, contentDescription = "Dashboard") },
                        label = { Text("Dashboard") },
                        selected = selectedTab == 1,
                        onClick = { selectedTab = 1 }
                    )
                }
            }
        ) { padding ->
            Box(modifier = Modifier.padding(padding)) {
                when (selectedTab) {
                    0 -> ChatScreen()
                    1 -> DashboardScreen(
                        onExportData = { /* TODO: Implement export */ }
                    )
                }
            }
        }
    }
}
```
  </action>
  <verify>
1. LoginScreen: `grep "fun LoginScreen" android/app/src/main/kotlin/com/demi/chat/ui/login/LoginScreen.kt`
2. ChatScreen: `grep "fun ChatScreen" android/app/src/main/kotlin/com/demi/chat/ui/chat/ChatScreen.kt`
3. DashboardScreen: `grep "fun DashboardScreen" android/app/src/main/kotlin/com/demi/chat/ui/dashboard/DashboardScreen.kt`
4. MainActivity: `grep "@AndroidEntryPoint" android/app/src/main/kotlin/com/demi/chat/MainActivity.kt`
  </verify>
  <done>
- LoginScreen with email/password fields, loading state, error display
- ChatScreen with message bubbles (iMessage style), typing indicator, status badges
- DashboardScreen with emotional state bars (9 dimensions), sessions list, stats
- MainActivity with bottom navigation (Chat, Dashboard tabs)
- Auto-scroll to latest message
- Read receipt marking on message visibility
- Ready for Task 7 (biometric, notifications, export)
  </done>
</task>

<task type="auto">
  <name>Task 7: Implement biometric authentication, notifications, and data export</name>
  <files>android/app/src/main/kotlin/com/demi/chat/utils/BiometricManager.kt, android/app/src/main/kotlin/com/demi/chat/utils/NotificationHelper.kt, android/app/src/main/kotlin/com/demi/chat/utils/DataExporter.kt</files>
  <action>
**android/app/src/main/kotlin/com/demi/chat/utils/BiometricManager.kt:**
```kotlin
package com.demi.chat.utils

import android.content.Context
import androidx.biometric.BiometricManager
import androidx.biometric.BiometricPrompt
import androidx.core.content.ContextCompat
import androidx.fragment.app.FragmentActivity
import dagger.hilt.android.qualifiers.ApplicationContext
import javax.inject.Inject
import javax.inject.Singleton

@Singleton
class DemiBiometricManager @Inject constructor(
    @ApplicationContext private val context: Context
) {
    private val biometricManager = BiometricManager.from(context)

    fun canAuthenticate(): Boolean {
        return biometricManager.canAuthenticate(
            BiometricManager.Authenticators.BIOMETRIC_STRONG or
            BiometricManager.Authenticators.DEVICE_CREDENTIAL
        ) == BiometricManager.BIOMETRIC_SUCCESS
    }

    fun authenticate(
        activity: FragmentActivity,
        title: String = "Authenticate to Demi",
        subtitle: String = "Use your fingerprint or face to unlock",
        onSuccess: () -> Unit,
        onError: (String) -> Unit
    ) {
        val executor = ContextCompat.getMainExecutor(context)

        val callback = object : BiometricPrompt.AuthenticationCallback() {
            override fun onAuthenticationSucceeded(result: BiometricPrompt.AuthenticationResult) {
                super.onAuthenticationSucceeded(result)
                onSuccess()
            }

            override fun onAuthenticationError(errorCode: Int, errString: CharSequence) {
                super.onAuthenticationError(errorCode, errString)
                onError(errString.toString())
            }

            override fun onAuthenticationFailed() {
                super.onAuthenticationFailed()
                // Don't call onError here - user can retry
            }
        }

        val biometricPrompt = BiometricPrompt(activity, executor, callback)

        val promptInfo = BiometricPrompt.PromptInfo.Builder()
            .setTitle(title)
            .setSubtitle(subtitle)
            .setAllowedAuthenticators(
                BiometricManager.Authenticators.BIOMETRIC_STRONG or
                BiometricManager.Authenticators.DEVICE_CREDENTIAL
            )
            .build()

        biometricPrompt.authenticate(promptInfo)
    }
}
```

**android/app/src/main/kotlin/com/demi/chat/utils/NotificationHelper.kt:**
```kotlin
package com.demi.chat.utils

import android.Manifest
import android.app.NotificationChannel
import android.app.NotificationManager
import android.app.PendingIntent
import android.content.Context
import android.content.Intent
import android.content.pm.PackageManager
import androidx.core.app.ActivityCompat
import androidx.core.app.NotificationCompat
import androidx.core.app.NotificationManagerCompat
import com.demi.chat.MainActivity
import com.demi.chat.R
import dagger.hilt.android.qualifiers.ApplicationContext
import javax.inject.Inject
import javax.inject.Singleton

@Singleton
class NotificationHelper @Inject constructor(
    @ApplicationContext private val context: Context
) {
    companion object {
        const val CHANNEL_MESSAGES = "demi_messages"
        const val CHANNEL_CHECKINS = "demi_checkins"
        const val NOTIFICATION_ID_MESSAGE = 1001
        const val NOTIFICATION_ID_CHECKIN = 1002
    }

    init {
        createNotificationChannels()
    }

    private fun createNotificationChannels() {
        val messageChannel = NotificationChannel(
            CHANNEL_MESSAGES,
            "Messages",
            NotificationManager.IMPORTANCE_DEFAULT
        ).apply {
            description = "New messages from Demi"
        }

        val checkinChannel = NotificationChannel(
            CHANNEL_CHECKINS,
            "Check-ins",
            NotificationManager.IMPORTANCE_HIGH
        ).apply {
            description = "Autonomous check-ins and important messages from Demi"
        }

        val notificationManager = context.getSystemService(NotificationManager::class.java)
        notificationManager.createNotificationChannel(messageChannel)
        notificationManager.createNotificationChannel(checkinChannel)
    }

    fun showMessageNotification(title: String, content: String, isCheckin: Boolean = false) {
        if (ActivityCompat.checkSelfPermission(
                context,
                Manifest.permission.POST_NOTIFICATIONS
            ) != PackageManager.PERMISSION_GRANTED
        ) {
            return
        }

        val intent = Intent(context, MainActivity::class.java).apply {
            flags = Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_CLEAR_TASK
        }
        val pendingIntent = PendingIntent.getActivity(
            context, 0, intent,
            PendingIntent.FLAG_IMMUTABLE
        )

        val channelId = if (isCheckin) CHANNEL_CHECKINS else CHANNEL_MESSAGES
        val notificationId = if (isCheckin) NOTIFICATION_ID_CHECKIN else NOTIFICATION_ID_MESSAGE

        val notification = NotificationCompat.Builder(context, channelId)
            .setSmallIcon(R.drawable.ic_notification) // You'll need to create this
            .setContentTitle(title)
            .setContentText(content)
            .setPriority(if (isCheckin) NotificationCompat.PRIORITY_HIGH else NotificationCompat.PRIORITY_DEFAULT)
            .setContentIntent(pendingIntent)
            .setAutoCancel(true)
            .build()

        NotificationManagerCompat.from(context).notify(notificationId, notification)
    }

    fun cancelAllNotifications() {
        NotificationManagerCompat.from(context).cancelAll()
    }
}
```

**android/app/src/main/kotlin/com/demi/chat/utils/DataExporter.kt:**
```kotlin
package com.demi.chat.utils

import android.content.Context
import android.content.Intent
import android.net.Uri
import androidx.core.content.FileProvider
import com.demi.chat.data.models.Message
import com.demi.chat.data.repository.AuthRepository
import com.demi.chat.data.repository.ChatRepository
import com.google.gson.GsonBuilder
import dagger.hilt.android.qualifiers.ApplicationContext
import kotlinx.coroutines.flow.first
import java.io.File
import java.text.SimpleDateFormat
import java.util.*
import javax.inject.Inject
import javax.inject.Singleton

data class ExportData(
    val exportedAt: String,
    val userId: String?,
    val email: String?,
    val messages: List<Message>,
    val totalMessages: Int
)

@Singleton
class DataExporter @Inject constructor(
    @ApplicationContext private val context: Context,
    private val chatRepository: ChatRepository,
    private val tokenManager: TokenManager
) {
    private val gson = GsonBuilder()
        .setPrettyPrinting()
        .setDateFormat("yyyy-MM-dd'T'HH:mm:ss'Z'")
        .create()

    suspend fun exportToJson(): File {
        val messages = chatRepository.messages.first()

        val exportData = ExportData(
            exportedAt = SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss'Z'", Locale.US)
                .format(Date()),
            userId = tokenManager.userId,
            email = tokenManager.email,
            messages = messages,
            totalMessages = messages.size
        )

        val json = gson.toJson(exportData)

        val timestamp = SimpleDateFormat("yyyyMMdd_HHmmss", Locale.US).format(Date())
        val fileName = "demi_export_$timestamp.json"
        val file = File(context.cacheDir, fileName)
        file.writeText(json)

        return file
    }

    fun shareExportedFile(file: File): Intent {
        val uri: Uri = FileProvider.getUriForFile(
            context,
            "${context.packageName}.fileprovider",
            file
        )

        return Intent(Intent.ACTION_SEND).apply {
            type = "application/json"
            putExtra(Intent.EXTRA_STREAM, uri)
            addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION)
        }
    }
}
```

**android/app/src/main/kotlin/com/demi/chat/DemiApplication.kt:**
```kotlin
package com.demi.chat

import android.app.Application
import dagger.hilt.android.HiltAndroidApp

@HiltAndroidApp
class DemiApplication : Application()
```

**android/app/src/main/kotlin/com/demi/chat/di/AppModule.kt:**
```kotlin
package com.demi.chat.di

import android.content.Context
import com.demi.chat.api.DemiApiClient
import com.demi.chat.api.WebSocketManager
import com.demi.chat.data.repository.AuthRepository
import com.demi.chat.data.repository.ChatRepository
import com.demi.chat.utils.*
import dagger.Module
import dagger.Provides
import dagger.hilt.InstallIn
import dagger.hilt.android.qualifiers.ApplicationContext
import dagger.hilt.components.SingletonComponent
import javax.inject.Singleton

@Module
@InstallIn(SingletonComponent::class)
object AppModule {

    @Provides
    @Singleton
    fun provideTokenManager(@ApplicationContext context: Context): TokenManager {
        return TokenManager(context)
    }

    @Provides
    @Singleton
    fun provideDemiApiClient(tokenManager: TokenManager): DemiApiClient {
        return DemiApiClient(tokenManager)
    }

    @Provides
    @Singleton
    fun provideWebSocketManager(apiClient: DemiApiClient): WebSocketManager {
        return WebSocketManager(apiClient)
    }

    @Provides
    @Singleton
    fun provideAuthRepository(
        apiClient: DemiApiClient,
        tokenManager: TokenManager
    ): AuthRepository {
        return AuthRepository(apiClient, tokenManager)
    }

    @Provides
    @Singleton
    fun provideChatRepository(webSocketManager: WebSocketManager): ChatRepository {
        return ChatRepository(webSocketManager)
    }

    @Provides
    @Singleton
    fun provideBiometricManager(@ApplicationContext context: Context): DemiBiometricManager {
        return DemiBiometricManager(context)
    }

    @Provides
    @Singleton
    fun provideNotificationHelper(@ApplicationContext context: Context): NotificationHelper {
        return NotificationHelper(context)
    }

    @Provides
    @Singleton
    fun provideDataExporter(
        @ApplicationContext context: Context,
        chatRepository: ChatRepository,
        tokenManager: TokenManager
    ): DataExporter {
        return DataExporter(context, chatRepository, tokenManager)
    }
}
```
  </action>
  <verify>
1. BiometricManager: `grep "fun authenticate" android/app/src/main/kotlin/com/demi/chat/utils/BiometricManager.kt`
2. NotificationHelper: `grep "fun showMessageNotification" android/app/src/main/kotlin/com/demi/chat/utils/NotificationHelper.kt`
3. DataExporter: `grep "suspend fun exportToJson" android/app/src/main/kotlin/com/demi/chat/utils/DataExporter.kt`
4. Hilt module: `grep "@Module" android/app/src/main/kotlin/com/demi/chat/di/AppModule.kt`
  </verify>
  <done>
- DemiBiometricManager with BiometricPrompt API
- NotificationHelper with message and check-in channels
- DataExporter for GDPR-compliant JSON export
- DemiApplication with @HiltAndroidApp
- AppModule with all dependency providers
- Ready for Task 8 (resources and testing)
  </done>
</task>

<task type="auto">
  <name>Task 8: Create resources, theme, and basic test setup</name>
  <files>android/app/src/main/res/**/*.xml, android/app/src/main/kotlin/com/demi/chat/ui/theme/*.kt, android/app/src/test/**/*.kt</files>
  <action>
**android/app/src/main/res/values/strings.xml:**
```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="app_name">Demi</string>
    <string name="login_title">Sign in to Demi</string>
    <string name="email_hint">Email</string>
    <string name="password_hint">Password</string>
    <string name="sign_in">Sign In</string>
    <string name="message_hint">Message Demi...</string>
    <string name="send">Send</string>
    <string name="chat">Chat</string>
    <string name="dashboard">Dashboard</string>
    <string name="emotional_state">Demi\'s Emotional State</string>
    <string name="active_sessions">Active Sessions</string>
    <string name="export_data">Export All Data (GDPR)</string>
    <string name="connecting">Connecting...</string>
    <string name="disconnected">Disconnected</string>
    <string name="demi_thinking">Demi is thinking...</string>
    <string name="read">Read</string>
    <string name="delivered">Delivered</string>
    <string name="sent">Sent</string>
</resources>
```

**android/app/src/main/res/values/colors.xml:**
```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <color name="purple_200">#FFBB86FC</color>
    <color name="purple_500">#FF6200EE</color>
    <color name="purple_700">#FF3700B3</color>
    <color name="teal_200">#FF03DAC5</color>
    <color name="teal_700">#FF018786</color>
    <color name="black">#FF000000</color>
    <color name="white">#FFFFFFFF</color>

    <!-- Demi brand colors -->
    <color name="demi_primary">#FF7C4DFF</color>
    <color name="demi_secondary">#FFE040FB</color>
    <color name="demi_background">#FF121212</color>
</resources>
```

**android/app/src/main/res/values/themes.xml:**
```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <style name="Theme.DemiChat" parent="android:Theme.Material.Light.NoActionBar">
        <item name="android:statusBarColor">@color/demi_primary</item>
    </style>
</resources>
```

**android/app/src/main/kotlin/com/demi/chat/ui/theme/Theme.kt:**
```kotlin
package com.demi.chat.ui.theme

import android.app.Activity
import androidx.compose.foundation.isSystemInDarkTheme
import androidx.compose.material3.*
import androidx.compose.runtime.Composable
import androidx.compose.runtime.SideEffect
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.toArgb
import androidx.compose.ui.platform.LocalView
import androidx.core.view.WindowCompat

private val DarkColorScheme = darkColorScheme(
    primary = Color(0xFF7C4DFF),
    secondary = Color(0xFFE040FB),
    tertiary = Color(0xFF03DAC5),
    background = Color(0xFF121212),
    surface = Color(0xFF1E1E1E),
    onPrimary = Color.White,
    onSecondary = Color.White,
    onTertiary = Color.Black,
    onBackground = Color.White,
    onSurface = Color.White,
    primaryContainer = Color(0xFF5E35B1),
    secondaryContainer = Color(0xFF2D2D2D),
    onPrimaryContainer = Color.White,
    onSecondaryContainer = Color(0xFFE0E0E0)
)

private val LightColorScheme = lightColorScheme(
    primary = Color(0xFF6200EE),
    secondary = Color(0xFFE040FB),
    tertiary = Color(0xFF03DAC5),
    background = Color(0xFFFFFBFE),
    surface = Color(0xFFFFFBFE),
    onPrimary = Color.White,
    onSecondary = Color.White,
    onTertiary = Color.Black,
    onBackground = Color(0xFF1C1B1F),
    onSurface = Color(0xFF1C1B1F),
    primaryContainer = Color(0xFFE8DEF8),
    secondaryContainer = Color(0xFFF3E5F5),
    onPrimaryContainer = Color(0xFF21005D),
    onSecondaryContainer = Color(0xFF1D192B)
)

@Composable
fun DemiChatTheme(
    darkTheme: Boolean = isSystemInDarkTheme(),
    content: @Composable () -> Unit
) {
    val colorScheme = if (darkTheme) DarkColorScheme else LightColorScheme

    val view = LocalView.current
    if (!view.isInEditMode) {
        SideEffect {
            val window = (view.context as Activity).window
            window.statusBarColor = colorScheme.primary.toArgb()
            WindowCompat.getInsetsController(window, view).isAppearanceLightStatusBars = !darkTheme
        }
    }

    MaterialTheme(
        colorScheme = colorScheme,
        typography = Typography,
        content = content
    )
}
```

**android/app/src/main/kotlin/com/demi/chat/ui/theme/Type.kt:**
```kotlin
package com.demi.chat.ui.theme

import androidx.compose.material3.Typography
import androidx.compose.ui.text.TextStyle
import androidx.compose.ui.text.font.FontFamily
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.sp

val Typography = Typography(
    displayLarge = TextStyle(
        fontFamily = FontFamily.Default,
        fontWeight = FontWeight.Bold,
        fontSize = 57.sp,
        lineHeight = 64.sp,
        letterSpacing = (-0.25).sp
    ),
    headlineSmall = TextStyle(
        fontFamily = FontFamily.Default,
        fontWeight = FontWeight.SemiBold,
        fontSize = 24.sp,
        lineHeight = 32.sp,
        letterSpacing = 0.sp
    ),
    titleMedium = TextStyle(
        fontFamily = FontFamily.Default,
        fontWeight = FontWeight.Medium,
        fontSize = 16.sp,
        lineHeight = 24.sp,
        letterSpacing = 0.15.sp
    ),
    bodyLarge = TextStyle(
        fontFamily = FontFamily.Default,
        fontWeight = FontWeight.Normal,
        fontSize = 16.sp,
        lineHeight = 24.sp,
        letterSpacing = 0.5.sp
    ),
    bodyMedium = TextStyle(
        fontFamily = FontFamily.Default,
        fontWeight = FontWeight.Normal,
        fontSize = 14.sp,
        lineHeight = 20.sp,
        letterSpacing = 0.25.sp
    ),
    labelSmall = TextStyle(
        fontFamily = FontFamily.Default,
        fontWeight = FontWeight.Medium,
        fontSize = 11.sp,
        lineHeight = 16.sp,
        letterSpacing = 0.5.sp
    )
)
```

**android/app/src/test/kotlin/com/demi/chat/EmotionalStateTest.kt:**
```kotlin
package com.demi.chat

import com.demi.chat.data.models.EmotionalState
import org.junit.Assert.*
import org.junit.Test

class EmotionalStateTest {

    @Test
    fun `dominantEmotion returns highest value emotion`() {
        val state = EmotionalState(
            happiness = 0.9f,
            sadness = 0.1f,
            loneliness = 0.2f
        )
        val (emotion, value) = state.dominantEmotion()
        assertEquals("happiness", emotion)
        assertEquals(0.9f, value)
    }

    @Test
    fun `moodDescription formats correctly for high intensity`() {
        val state = EmotionalState(excitement = 0.85f)
        val description = state.moodDescription()
        assertTrue(description.contains("very"))
    }

    @Test
    fun `moodDescription formats correctly for low intensity`() {
        val state = EmotionalState(sadness = 0.3f)
        val description = state.moodDescription()
        assertTrue(description.contains("slightly") || description.contains("somewhat"))
    }
}
```

**android/app/src/test/kotlin/com/demi/chat/TokenManagerTest.kt:**
```kotlin
package com.demi.chat

import org.junit.Assert.*
import org.junit.Test

class TokenManagerTest {

    @Test
    fun `session timeout calculation`() {
        // 30 minutes = 1800000 ms
        val thirtyMinutesMs = 30 * 60 * 1000L
        assertEquals(1800000L, thirtyMinutesMs)
    }

    @Test
    fun `token expiry check logic`() {
        val currentTime = System.currentTimeMillis()
        val expiryInFuture = currentTime + 60000
        val expiryInPast = currentTime - 60000

        assertTrue(currentTime > expiryInPast) // expired
        assertFalse(currentTime > expiryInFuture) // not expired
    }
}
```
  </action>
  <verify>
1. strings.xml: `grep "app_name" android/app/src/main/res/values/strings.xml`
2. Theme.kt: `grep "DemiChatTheme" android/app/src/main/kotlin/com/demi/chat/ui/theme/Theme.kt`
3. Test file: `ls android/app/src/test/kotlin/com/demi/chat/EmotionalStateTest.kt`
4. Colors defined: `grep "demi_primary" android/app/src/main/res/values/colors.xml`
  </verify>
  <done>
- strings.xml with all app strings
- colors.xml with Demi brand colors
- themes.xml for Android theme
- Theme.kt with Material 3 dark/light themes
- Type.kt with typography definitions
- EmotionalStateTest unit tests
- TokenManagerTest unit tests
- Android client implementation COMPLETE
  </done>
</task>

</tasks>

<verification>
After all tasks complete, verify the following:

1. **Build:** `cd android && ./gradlew assembleDebug` builds without errors
2. **Login:** App launches, shows login screen, can enter credentials
3. **Authentication:** Login with valid backend credentials returns tokens
4. **WebSocket:** After login, WebSocket connects and receives history
5. **Messaging:** User can send message, Demi responds via WebSocket
6. **Read Receipts:** Messages show Sent → Delivered → Read status
7. **Typing:** "Demi is thinking..." appears while response generates
8. **Dashboard:** Shows emotional state bars and active sessions
9. **Session Management:** Can view and revoke other sessions
10. **Biometric:** Biometric prompt appears after session timeout
11. **Notifications:** Test notification appears for new message
12. **Export:** Data exports to JSON file with all messages

Run integration test:
1. Start FastAPI backend: `python3 src/api/main.py`
2. Run Android emulator (API 31+)
3. Install app: `./gradlew installDebug`
4. Complete login flow
5. Send test messages
6. Verify bidirectional communication

All 8 tasks must complete for Phase 06 to be finished.
</verification>

<success_criteria>
- Android project builds with Gradle (API 31+)
- Login screen authenticates against FastAPI backend
- WebSocket connects and maintains real-time connection
- Messages send and receive with correct formatting
- Read/delivered status indicators update correctly
- Typing indicator shows "Demi is thinking..."
- Dashboard displays 9-dimension emotional state
- Session list shows all active devices
- Session revocation works
- Biometric authentication prompts after 30-minute timeout
- Notifications display for new messages
- GDPR data export generates valid JSON
- Unit tests pass
- No import errors, all Kotlin syntax valid
- Phase 06 Android Integration 100% complete
</success_criteria>

<output>
After completion, create `.planning/phases/06-android-integration/06-04-SUMMARY.md`

Update `.planning/ROADMAP.md`:
- Phase 06 completion: 4/4 plans complete
- Update phase status from "In Progress" to "Complete"

Update `.planning/STATE.md`:
- Mark Phase 06 as complete
- Note Android client closes the gap from verification
</output>
