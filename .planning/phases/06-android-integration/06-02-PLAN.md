---
phase: 06-android-integration
plan: 02
type: execute
wave: 2
depends_on: ["06-01"]
files_modified:
  - src/api/messages.py
  - src/api/websocket.py
  - src/api/models.py
  - src/api/migrations.py
autonomous: true

must_haves:
  truths:
    - "WebSocket /api/v1/chat/ws enables bidirectional real-time messaging"
    - "Messages include sender, content, timestamp, Demi's emotion_state, conversation_id"
    - "Last 7 days of history loaded on connection"
    - "Read receipts track Delivered vs Read with timestamps"
    - "Typing indicator shows 'Demi is thinking...' during composition"
  artifacts:
    - path: "src/api/messages.py"
      provides: "Message storage and retrieval logic"
      exports: ["store_message", "get_conversation_history", "mark_as_read"]
      min_lines: 200
    - path: "src/api/websocket.py"
      provides: "WebSocket connection handler for real-time messaging"
      exports: ["router", "ConnectionManager"]
      min_lines: 300
  key_links:
    - from: "src/api/websocket.py"
      to: "src/conductor/orchestrator.py"
      via: "conductor.request_inference(platform='android')"
      pattern: "conductor\\.request_inference"
    - from: "src/api/websocket.py"
      to: "android_messages table"
      via: "store_message() persistence"
      pattern: "INSERT INTO android_messages"

---

<objective>
Create WebSocket-based real-time messaging system that routes Android messages through Demi's LLM pipeline, persists conversation history with emotional state, supports read receipts, and provides typing indicators. Messages flow bidirectionally: user sends via WebSocket, Demi responds via same connection with emotion_state included.

Purpose: Real-time messaging ensures Demi feels responsive and present. WebSocket enables Demi to initiate autonomous messages (check-ins, guilt-trips) without polling. Emotion state tracking maintains personality consistency. Read receipts let Demi know when user reads her messages (important for autonomy).

Output: WebSocket endpoint, message persistence with 7-day history, read receipts, typing indicators, emotion state in every response.
</objective>

<execution_context>
@/home/mystiatech/.claude/get-shit-done/workflows/execute-plan.md
@/home/mystiatech/projects/Demi/.planning/phases/06-android-integration/06-DISCOVERY.md
@/home/mystiatech/projects/Demi/.planning/phases/06-android-integration/06-CONTEXT.md
</execution_context>

<context>
@.planning/phases/06-android-integration/06-01-SUMMARY.md
@.planning/phases/04-llm-integration/04-04-SUMMARY.md
@src/conductor/orchestrator.py
@src/models/emotional_state.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Message model and database persistence</name>
  <files>src/api/models.py, src/api/migrations.py, src/api/messages.py</files>
  <action>
Add to `src/api/models.py`:

```python
from typing import Dict, Optional

@dataclass
class AndroidMessage:
    """Message in Android conversation"""
    message_id: str  # UUID
    conversation_id: str  # Thread ID (user_id for now)
    user_id: str  # Owner of conversation
    sender: str  # "user" or "demi"
    content: str
    emotion_state: Optional[Dict[str, float]] = None
    status: str = "sent"  # sent, delivered, read
    delivered_at: Optional[datetime] = None
    read_at: Optional[datetime] = None
    created_at: datetime = field(default_factory=lambda: datetime.now(UTC))

    def to_dict(self) -> dict:
        return {
            "message_id": self.message_id,
            "conversation_id": self.conversation_id,
            "sender": self.sender,
            "content": self.content,
            "emotion_state": self.emotion_state,
            "status": self.status,
            "delivered_at": self.delivered_at.isoformat() if self.delivered_at else None,
            "read_at": self.read_at.isoformat() if self.read_at else None,
            "created_at": self.created_at.isoformat()
        }

class SendMessageRequest(BaseModel):
    """Send message from Android client"""
    content: str

class MessageEvent(BaseModel):
    """WebSocket event"""
    event: str  # "message", "typing", "read_receipt"
    data: dict
```

Update `src/api/migrations.py`:

```python
def create_android_messages_table():
    """Create messages table with read receipts"""
    db_path = get_db_path()
    with sqlite3.connect(db_path) as conn:
        conn.execute("""
        CREATE TABLE IF NOT EXISTS android_messages (
            message_id TEXT PRIMARY KEY,
            conversation_id TEXT NOT NULL,
            user_id TEXT NOT NULL,
            sender TEXT NOT NULL,
            content TEXT NOT NULL,
            emotion_state JSON,
            status TEXT DEFAULT 'sent',
            delivered_at TIMESTAMP,
            read_at TIMESTAMP,
            created_at TIMESTAMP NOT NULL,
            FOREIGN KEY (user_id) REFERENCES users(user_id) ON DELETE CASCADE
        )
        """)
        # Index for conversation queries
        conn.execute("""
        CREATE INDEX IF NOT EXISTS idx_messages_conversation
        ON android_messages(conversation_id, created_at DESC)
        """)
        # Index for unread messages
        conn.execute("""
        CREATE INDEX IF NOT EXISTS idx_messages_unread
        ON android_messages(user_id, status, sender)
        WHERE status != 'read' AND sender = 'demi'
        """)
        conn.commit()
        logger.info("Android messages table created/verified")
```

Create `src/api/messages.py`:

```python
import sqlite3
import json
import uuid
from datetime import datetime, timedelta, UTC
from typing import List, Optional, Dict
from src.api.models import AndroidMessage
from src.core.logger import DemiLogger

logger = DemiLogger()

def get_db_path() -> str:
    db_url = os.getenv("DATABASE_URL", "sqlite:////home/user/.demi/demi.db")
    return db_url.replace("sqlite:///", "")

async def store_message(
    conversation_id: str,
    user_id: str,
    sender: str,
    content: str,
    emotion_state: Optional[Dict[str, float]] = None
) -> AndroidMessage:
    """Store message in database"""
    message = AndroidMessage(
        message_id=str(uuid.uuid4()),
        conversation_id=conversation_id,
        user_id=user_id,
        sender=sender,
        content=content,
        emotion_state=emotion_state,
        status="sent",
        created_at=datetime.now(UTC)
    )

    db_path = get_db_path()
    with sqlite3.connect(db_path) as conn:
        conn.execute("""
        INSERT INTO android_messages
        (message_id, conversation_id, user_id, sender, content, emotion_state, status, created_at)
        VALUES (?, ?, ?, ?, ?, ?, ?, ?)
        """, (
            message.message_id,
            message.conversation_id,
            message.user_id,
            message.sender,
            message.content,
            json.dumps(emotion_state) if emotion_state else None,
            message.status,
            message.created_at.isoformat()
        ))
        conn.commit()

    logger.info(f"Message stored: {message.message_id} ({sender})")
    return message

async def get_conversation_history(
    conversation_id: str,
    days: int = 7,
    limit: int = 100
) -> List[AndroidMessage]:
    """Load last N days of conversation history"""
    cutoff = datetime.now(UTC) - timedelta(days=days)
    db_path = get_db_path()

    with sqlite3.connect(db_path) as conn:
        conn.row_factory = sqlite3.Row
        rows = conn.execute("""
        SELECT * FROM android_messages
        WHERE conversation_id = ? AND created_at > ?
        ORDER BY created_at DESC
        LIMIT ?
        """, (conversation_id, cutoff.isoformat(), limit)).fetchall()

    messages = []
    for row in reversed(rows):  # Reverse for chronological order
        emotion_state = json.loads(row["emotion_state"]) if row["emotion_state"] else None
        messages.append(AndroidMessage(
            message_id=row["message_id"],
            conversation_id=row["conversation_id"],
            user_id=row["user_id"],
            sender=row["sender"],
            content=row["content"],
            emotion_state=emotion_state,
            status=row["status"],
            delivered_at=datetime.fromisoformat(row["delivered_at"]) if row["delivered_at"] else None,
            read_at=datetime.fromisoformat(row["read_at"]) if row["read_at"] else None,
            created_at=datetime.fromisoformat(row["created_at"])
        ))

    return messages

async def mark_as_read(message_id: str) -> None:
    """Mark message as read with timestamp"""
    db_path = get_db_path()
    with sqlite3.connect(db_path) as conn:
        conn.execute("""
        UPDATE android_messages
        SET status = 'read', read_at = ?
        WHERE message_id = ?
        """, (datetime.now(UTC).isoformat(), message_id))
        conn.commit()
    logger.debug(f"Message marked read: {message_id}")

async def mark_as_delivered(message_id: str) -> None:
    """Mark message as delivered"""
    db_path = get_db_path()
    with sqlite3.connect(db_path) as conn:
        conn.execute("""
        UPDATE android_messages
        SET status = 'delivered', delivered_at = ?
        WHERE message_id = ? AND status = 'sent'
        """, (datetime.now(UTC).isoformat(), message_id))
        conn.commit()
```
  </action>
  <verify>
1. Models added: `grep "class AndroidMessage\|class SendMessageRequest\|class MessageEvent" src/api/models.py`
2. Migration exists: `grep "def create_android_messages_table" src/api/migrations.py`
3. Import check: `python3 -c "from src.api.messages import store_message, get_conversation_history, mark_as_read; print('OK')"`
  </verify>
  <done>
- AndroidMessage dataclass with read receipts (status, delivered_at, read_at)
- SendMessageRequest and MessageEvent schemas
- android_messages table migration with indexes
- store_message() function
- get_conversation_history() loads last 7 days
- mark_as_read() and mark_as_delivered() for read receipts
- Ready for Task 2 (WebSocket handler)
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement WebSocket real-time messaging endpoint</name>
  <files>src/api/websocket.py</files>
  <action>
Create `src/api/websocket.py`:

```python
from fastapi import APIRouter, WebSocket, WebSocketDisconnect, HTTPException, Query
from typing import Dict, Set
import asyncio
import json
from datetime import datetime, UTC

from src.api.auth import verify_token
from src.api.messages import store_message, get_conversation_history, mark_as_read, mark_as_delivered
from src.core.logger import DemiLogger

router = APIRouter(prefix="/api/v1/chat", tags=["chat"])
logger = DemiLogger()

class ConnectionManager:
    """Manage active WebSocket connections for real-time messaging"""

    def __init__(self):
        self.active_connections: Dict[str, WebSocket] = {}  # user_id -> websocket

    async def connect(self, user_id: str, websocket: WebSocket):
        """Register new connection"""
        await websocket.accept()
        self.active_connections[user_id] = websocket
        logger.info(f"WebSocket connected: user {user_id}")

    def disconnect(self, user_id: str):
        """Remove connection"""
        if user_id in self.active_connections:
            del self.active_connections[user_id]
            logger.info(f"WebSocket disconnected: user {user_id}")

    async def send_message(self, user_id: str, event: str, data: dict):
        """Send message to specific user"""
        if user_id in self.active_connections:
            websocket = self.active_connections[user_id]
            try:
                await websocket.send_json({
                    "event": event,
                    "data": data,
                    "timestamp": datetime.now(UTC).isoformat()
                })
            except Exception as e:
                logger.error(f"Error sending to {user_id}: {e}")
                self.disconnect(user_id)

    async def broadcast_typing(self, user_id: str, is_typing: bool):
        """Send typing indicator"""
        await self.send_message(user_id, "typing", {"is_typing": is_typing})

manager = ConnectionManager()

@router.websocket("/ws")
async def websocket_endpoint(
    websocket: WebSocket,
    token: str = Query(..., description="JWT access token")
):
    """
    WebSocket endpoint for bidirectional real-time messaging.

    Client sends:
    {
      "event": "message",
      "data": {"content": "Hey Demi"}
    }

    Server sends (Demi's response):
    {
      "event": "message",
      "data": {
        "message_id": "uuid",
        "sender": "demi",
        "content": "Yeah?",
        "emotion_state": {...},
        "created_at": "..."
      },
      "timestamp": "..."
    }

    Server also sends:
    - typing events: {"event": "typing", "data": {"is_typing": true}}
    - read_receipt events: {"event": "read_receipt", "data": {"message_id": "..."}}
    - delivered events: {"event": "delivered", "data": {"message_id": "..."}}
    """

    # Verify JWT token
    try:
        payload = verify_token(token, token_type="access")
        user_id = payload["user_id"]
        conversation_id = user_id  # For v1, conversation_id = user_id (1-1 chat)
    except HTTPException as e:
        await websocket.close(code=1008, reason=str(e.detail))
        return

    # Connect
    await manager.connect(user_id, websocket)

    try:
        # Send conversation history (last 7 days)
        history = await get_conversation_history(conversation_id, days=7, limit=100)
        await websocket.send_json({
            "event": "history",
            "data": {
                "messages": [msg.to_dict() for msg in history],
                "count": len(history)
            }
        })

        # Main message loop
        while True:
            # Receive message from Android client
            raw_data = await websocket.receive_json()
            event = raw_data.get("event")
            data = raw_data.get("data", {})

            if event == "message":
                # Store user's message
                user_content = data.get("content", "").strip()
                if not user_content:
                    continue

                user_message = await store_message(
                    conversation_id=conversation_id,
                    user_id=user_id,
                    sender="user",
                    content=user_content
                )

                # Mark as delivered immediately
                await mark_as_delivered(user_message.message_id)

                # Send typing indicator
                await manager.broadcast_typing(user_id, is_typing=True)

                # Get Demi's response via Conductor
                try:
                    # Import conductor (avoid circular import)
                    from src.conductor.orchestrator import get_conductor_instance
                    conductor = get_conductor_instance()

                    response = await conductor.request_inference(
                        platform="android",
                        user_id=user_id,
                        content=user_content,
                        context={
                            "source": "android_websocket",
                            "conversation_id": conversation_id,
                            "message_id": user_message.message_id
                        }
                    )

                    # Stop typing indicator
                    await manager.broadcast_typing(user_id, is_typing=False)

                    # Store Demi's response
                    emotion_state = response.get("emotion_state", {})
                    demi_message = await store_message(
                        conversation_id=conversation_id,
                        user_id=user_id,
                        sender="demi",
                        content=response.get("content", ""),
                        emotion_state=emotion_state
                    )

                    # Send response to client
                    await websocket.send_json({
                        "event": "message",
                        "data": demi_message.to_dict(),
                        "timestamp": datetime.now(UTC).isoformat()
                    })

                except Exception as e:
                    logger.error(f"LLM inference error: {e}")
                    await manager.broadcast_typing(user_id, is_typing=False)
                    await websocket.send_json({
                        "event": "error",
                        "data": {"message": "Error generating response"}
                    })

            elif event == "read_receipt":
                # Mark message as read
                message_id = data.get("message_id")
                if message_id:
                    await mark_as_read(message_id)

            elif event == "ping":
                # Keepalive
                await websocket.send_json({"event": "pong"})

    except WebSocketDisconnect:
        manager.disconnect(user_id)
    except Exception as e:
        logger.error(f"WebSocket error for user {user_id}: {e}")
        manager.disconnect(user_id)

# Export manager for autonomous messages (Plan 03)
def get_connection_manager() -> ConnectionManager:
    """Get singleton connection manager"""
    return manager
```
  </action>
  <verify>
1. Syntax check: `python3 -m py_compile src/api/websocket.py`
2. Import check: `python3 -c "from src.api.websocket import router, ConnectionManager, get_connection_manager; print('OK')"`
3. WebSocket route: `grep "@router.websocket" src/api/websocket.py`
  </verify>
  <done>
- WebSocket endpoint created (/api/v1/chat/ws)
- ConnectionManager for active connections
- Bidirectional messaging (user → Demi → user)
- Message persistence with emotion_state
- Typing indicator ("Demi is thinking...")
- Read receipts (mark_as_read)
- Delivered receipts (mark_as_delivered)
- 7-day conversation history on connection
- Routes through Conductor.request_inference()
- Ready for Task 3 (wire into FastAPI app)
  </done>
</task>

<task type="auto">
  <name>Task 3: Wire WebSocket into FastAPI app and update migrations</name>
  <files>src/api/__init__.py, src/api/migrations.py</files>
  <action>
Update `src/api/__init__.py`:

```python
from src.api.websocket import router as websocket_router

# In create_app():
app.include_router(websocket_router)
```

Update `src/api/migrations.py` to include android_messages table:

```python
def run_all_migrations():
    """Run all database migrations"""
    create_users_table()
    create_sessions_table()
    create_android_messages_table()
```

Test WebSocket connection manually:

```bash
# Start server
python3 src/api/main.py

# Test with wscat (install: npm install -g wscat)
# Get token first via POST /api/v1/auth/login
wscat -c "ws://localhost:8000/api/v1/chat/ws?token=YOUR_ACCESS_TOKEN"

# Send message:
{"event": "message", "data": {"content": "Hey"}}

# Expect response with Demi's message + emotion_state
```
  </action>
  <verify>
1. Router inclusion: `grep "websocket_router" src/api/__init__.py`
2. Migration updated: `grep "create_android_messages_table" src/api/migrations.py`
3. Tables exist: `sqlite3 ~/.demi/demi.db ".schema android_messages"`
4. WebSocket test: Connect with wscat and send message
  </verify>
  <done>
- WebSocket router included in FastAPI app
- android_messages table created on startup
- WebSocket endpoint accessible at ws://host:port/api/v1/chat/ws?token=...
- Bidirectional real-time messaging working
- Emotion state included in responses
- Read receipts tracking
- Ready for Plan 03 (autonomy, check-ins, guilt-trip messages)
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **WebSocket Connection:** Connect to ws://localhost:8000/api/v1/chat/ws?token=... → accepts connection
2. **Send Message:** `{"event": "message", "data": {"content": "Hi"}}` → Demi responds via WebSocket with emotion_state
3. **Typing Indicator:** Server sends `{"event": "typing", "data": {"is_typing": true}}` while generating
4. **History:** On connection, server sends last 7 days of messages
5. **Read Receipts:** Send `{"event": "read_receipt", "data": {"message_id": "..."}}` → message marked read in DB
6. **Persistence:** Disconnect and reconnect → history reloaded

All 3 tasks must complete before Plan 03 starts.
</verification>

<success_criteria>
- WebSocket endpoint working (/api/v1/chat/ws)
- Bidirectional real-time messaging
- Messages route through Conductor LLM pipeline
- Emotion state included in every Demi response
- Last 7 days of history loaded on connection
- Read receipts (status: sent/delivered/read)
- Typing indicator shows "Demi is thinking..."
- Message persistence in android_messages table
- ConnectionManager tracks active connections
- No import errors, all syntax valid
</success_criteria>

<output>
After completion, create `.planning/phases/06-android-integration/06-02-SUMMARY.md`
</output>
