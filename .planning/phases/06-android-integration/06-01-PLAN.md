---
phase: 06-android-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/api/__init__.py
  - src/api/auth.py
  - src/api/models.py
  - src/api/migrations.py
autonomous: true
user_setup:
  - service: android_api
    why: "FastAPI backend for Android client messaging"
    env_vars:
      - name: JWT_SECRET_KEY
        source: "Generate: openssl rand -base64 32"
      - name: JWT_REFRESH_SECRET_KEY
        source: "Generate: openssl rand -base64 32 (different from access)"
      - name: ANDROID_API_HOST
        source: "Set to 0.0.0.0 (listen all interfaces)"
      - name: ANDROID_API_PORT
        source: "Set to 8000 (default, change if needed)"

must_haves:
  truths:
    - "POST /api/v1/auth/login authenticates existing users and returns access + refresh tokens"
    - "POST /api/v1/auth/refresh exchanges refresh token for new access token"
    - "GET /api/v1/auth/sessions lists active sessions across devices"
    - "DELETE /api/v1/auth/sessions/{id} revokes specific session/device"
    - "Refresh tokens stored in Android keystore for persistent login (7-day expiry)"
  artifacts:
    - path: "src/api/auth.py"
      provides: "User authentication and session management endpoints"
      exports: ["router", "create_access_token", "create_refresh_token", "verify_token"]
      min_lines: 300
    - path: "src/api/models.py"
      provides: "User, Session, and auth request/response schemas"
      exports: ["User", "Session", "LoginRequest", "TokenResponse", "SessionResponse"]
      min_lines: 150
  key_links:
    - from: "src/api/auth.py"
      to: "passlib.context"
      via: "bcrypt password hashing"
      pattern: "pwd_context\\.hash|verify"
    - from: "src/api/auth.py"
      to: "jwt"
      via: "token creation/verification"
      pattern: "jwt\\.encode|jwt\\.decode"
    - from: "src/api/auth.py"
      to: "sessions table"
      via: "database queries for active sessions"
      pattern: "SELECT.*FROM sessions"

---

<objective>
Establish FastAPI backend foundation with user authentication (existing account login only), refresh token flow for persistent sessions, multi-device support with session management, and brute-force protection. This is the gateway for Android clients to authenticate and maintain persistent login across app restarts.

Purpose: Android clients need secure, persistent authentication with refresh tokens stored in Android keystore. Multi-device support allows same account on phone + tablet simultaneously. Session management lets users revoke devices remotely.

Output: Login endpoint, refresh token endpoint, session list/revoke endpoints, users and sessions tables, JWT token management with 7-day refresh tokens.
</objective>

<execution_context>
@/home/mystiatech/.claude/get-shit-done/workflows/execute-plan.md
@/home/mystiatech/projects/Demi/.planning/phases/06-android-integration/06-DISCOVERY.md
@/home/mystiatech/projects/Demi/.planning/phases/06-android-integration/06-CONTEXT.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/PROJECT.md
@src/core/database.py
@src/core/config.py
@src/core/logger.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create User and Session models with authentication utilities</name>
  <files>src/api/models.py, src/api/migrations.py</files>
  <action>
Create `src/api/models.py`:

```python
from dataclasses import dataclass, field
from datetime import datetime, UTC
from typing import Optional
from pydantic import BaseModel, EmailStr
import uuid

# Database models
@dataclass
class User:
    """User account (existing account only - no in-app registration)"""
    user_id: str  # UUID
    email: str
    username: str
    password_hash: str  # bcrypt hash
    created_at: datetime = field(default_factory=lambda: datetime.now(UTC))
    last_login: Optional[datetime] = None
    is_active: bool = True
    failed_login_attempts: int = 0
    locked_until: Optional[datetime] = None

    def to_dict(self) -> dict:
        return {
            "user_id": self.user_id,
            "email": self.email,
            "username": self.username,
            "created_at": self.created_at.isoformat(),
            "is_active": self.is_active,
            "locked_until": self.locked_until.isoformat() if self.locked_until else None
        }

@dataclass
class Session:
    """Active session for multi-device support"""
    session_id: str  # UUID
    user_id: str  # FK to User
    device_name: str  # "Pixel 7", "Galaxy Tab", etc.
    device_fingerprint: str  # Unique device ID
    refresh_token_hash: str  # bcrypt hash of refresh token
    created_at: datetime = field(default_factory=lambda: datetime.now(UTC))
    last_activity: datetime = field(default_factory=lambda: datetime.now(UTC))
    expires_at: datetime = field(default_factory=lambda: datetime.now(UTC))
    is_active: bool = True

    def to_dict(self) -> dict:
        return {
            "session_id": self.session_id,
            "user_id": self.user_id,
            "device_name": self.device_name,
            "created_at": self.created_at.isoformat(),
            "last_activity": self.last_activity.isoformat(),
            "expires_at": self.expires_at.isoformat(),
            "is_active": self.is_active
        }

# Pydantic request/response schemas
class LoginRequest(BaseModel):
    """User login request (existing account only)"""
    email: EmailStr
    password: str
    device_name: str = "Android Device"
    device_fingerprint: Optional[str] = None

    class Config:
        json_schema_extra = {
            "example": {
                "email": "user@example.com",
                "password": "MyPassword123!",
                "device_name": "Pixel 7",
                "device_fingerprint": "android-uuid-1234"
            }
        }

class RefreshTokenRequest(BaseModel):
    """Refresh access token"""
    refresh_token: str

    class Config:
        json_schema_extra = {
            "example": {"refresh_token": "eyJhbGc..."}
        }

class TokenResponse(BaseModel):
    """Authentication response with access + refresh tokens"""
    access_token: str
    refresh_token: str
    token_type: str
    expires_in: int  # seconds (access token)
    refresh_expires_in: int  # seconds (refresh token)
    user_id: str
    email: str
    session_id: str

    class Config:
        json_schema_extra = {
            "example": {
                "access_token": "eyJhbGc...",
                "refresh_token": "eyJhbGc...",
                "token_type": "bearer",
                "expires_in": 1800,
                "refresh_expires_in": 604800,
                "user_id": "uuid-1234",
                "email": "user@example.com",
                "session_id": "session-uuid-5678"
            }
        }

class SessionResponse(BaseModel):
    """Active session details"""
    session_id: str
    device_name: str
    created_at: str
    last_activity: str
    expires_at: str
    is_active: bool
    is_current: bool  # True if this is the session making the request

    class Config:
        json_schema_extra = {
            "example": {
                "session_id": "session-1234",
                "device_name": "Pixel 7",
                "created_at": "2026-02-01T10:00:00Z",
                "last_activity": "2026-02-01T15:30:00Z",
                "expires_at": "2026-02-08T10:00:00Z",
                "is_active": True,
                "is_current": True
            }
        }

class SessionListResponse(BaseModel):
    """List of all active sessions"""
    sessions: list[SessionResponse]
    total_count: int

class UserResponse(BaseModel):
    """User profile response"""
    user_id: str
    email: str
    username: str
    created_at: str
    is_active: bool
```

Create `src/api/migrations.py`:

```python
import sqlite3
import os
from src.core.logger import DemiLogger

logger = DemiLogger()

def get_db_path() -> str:
    """Get database path from environment"""
    db_url = os.getenv("DATABASE_URL", "sqlite:////home/user/.demi/demi.db")
    return db_url.replace("sqlite:///", "")

def create_users_table():
    """Create users table if not exists"""
    db_path = get_db_path()
    with sqlite3.connect(db_path) as conn:
        conn.execute("""
        CREATE TABLE IF NOT EXISTS users (
            user_id TEXT PRIMARY KEY,
            email TEXT UNIQUE NOT NULL,
            username TEXT NOT NULL,
            password_hash TEXT NOT NULL,
            created_at TIMESTAMP NOT NULL,
            last_login TIMESTAMP,
            is_active BOOLEAN DEFAULT 1,
            failed_login_attempts INTEGER DEFAULT 0,
            locked_until TIMESTAMP
        )
        """)
        # Index for login lookups
        conn.execute("""
        CREATE INDEX IF NOT EXISTS idx_users_email
        ON users(email)
        """)
        conn.commit()
        logger.info("Users table created/verified")

def create_sessions_table():
    """Create sessions table for multi-device support"""
    db_path = get_db_path()
    with sqlite3.connect(db_path) as conn:
        conn.execute("""
        CREATE TABLE IF NOT EXISTS sessions (
            session_id TEXT PRIMARY KEY,
            user_id TEXT NOT NULL,
            device_name TEXT NOT NULL,
            device_fingerprint TEXT,
            refresh_token_hash TEXT NOT NULL,
            created_at TIMESTAMP NOT NULL,
            last_activity TIMESTAMP NOT NULL,
            expires_at TIMESTAMP NOT NULL,
            is_active BOOLEAN DEFAULT 1,
            FOREIGN KEY (user_id) REFERENCES users(user_id) ON DELETE CASCADE
        )
        """)
        # Index for session lookups
        conn.execute("""
        CREATE INDEX IF NOT EXISTS idx_sessions_user
        ON sessions(user_id, is_active, expires_at)
        """)
        conn.commit()
        logger.info("Sessions table created/verified")

def run_all_migrations():
    """Run all database migrations"""
    create_users_table()
    create_sessions_table()
```
  </action>
  <verify>
1. Files created: `ls src/api/models.py src/api/migrations.py`
2. Import check: `python3 -c "from src.api.models import User, Session, LoginRequest, TokenResponse, SessionResponse; print('Models OK')"`
3. Migration check: `python3 -c "from src.api.migrations import run_all_migrations; run_all_migrations(); print('Migrations OK')"`
4. Tables exist: `sqlite3 ~/.demi/demi.db ".schema users"` and `sqlite3 ~/.demi/demi.db ".schema sessions"`
  </verify>
  <done>
- User dataclass created with brute-force protection fields (failed_login_attempts, locked_until)
- Session dataclass created for multi-device tracking
- LoginRequest schema (email, password, device_name, device_fingerprint)
- RefreshTokenRequest schema (refresh_token)
- TokenResponse schema (access_token, refresh_token, expires_in, session_id)
- SessionResponse and SessionListResponse schemas
- Users table migration (email unique, failed login tracking)
- Sessions table migration (user_id FK, device tracking, expiry)
- Indexes for efficient lookups
- Ready for Task 2 (authentication endpoints)
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement login, refresh, and session management endpoints</name>
  <files>src/api/auth.py</files>
  <action>
Create `src/api/auth.py`:

```python
from fastapi import APIRouter, HTTPException, status, Depends
from fastapi.security import HTTPBearer, HTTPAuthCredentials
from datetime import datetime, timedelta, UTC
import jwt
import os
import uuid
import sqlite3
import json
from typing import Optional
from passlib.context import CryptContext

from src.api.models import (
    User, Session, LoginRequest, RefreshTokenRequest,
    TokenResponse, SessionResponse, SessionListResponse
)
from src.core.logger import DemiLogger

router = APIRouter(prefix="/api/v1/auth", tags=["auth"])
security = HTTPBearer()
logger = DemiLogger()

# Configuration
SECRET_KEY = os.getenv("JWT_SECRET_KEY", "change-me-in-production")
REFRESH_SECRET_KEY = os.getenv("JWT_REFRESH_SECRET_KEY", "change-refresh-key-too")
ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_MINUTES = 30
REFRESH_TOKEN_EXPIRE_DAYS = 7
MAX_FAILED_LOGIN_ATTEMPTS = 5
LOCKOUT_DURATION_MINUTES = 15

pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

def get_db_path() -> str:
    """Get database path"""
    db_url = os.getenv("DATABASE_URL", "sqlite:////home/user/.demi/demi.db")
    return db_url.replace("sqlite:///", "")

def hash_password(password: str) -> str:
    """Hash password with bcrypt"""
    return pwd_context.hash(password)

def verify_password(plain_password: str, hashed_password: str) -> bool:
    """Verify password against hash"""
    return pwd_context.verify(plain_password, hashed_password)

def create_access_token(user_id: str, email: str, session_id: str) -> str:
    """Create short-lived access token (30 minutes)"""
    exp = datetime.now(UTC) + timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    payload = {
        "user_id": user_id,
        "email": email,
        "session_id": session_id,
        "type": "access",
        "exp": int(exp.timestamp()),
        "iat": int(datetime.now(UTC).timestamp())
    }
    token = jwt.encode(payload, SECRET_KEY, algorithm=ALGORITHM)
    return token

def create_refresh_token(user_id: str, session_id: str) -> str:
    """Create long-lived refresh token (7 days)"""
    exp = datetime.now(UTC) + timedelta(days=REFRESH_TOKEN_EXPIRE_DAYS)
    payload = {
        "user_id": user_id,
        "session_id": session_id,
        "type": "refresh",
        "exp": int(exp.timestamp()),
        "iat": int(datetime.now(UTC).timestamp())
    }
    token = jwt.encode(payload, REFRESH_SECRET_KEY, algorithm=ALGORITHM)
    return token

def verify_token(token: str, token_type: str = "access") -> dict:
    """Verify JWT token, return payload"""
    try:
        secret = SECRET_KEY if token_type == "access" else REFRESH_SECRET_KEY
        payload = jwt.decode(token, secret, algorithms=[ALGORITHM])

        # Verify token type matches
        if payload.get("type") != token_type:
            raise HTTPException(status_code=401, detail=f"Invalid {token_type} token")

        return payload
    except jwt.ExpiredSignatureError:
        raise HTTPException(status_code=401, detail="Token expired")
    except jwt.InvalidTokenError:
        raise HTTPException(status_code=401, detail="Invalid token")

def get_current_user(credentials: HTTPAuthCredentials = Depends(security)) -> dict:
    """Dependency to get current user from access token"""
    token = credentials.credentials
    return verify_token(token, token_type="access")

async def get_user_from_db(email: str) -> Optional[User]:
    """Query user by email"""
    db_path = get_db_path()
    with sqlite3.connect(db_path) as conn:
        conn.row_factory = sqlite3.Row
        row = conn.execute(
            "SELECT * FROM users WHERE email = ?", (email,)
        ).fetchone()

    if not row:
        return None

    return User(
        user_id=row["user_id"],
        email=row["email"],
        username=row["username"],
        password_hash=row["password_hash"],
        created_at=datetime.fromisoformat(row["created_at"]),
        last_login=datetime.fromisoformat(row["last_login"]) if row["last_login"] else None,
        is_active=bool(row["is_active"]),
        failed_login_attempts=row["failed_login_attempts"],
        locked_until=datetime.fromisoformat(row["locked_until"]) if row["locked_until"] else None
    )

async def create_session(
    user_id: str,
    device_name: str,
    device_fingerprint: Optional[str],
    refresh_token: str
) -> Session:
    """Create new session for device"""
    session_id = str(uuid.uuid4())
    refresh_token_hash = hash_password(refresh_token)
    expires_at = datetime.now(UTC) + timedelta(days=REFRESH_TOKEN_EXPIRE_DAYS)

    session = Session(
        session_id=session_id,
        user_id=user_id,
        device_name=device_name,
        device_fingerprint=device_fingerprint or "",
        refresh_token_hash=refresh_token_hash,
        created_at=datetime.now(UTC),
        last_activity=datetime.now(UTC),
        expires_at=expires_at,
        is_active=True
    )

    db_path = get_db_path()
    with sqlite3.connect(db_path) as conn:
        conn.execute("""
        INSERT INTO sessions
        (session_id, user_id, device_name, device_fingerprint, refresh_token_hash,
         created_at, last_activity, expires_at, is_active)
        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
        """, (
            session.session_id,
            session.user_id,
            session.device_name,
            session.device_fingerprint,
            session.refresh_token_hash,
            session.created_at.isoformat(),
            session.last_activity.isoformat(),
            session.expires_at.isoformat(),
            session.is_active
        ))
        conn.commit()

    logger.info(f"Session created for user {user_id}, device: {device_name}")
    return session

@router.post("/login", response_model=TokenResponse)
async def login(req: LoginRequest):
    """
    Login with existing account credentials.
    Returns access token (30 min) and refresh token (7 days).
    """

    # Get user from DB
    user = await get_user_from_db(req.email)

    if not user:
        raise HTTPException(
            status_code=401,
            detail="Invalid email or password"
        )

    # Check if account is locked
    if user.locked_until and user.locked_until > datetime.now(UTC):
        raise HTTPException(
            status_code=403,
            detail=f"Account locked due to too many failed attempts. Try again after {user.locked_until.isoformat()}"
        )

    # Verify password
    if not verify_password(req.password, user.password_hash):
        # Increment failed attempts
        db_path = get_db_path()
        with sqlite3.connect(db_path) as conn:
            new_failed_attempts = user.failed_login_attempts + 1

            # Lock account after 5 failed attempts
            locked_until = None
            if new_failed_attempts >= MAX_FAILED_LOGIN_ATTEMPTS:
                locked_until = datetime.now(UTC) + timedelta(minutes=LOCKOUT_DURATION_MINUTES)
                logger.warning(f"Account locked: {user.email} (5 failed attempts)")

            conn.execute("""
            UPDATE users
            SET failed_login_attempts = ?, locked_until = ?
            WHERE user_id = ?
            """, (new_failed_attempts, locked_until.isoformat() if locked_until else None, user.user_id))
            conn.commit()

        raise HTTPException(
            status_code=401,
            detail="Invalid email or password"
        )

    if not user.is_active:
        raise HTTPException(status_code=403, detail="Account disabled")

    # Reset failed login attempts on successful login
    db_path = get_db_path()
    with sqlite3.connect(db_path) as conn:
        conn.execute("""
        UPDATE users
        SET last_login = ?, failed_login_attempts = 0, locked_until = NULL
        WHERE user_id = ?
        """, (datetime.now(UTC).isoformat(), user.user_id))
        conn.commit()

    # Create session
    refresh_token = create_refresh_token(user.user_id, "temp-session-id")
    session = await create_session(
        user_id=user.user_id,
        device_name=req.device_name,
        device_fingerprint=req.device_fingerprint,
        refresh_token=refresh_token
    )

    # Issue tokens
    access_token = create_access_token(user.user_id, user.email, session.session_id)
    refresh_token = create_refresh_token(user.user_id, session.session_id)

    logger.info(f"User logged in: {user.email}, session: {session.session_id}")

    return TokenResponse(
        access_token=access_token,
        refresh_token=refresh_token,
        token_type="bearer",
        expires_in=ACCESS_TOKEN_EXPIRE_MINUTES * 60,
        refresh_expires_in=REFRESH_TOKEN_EXPIRE_DAYS * 86400,
        user_id=user.user_id,
        email=user.email,
        session_id=session.session_id
    )

@router.post("/refresh", response_model=TokenResponse)
async def refresh_access_token(req: RefreshTokenRequest):
    """
    Exchange refresh token for new access token.
    Refresh token must be valid and session must be active.
    """

    # Verify refresh token
    payload = verify_token(req.refresh_token, token_type="refresh")
    session_id = payload.get("session_id")
    user_id = payload.get("user_id")

    # Get session from DB
    db_path = get_db_path()
    with sqlite3.connect(db_path) as conn:
        conn.row_factory = sqlite3.Row
        row = conn.execute(
            "SELECT * FROM sessions WHERE session_id = ? AND user_id = ?",
            (session_id, user_id)
        ).fetchone()

    if not row or not row["is_active"]:
        raise HTTPException(status_code=401, detail="Session invalid or expired")

    # Check expiry
    expires_at = datetime.fromisoformat(row["expires_at"])
    if expires_at < datetime.now(UTC):
        raise HTTPException(status_code=401, detail="Session expired")

    # Update last activity
    with sqlite3.connect(db_path) as conn:
        conn.execute(
            "UPDATE sessions SET last_activity = ? WHERE session_id = ?",
            (datetime.now(UTC).isoformat(), session_id)
        )
        conn.commit()

    # Get user email for access token
    user = await get_user_from_db_by_id(user_id)

    # Issue new access token
    access_token = create_access_token(user_id, user.email, session_id)

    logger.info(f"Access token refreshed for session: {session_id}")

    return TokenResponse(
        access_token=access_token,
        refresh_token=req.refresh_token,  # Return same refresh token
        token_type="bearer",
        expires_in=ACCESS_TOKEN_EXPIRE_MINUTES * 60,
        refresh_expires_in=int((expires_at - datetime.now(UTC)).total_seconds()),
        user_id=user_id,
        email=user.email,
        session_id=session_id
    )

@router.get("/sessions", response_model=SessionListResponse)
async def list_sessions(current_user: dict = Depends(get_current_user)):
    """
    List all active sessions for current user across all devices.
    Shows device name, created time, last activity, expiry.
    """
    user_id = current_user["user_id"]
    current_session_id = current_user["session_id"]

    db_path = get_db_path()
    with sqlite3.connect(db_path) as conn:
        conn.row_factory = sqlite3.Row
        rows = conn.execute("""
        SELECT * FROM sessions
        WHERE user_id = ? AND is_active = 1 AND expires_at > ?
        ORDER BY last_activity DESC
        """, (user_id, datetime.now(UTC).isoformat())).fetchall()

    sessions = []
    for row in rows:
        sessions.append(SessionResponse(
            session_id=row["session_id"],
            device_name=row["device_name"],
            created_at=row["created_at"],
            last_activity=row["last_activity"],
            expires_at=row["expires_at"],
            is_active=bool(row["is_active"]),
            is_current=(row["session_id"] == current_session_id)
        ))

    return SessionListResponse(
        sessions=sessions,
        total_count=len(sessions)
    )

@router.delete("/sessions/{session_id}")
async def revoke_session(session_id: str, current_user: dict = Depends(get_current_user)):
    """
    Revoke specific session/device (multi-device support).
    User can remotely logout from other devices.
    """
    user_id = current_user["user_id"]

    db_path = get_db_path()
    with sqlite3.connect(db_path) as conn:
        # Verify session belongs to user
        row = conn.execute(
            "SELECT user_id FROM sessions WHERE session_id = ?",
            (session_id,)
        ).fetchone()

        if not row or row[0] != user_id:
            raise HTTPException(status_code=404, detail="Session not found")

        # Revoke session
        conn.execute(
            "UPDATE sessions SET is_active = 0 WHERE session_id = ?",
            (session_id,)
        )
        conn.commit()

    logger.info(f"Session revoked: {session_id} by user {user_id}")

    return {"message": "Session revoked successfully"}

async def get_user_from_db_by_id(user_id: str) -> User:
    """Query user by ID"""
    db_path = get_db_path()
    with sqlite3.connect(db_path) as conn:
        conn.row_factory = sqlite3.Row
        row = conn.execute(
            "SELECT * FROM users WHERE user_id = ?", (user_id,)
        ).fetchone()

    if not row:
        raise HTTPException(status_code=404, detail="User not found")

    return User(
        user_id=row["user_id"],
        email=row["email"],
        username=row["username"],
        password_hash=row["password_hash"],
        created_at=datetime.fromisoformat(row["created_at"]),
        last_login=datetime.fromisoformat(row["last_login"]) if row["last_login"] else None,
        is_active=bool(row["is_active"]),
        failed_login_attempts=row["failed_login_attempts"],
        locked_until=datetime.fromisoformat(row["locked_until"]) if row["locked_until"] else None
    )
```
  </action>
  <verify>
1. Syntax check: `python3 -m py_compile src/api/auth.py`
2. Import check: `python3 -c "from src.api.auth import router, create_access_token, create_refresh_token, verify_token; print('Auth module OK')"`
3. JWT token verification:
   - Create access token with create_access_token()
   - Verify with verify_token(token, "access")
   - Ensure payload correct
4. Password hashing:
   - Hash a password
   - Verify with correct password (True)
   - Verify with wrong password (False)
  </verify>
  <done>
- Login endpoint created (POST /api/v1/auth/login)
- Refresh endpoint created (POST /api/v1/auth/refresh)
- Session list endpoint (GET /api/v1/auth/sessions)
- Session revoke endpoint (DELETE /api/v1/auth/sessions/{id})
- JWT access token (30-minute expiry)
- JWT refresh token (7-day expiry)
- Multi-device session tracking
- Brute-force protection (5 failed attempts → 15-minute lockout)
- Password validation (bcrypt)
- Users and sessions tables ready
- Ready for Task 3 (FastAPI app wiring)
  </done>
</task>

<task type="auto">
  <name>Task 3: Wire authentication into FastAPI app and create startup script</name>
  <files>src/api/__init__.py, src/api/main.py</files>
  <action>
Create `src/api/__init__.py`:

```python
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from src.api.auth import router as auth_router
from src.api.migrations import run_all_migrations
from src.core.logger import DemiLogger

logger = DemiLogger()

def create_app() -> FastAPI:
    """Create FastAPI application"""
    app = FastAPI(
        title="Demi Android API",
        version="1.0.0",
        description="API for Android client communication with Demi"
    )

    # Add CORS middleware (allow Android client requests)
    app.add_middleware(
        CORSMiddleware,
        allow_origins=["*"],  # Mobile clients from any origin
        allow_credentials=True,
        allow_methods=["*"],
        allow_headers=["*"],
    )

    # Initialize database
    @app.on_event("startup")
    async def startup():
        run_all_migrations()
        logger.info("FastAPI started, database migrations complete")

    # Include auth router
    app.include_router(auth_router)

    # Health check
    @app.get("/api/v1/status")
    async def status():
        return {
            "status": "ok",
            "service": "demi-android-api",
            "version": "1.0.0"
        }

    return app

# Create app instance for deployment
app = create_app()
```

Create `src/api/main.py`:

```python
import uvicorn
import os
from src.api import create_app

if __name__ == "__main__":
    app = create_app()

    host = os.getenv("ANDROID_API_HOST", "0.0.0.0")
    port = int(os.getenv("ANDROID_API_PORT", "8000"))

    print(f"Starting Demi Android API on {host}:{port}")
    print("Endpoints:")
    print("  POST /api/v1/auth/login")
    print("  POST /api/v1/auth/refresh")
    print("  GET  /api/v1/auth/sessions")
    print("  DELETE /api/v1/auth/sessions/{id}")
    print("  GET  /api/v1/status")

    uvicorn.run(
        app,
        host=host,
        port=port,
        log_level="info"
    )
```

Create `.env.example` in project root:

```bash
# JWT Authentication
JWT_SECRET_KEY=generate-with-openssl-rand-base64-32
JWT_REFRESH_SECRET_KEY=generate-different-from-access-key

# API Server
ANDROID_API_HOST=0.0.0.0
ANDROID_API_PORT=8000

# Database
DATABASE_URL=sqlite:////home/user/.demi/demi.db
```
  </action>
  <verify>
1. App creation: `python3 -c "from src.api import create_app; app = create_app(); print('App created OK')"`
2. Router inclusion: Verify auth_router included via app.include_router()
3. CORS config: Check CORSMiddleware configured
4. Startup hook: Verify on_event("startup") registered
5. .env.example: Verify file created with correct variables
  </verify>
  <done>
- FastAPI app created with proper configuration
- Auth router included (login, refresh, sessions endpoints)
- CORS middleware added for mobile clients
- Database migrations run on startup
- Health check endpoint created
- Main script with uvicorn server
- .env.example created with JWT secrets
- Ready for execution and testing
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Login:** POST /api/v1/auth/login with valid email/password → 200 + access_token + refresh_token + session_id
2. **Invalid Password:** POST /api/v1/auth/login with wrong password → 401
3. **Brute-Force Protection:** 5 failed logins → 403 (account locked for 15 minutes)
4. **Refresh Token:** POST /api/v1/auth/refresh with valid refresh token → 200 + new access_token
5. **Session List:** GET /api/v1/auth/sessions with valid access token → 200 + array of active sessions
6. **Session Revoke:** DELETE /api/v1/auth/sessions/{id} → 200, session marked inactive
7. **Multi-Device:** Login from 2 different devices → both sessions active simultaneously

All 3 tasks must complete before Plan 02 starts.
</verification>

<success_criteria>
- User login endpoint working (POST /api/v1/auth/login)
- Refresh token endpoint working (POST /api/v1/auth/refresh)
- Session list endpoint working (GET /api/v1/auth/sessions)
- Session revoke endpoint working (DELETE /api/v1/auth/sessions/{id})
- Access tokens (30-minute expiry)
- Refresh tokens (7-day expiry)
- Multi-device support (multiple active sessions per user)
- Brute-force protection (5 failed attempts → lockout)
- Password hashing with bcrypt
- Users and sessions tables created
- CORS middleware enabled for mobile clients
- FastAPI app properly configured
- No import errors, all syntax valid
</success_criteria>

<output>
After completion, create `.planning/phases/06-android-integration/06-01-SUMMARY.md`
</output>
