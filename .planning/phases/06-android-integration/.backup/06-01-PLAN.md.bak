---
phase: 06-android-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/api/__init__.py
  - src/api/auth.py
  - src/api/models.py
autonomous: true
user_setup:
  - service: android_api
    why: "FastAPI backend for Android client messaging"
    env_vars:
      - name: JWT_SECRET_KEY
        source: "Generate: openssl rand -base64 32 (copy 32-character output)"
      - name: ANDROID_API_HOST
        source: "Set to 0.0.0.0 (listen all interfaces)"
      - name: ANDROID_API_PORT
        source: "Set to 8000 (or desired port)"

must_haves:
  truths:
    - "POST /api/v1/auth/register creates new user and returns JWT token"
    - "POST /api/v1/auth/login authenticates user and returns JWT token"
    - "Invalid credentials return 401 Unauthorized"
    - "JWT tokens verify correctly with HS256 algorithm"
  artifacts:
    - path: "src/api/auth.py"
      provides: "User registration and login endpoints"
      exports: ["router", "create_access_token", "verify_token"]
    - path: "src/api/models.py"
      provides: "User and registration request/response schemas"
      exports: ["User", "RegisterRequest", "LoginRequest", "TokenResponse"]
  key_links:
    - from: "src/api/auth.py"
      to: "passlib.context"
      via: "bcrypt password hashing"
      pattern: "pwd_context\\.hash|verify"
    - from: "src/api/auth.py"
      to: "jwt"
      via: "token creation/verification"
      pattern: "jwt\\.encode|jwt\\.decode"

---

<objective>
Establish FastAPI backend foundation with user authentication (registration, login, JWT tokens). This is the gateway for Android clients to create accounts and authenticate API requests.

Purpose: Android clients need secure, stateless authentication (JWT) for mobile apps. User registration creates unique identities in the system.

Output: Registration and login endpoints, user database schema, JWT token management.
</objective>

<execution_context>
@~/.opencode/get-shit-done/workflows/execute-plan.md
@.planning/phases/06-android-integration/06-DISCOVERY.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/PROJECT.md
@src/core/database.py
@src/core/config.py
@src/core/logger.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create User model and password hashing utilities</name>
  <files>src/api/models.py</files>
  <action>
Create `src/api/models.py`:

```python
from dataclasses import dataclass, field
from datetime import datetime
from typing import Optional
from pydantic import BaseModel, EmailStr
import uuid

# Database model
@dataclass
class User:
    """User account"""
    user_id: str  # UUID
    email: str
    username: str
    password_hash: str  # bcrypt hash
    created_at: datetime = field(default_factory=datetime.utcnow)
    last_login: Optional[datetime] = None
    is_active: bool = True
    
    def to_dict(self) -> dict:
        return {
            "user_id": self.user_id,
            "email": self.email,
            "username": self.username,
            "created_at": self.created_at.isoformat(),
            "is_active": self.is_active
        }

# Pydantic request/response schemas
class RegisterRequest(BaseModel):
    """User registration request"""
    email: EmailStr
    password: str  # At least 12 chars, mixed case, number
    username: Optional[str] = None
    
    class Config:
        example = {
            "email": "user@example.com",
            "password": "MyPassword123!",
            "username": "johndoe"
        }

class LoginRequest(BaseModel):
    """User login request"""
    email: EmailStr
    password: str
    
    class Config:
        example = {
            "email": "user@example.com",
            "password": "MyPassword123!"
        }

class TokenResponse(BaseModel):
    """Authentication response with token"""
    access_token: str
    token_type: str
    expires_in: int  # seconds
    user_id: str
    email: str
    
    class Config:
        example = {
            "access_token": "eyJhbGc...",
            "token_type": "bearer",
            "expires_in": 86400,
            "user_id": "uuid-1234",
            "email": "user@example.com"
        }

class UserResponse(BaseModel):
    """User profile response"""
    user_id: str
    email: str
    username: str
    created_at: str
    is_active: bool
```

Create password validation helper:

```python
# In src/api/auth.py (created in Task 2)

import re
from passlib.context import CryptContext

pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

def hash_password(password: str) -> str:
    """Hash password with bcrypt"""
    return pwd_context.hash(password)

def verify_password(plain_password: str, hashed_password: str) -> bool:
    """Verify password against hash"""
    return pwd_context.verify(plain_password, hashed_password)

def validate_password_strength(password: str) -> tuple[bool, str]:
    """
    Validate password meets requirements:
    - At least 12 characters
    - Mixed case (upper + lower)
    - At least one number
    
    Returns:
        (is_valid: bool, error_message: str)
    """
    if len(password) < 12:
        return False, "Password must be at least 12 characters"
    
    if not re.search(r"[a-z]", password) or not re.search(r"[A-Z]", password):
        return False, "Password must contain both uppercase and lowercase letters"
    
    if not re.search(r"\d", password):
        return False, "Password must contain at least one number"
    
    return True, ""

def validate_email_format(email: str) -> tuple[bool, str]:
    """Validate email format"""
    pattern = r"^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$"
    if re.match(pattern, email):
        return True, ""
    return False, "Invalid email format"
```
  </action>
  <verify>
1. File created: `ls src/api/models.py src/api/auth.py` (both should exist)
2. Import check: `python3 -c "from src.api.models import User, RegisterRequest, TokenResponse; print('Models OK')"`
3. Password validation test:
   - `validate_password_strength("short")` → False
   - `validate_password_strength("NoNumber!")` → False
   - `validate_password_strength("ValidPass123")` → True
  </verify>
  <done>
- User dataclass created with all fields (user_id, email, username, password_hash, timestamps)
- RegisterRequest schema (email, password, optional username)
- LoginRequest schema (email, password)
- TokenResponse schema (access_token, token_type, expires_in, user_id, email)
- Password hashing utilities (hash_password, verify_password)
- Password strength validation (12+ chars, mixed case, number)
- Email format validation
- Ready for Task 2 (endpoints)
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement registration and login endpoints with JWT</name>
  <files>src/api/auth.py</files>
  <action>
Create `src/api/auth.py`:

```python
from fastapi import APIRouter, HTTPException, status, Depends
from fastapi.security import HTTPBearer, HTTPAuthCredentials
from datetime import datetime, timedelta
import jwt
import os
import uuid
import sqlite3
from src.api.models import (
    User, RegisterRequest, LoginRequest, TokenResponse,
    hash_password, verify_password,
    validate_password_strength, validate_email_format
)
from src.core.logger import get_logger
from src.core.config import get_config

router = APIRouter(prefix="/api/v1/auth", tags=["auth"])
security = HTTPBearer()
logger = get_logger()

# Configuration
SECRET_KEY = os.getenv("JWT_SECRET_KEY", "change-me-in-production")
ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_HOURS = 24
DB_PATH = os.getenv("DATABASE_URL", "~/.demi/demi.db").replace("sqlite:///", "")

def create_access_token(user_id: str, email: str) -> str:
    """Create JWT token"""
    exp = datetime.utcnow() + timedelta(hours=ACCESS_TOKEN_EXPIRE_HOURS)
    payload = {
        "user_id": user_id,
        "email": email,
        "exp": int(exp.timestamp()),
        "iat": int(datetime.utcnow().timestamp())
    }
    token = jwt.encode(payload, SECRET_KEY, algorithm=ALGORITHM)
    return token

def verify_token(token: str) -> dict:
    """Verify JWT token, return payload"""
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        return payload
    except jwt.ExpiredSignatureError:
        raise HTTPException(status_code=401, detail="Token expired")
    except jwt.InvalidTokenError:
        raise HTTPException(status_code=401, detail="Invalid token")

def get_current_user(credentials: HTTPAuthCredentials = Depends(security)) -> dict:
    """Dependency to get current user from JWT token"""
    token = credentials.credentials
    return verify_token(token)

async def get_user_from_db(email: str) -> Optional[User]:
    """Query user by email"""
    with sqlite3.connect(DB_PATH) as conn:
        conn.row_factory = sqlite3.Row
        row = conn.execute(
            "SELECT * FROM users WHERE email = ?", (email,)
        ).fetchone()
    
    if not row:
        return None
    
    return User(
        user_id=row["user_id"],
        email=row["email"],
        username=row["username"],
        password_hash=row["password_hash"],
        created_at=datetime.fromisoformat(row["created_at"]),
        last_login=datetime.fromisoformat(row["last_login"]) if row["last_login"] else None,
        is_active=bool(row["is_active"])
    )

async def create_user_in_db(user: User) -> None:
    """Save user to database"""
    with sqlite3.connect(DB_PATH) as conn:
        conn.execute("""
        INSERT INTO users 
        (user_id, email, username, password_hash, created_at, is_active)
        VALUES (?, ?, ?, ?, ?, ?)
        """, (
            user.user_id,
            user.email,
            user.username,
            user.password_hash,
            user.created_at.isoformat(),
            user.is_active
        ))
        conn.commit()

@router.post("/register", response_model=TokenResponse)
async def register(req: RegisterRequest):
    """Register new user account"""
    
    # Validate password
    is_valid, error_msg = validate_password_strength(req.password)
    if not is_valid:
        raise HTTPException(status_code=400, detail=error_msg)
    
    # Validate email
    is_valid, error_msg = validate_email_format(req.email)
    if not is_valid:
        raise HTTPException(status_code=400, detail=error_msg)
    
    # Check if email already exists
    existing_user = await get_user_from_db(req.email)
    if existing_user:
        raise HTTPException(
            status_code=409,
            detail="Email already registered"
        )
    
    # Create user
    user_id = str(uuid.uuid4())
    user = User(
        user_id=user_id,
        email=req.email,
        username=req.username or req.email.split("@")[0],
        password_hash=hash_password(req.password)
    )
    
    # Save to DB
    await create_user_in_db(user)
    logger.info(f"User registered: {user.email}")
    
    # Issue token
    access_token = create_access_token(user.user_id, user.email)
    
    return TokenResponse(
        access_token=access_token,
        token_type="bearer",
        expires_in=ACCESS_TOKEN_EXPIRE_HOURS * 3600,
        user_id=user.user_id,
        email=user.email
    )

@router.post("/login", response_model=TokenResponse)
async def login(req: LoginRequest):
    """Login with email and password"""
    
    # Get user from DB
    user = await get_user_from_db(req.email)
    
    if not user or not verify_password(req.password, user.password_hash):
        raise HTTPException(
            status_code=401,
            detail="Invalid email or password"
        )
    
    if not user.is_active:
        raise HTTPException(status_code=403, detail="Account disabled")
    
    # Update last_login
    with sqlite3.connect(DB_PATH) as conn:
        conn.execute(
            "UPDATE users SET last_login = ? WHERE user_id = ?",
            (datetime.utcnow().isoformat(), user.user_id)
        )
        conn.commit()
    
    logger.info(f"User logged in: {user.email}")
    
    # Issue token
    access_token = create_access_token(user.user_id, user.email)
    
    return TokenResponse(
        access_token=access_token,
        token_type="bearer",
        expires_in=ACCESS_TOKEN_EXPIRE_HOURS * 3600,
        user_id=user.user_id,
        email=user.email
    )
```

Create database migration:

```python
# In src/api/migrations.py (new file)

import sqlite3
import os

def create_users_table():
    """Create users table if not exists"""
    db_path = os.getenv("DATABASE_URL", "~/.demi/demi.db").replace("sqlite:///", "")
    with sqlite3.connect(db_path) as conn:
        conn.execute("""
        CREATE TABLE IF NOT EXISTS users (
            user_id TEXT PRIMARY KEY,
            email TEXT UNIQUE NOT NULL,
            username TEXT NOT NULL,
            password_hash TEXT NOT NULL,
            created_at TIMESTAMP NOT NULL,
            last_login TIMESTAMP,
            is_active BOOLEAN DEFAULT 1
        )
        """)
        conn.commit()
```

Call migration on startup (in main.py):
```python
from src.api.migrations import create_users_table

@app.on_event("startup")
async def startup():
    create_users_table()
```
  </action>
  <verify>
1. Syntax check: `python3 -m py_compile src/api/auth.py`
2. JWT token verification:
   - Create token with create_access_token()
   - Verify with verify_token()
   - Ensure payload correct
3. Password hashing:
   - Hash a password
   - Verify with correct password (True)
   - Verify with wrong password (False)
  </verify>
  <done>
- Registration endpoint created (POST /api/v1/auth/register)
- Login endpoint created (POST /api/v1/auth/login)
- JWT token creation and verification working
- Password validation (strength) enforced
- Email validation enforced
- Duplicate email prevention (409 Conflict)
- Users table created in database
- Ready for Plan 02 (messaging endpoints)
  </done>
</task>

<task type="auto">
  <name>Task 3: Wire authentication into FastAPI main app</name>
  <files>src/api/__init__.py</files>
  <action>
Create `src/api/__init__.py`:

```python
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from src.api.auth import router as auth_router
from src.api.migrations import create_users_table
from src.core.logger import get_logger

logger = get_logger()

def create_app() -> FastAPI:
    """Create FastAPI application"""
    app = FastAPI(
        title="Demi Android API",
        version="1.0.0",
        description="API for Android client communication with Demi"
    )
    
    # Add CORS middleware (allow Android client requests)
    app.add_middleware(
        CORSMiddleware,
        allow_origins=["*"],  # Mobile clients from any origin
        allow_credentials=True,
        allow_methods=["*"],
        allow_headers=["*"],
    )
    
    # Initialize database
    @app.on_event("startup")
    async def startup():
        create_users_table()
        logger.info("FastAPI started, users table created")
    
    # Include auth router
    app.include_router(auth_router)
    
    # Health check
    @app.get("/api/v1/status")
    async def status():
        return {"status": "ok"}
    
    return app

# Create app instance for deployment
app = create_app()
```

Create startup script `src/api/main.py`:

```python
import uvicorn
import os
from src.api import create_app

if __name__ == "__main__":
    app = create_app()
    
    host = os.getenv("ANDROID_API_HOST", "0.0.0.0")
    port = int(os.getenv("ANDROID_API_PORT", "8000"))
    
    uvicorn.run(
        app,
        host=host,
        port=port,
        log_level="info"
    )
```
  </action>
  <verify>
1. App creation: `python3 -c "from src.api import create_app; app = create_app(); print('App created OK')"`
2. Router inclusion: Verify auth_router included via app.include_router()
3. CORS config: Check CORSMiddleware configured
4. Startup hook: Verify on_event("startup") registered
  </verify>
  <done>
- FastAPI app created with proper configuration
- Auth router included (registration, login endpoints)
- CORS middleware added for mobile clients
- Database initialization on startup
- Health check endpoint created
- Ready for execution and testing
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Registration:** POST /api/v1/auth/register with valid email/password → 200 + token
2. **Invalid Password:** POST /api/v1/auth/register with weak password → 400 with error message
3. **Duplicate Email:** POST /api/v1/auth/register twice with same email → 409 Conflict
4. **Login:** POST /api/v1/auth/login with correct credentials → 200 + token
5. **Invalid Credentials:** POST /api/v1/auth/login with wrong password → 401
6. **Token Verification:** Use returned token in Bearer header → should work
7. **Expired Token:** Manually manipulate token or wait 24 hours → 401

All 3 tasks must complete before Plan 02 starts.
</verification>

<success_criteria>
- User registration endpoint working (POST /api/v1/auth/register)
- User login endpoint working (POST /api/v1/auth/login)
- JWT tokens created and verified
- Password validation enforced (12+ chars, mixed case, number)
- Email validation enforced
- Duplicate email prevention working
- Users table created in database
- CORS middleware enabled for mobile clients
- FastAPI app properly configured
- No import errors, all syntax valid
</success_criteria>

<output>
After completion, create `.planning/phases/06-android-integration/06-01-SUMMARY.md`
</output>

---
