---
phase: 06-android-integration
plan: 03
type: execute
wave: 3
depends_on: ["06-02"]
files_modified:
  - src/api/notifications.py
  - src/api/__init__.py
autonomous: true

must_haves:
  truths:
    - "GET /api/v1/notifications/poll returns notification status (has_new_messages)"
    - "Polling endpoint suggests next poll interval to Android client"
    - "Multiple concurrent users can poll independently without interference"
    - "Android API handles 10+ concurrent requests without degradation"
  artifacts:
    - path: "src/api/notifications.py"
      provides: "Polling notification endpoint"
      exports: ["router"]
  key_links:
    - from: "src/api/notifications.py"
      to: "android_messages table"
      via: "query unread message count"
      pattern: "SELECT.*unread"

---

<objective>
Implement the notification polling system for Android clients to check for new messages from Demi. This enables near-real-time updates without pushing (polling is simpler for v1, websocket optional for v2).

Purpose: Android client needs to know when Demi has sent new messages. Polling endpoint provides lightweight status check every 30 seconds without websocket complexity.

Output: Polling endpoint with unread message counts and notification metadata.
</objective>

<execution_context>
@~/.opencode/get-shit-done/workflows/execute-plan.md
@.planning/phases/06-android-integration/06-DISCOVERY.md
</execution_context>

<context>
@.planning/phases/06-android-integration/06-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create polling notification endpoint</name>
  <files>src/api/notifications.py</files>
  <action>
Create `src/api/notifications.py`:

```python
from fastapi import APIRouter, Depends, HTTPException
from datetime import datetime
from typing import Optional
import sqlite3
import os
import json

from src.api.auth import get_current_user
from src.core.logger import get_logger

router = APIRouter(prefix="/api/v1/notifications", tags=["notifications"])
logger = get_logger()
DB_PATH = os.getenv("DATABASE_URL", "~/.demi/demi.db").replace("sqlite:///", "")

class NotificationStatus:
    """Notification status response"""
    def __init__(
        self,
        has_new_messages: bool,
        unread_count: int,
        last_message_preview: Optional[str] = None,
        last_message_time: Optional[str] = None,
        next_poll_interval_seconds: int = 30,
        server_timestamp: str = None
    ):
        self.has_new_messages = has_new_messages
        self.unread_count = unread_count
        self.last_message_preview = last_message_preview
        self.last_message_time = last_message_time
        self.next_poll_interval_seconds = next_poll_interval_seconds
        self.server_timestamp = server_timestamp or datetime.utcnow().isoformat()
    
    def to_dict(self) -> dict:
        return {
            "has_new_messages": self.has_new_messages,
            "unread_count": self.unread_count,
            "last_message_preview": self.last_message_preview[:100] if self.last_message_preview else None,
            "last_message_time": self.last_message_time,
            "next_poll_interval_seconds": self.next_poll_interval_seconds,
            "server_timestamp": self.server_timestamp
        }

@router.get("/poll")
async def poll_notifications(
    current_user: dict = Depends(get_current_user)
) -> dict:
    """
    Poll for notification status.
    
    Returns:
    - has_new_messages: bool (true if unread messages exist)
    - unread_count: int (number of unread messages)
    - last_message_preview: str (first 100 chars of latest message)
    - last_message_time: str (timestamp of latest message)
    - next_poll_interval_seconds: int (recommended interval for next poll)
    - server_timestamp: str (server time for client clock sync)
    
    Android client should:
    1. Poll every 30 seconds (or interval suggested)
    2. If has_new_messages=true, call GET /api/v1/messages/receive
    3. Mark messages as read
    4. Adjust poll interval based on activity (more active → more frequent)
    """
    user_id = current_user["user_id"]
    
    try:
        with sqlite3.connect(DB_PATH) as conn:
            conn.row_factory = sqlite3.Row
            
            # Get unread message count
            unread_row = conn.execute("""
            SELECT COUNT(*) as count FROM android_messages
            WHERE user_id = ? AND direction = 'received' AND is_read = 0
            """, (user_id,)).fetchone()
            
            unread_count = unread_row["count"] if unread_row else 0
            
            # Get latest message for preview
            latest_row = conn.execute("""
            SELECT content, created_at FROM android_messages
            WHERE user_id = ?
            ORDER BY created_at DESC
            LIMIT 1
            """, (user_id,)).fetchone()
            
            last_message_preview = None
            last_message_time = None
            if latest_row:
                last_message_preview = latest_row["content"]
                last_message_time = latest_row["created_at"]
        
        # Determine poll interval based on activity
        # If user has unread messages, suggest faster polling
        poll_interval = 15 if unread_count > 0 else 30
        
        notification = NotificationStatus(
            has_new_messages=unread_count > 0,
            unread_count=unread_count,
            last_message_preview=last_message_preview,
            last_message_time=last_message_time,
            next_poll_interval_seconds=poll_interval
        )
        
        logger.debug(f"Notification poll: {user_id}, unread={unread_count}")
        
        return notification.to_dict()
    
    except Exception as e:
        logger.error(f"Notification poll error: {e}")
        raise HTTPException(status_code=500, detail="Error checking notifications")

@router.get("/status")
async def notification_status(
    current_user: dict = Depends(get_current_user)
) -> dict:
    """
    Extended notification status with emotion indicator.
    
    Returns:
    - All fields from /poll
    - last_emotion_state: dict (emotional state of latest message)
    - demi_is_online: bool (always true for v1)
    """
    user_id = current_user["user_id"]
    
    try:
        with sqlite3.connect(DB_PATH) as conn:
            conn.row_factory = sqlite3.Row
            
            # Get latest received message with emotion state
            latest_row = conn.execute("""
            SELECT content, emotion_state, created_at FROM android_messages
            WHERE user_id = ? AND direction = 'received'
            ORDER BY created_at DESC
            LIMIT 1
            """, (user_id,)).fetchone()
            
            last_emotion_state = {}
            if latest_row and latest_row["emotion_state"]:
                last_emotion_state = json.loads(latest_row["emotion_state"])
            
            # Get unread count
            unread_row = conn.execute("""
            SELECT COUNT(*) as count FROM android_messages
            WHERE user_id = ? AND direction = 'received' AND is_read = 0
            """, (user_id,)).fetchone()
            
            unread_count = unread_row["count"] if unread_row else 0
        
        return {
            "unread_count": unread_count,
            "last_emotion_state": last_emotion_state,
            "demi_is_online": True,  # v1: always online
            "server_timestamp": datetime.utcnow().isoformat()
        }
    
    except Exception as e:
        logger.error(f"Status check error: {e}")
        raise HTTPException(status_code=500, detail="Error checking status")
```

Update `src/api/__init__.py`:

```python
# In create_app():
from src.api.notifications import router as notifications_router
app.include_router(notifications_router)
```
  </action>
  <verify>
1. File created: `ls src/api/notifications.py`
2. Syntax check: `python3 -m py_compile src/api/notifications.py`
3. Import check: `python3 -c "from src.api.notifications import router; print('OK')"`
4. Router inclusion: `grep "notifications_router" src/api/__init__.py`
  </verify>
  <done>
- GET /api/v1/notifications/poll endpoint implemented
- GET /api/v1/notifications/status endpoint implemented
- Unread message counting from database
- Message preview generation (first 100 chars)
- Adaptive polling interval (15s if unread, 30s if none)
- Emotion state included in status endpoint
- Ready for Task 2 (testing)
  </done>
</task>

<task type="auto">
  <name>Task 2: Add notification tests and load scenario</name>
  <files>src/api/notifications.py</files>
  <action>
Create `tests/test_android_notifications.py`:

```python
import pytest
from fastapi.testclient import TestClient
from src.api import create_app
import asyncio

client = TestClient(create_app())

@pytest.fixture
def auth_token():
    """Register and login to get auth token"""
    response = client.post("/api/v1/auth/register", json={
        "email": f"test-{asyncio.current_task().get_name() if asyncio.current_task() else 'default'}@example.com",
        "password": "TestPass123"
    })
    token = response.json()["access_token"]
    return f"Bearer {token}"

class TestNotifications:
    def test_poll_no_messages(self, auth_token):
        """Poll with no messages should return 0 unread"""
        response = client.get(
            "/api/v1/notifications/poll",
            headers={"Authorization": auth_token}
        )
        assert response.status_code == 200
        data = response.json()
        assert "unread_count" in data
        assert data["unread_count"] == 0
        assert data["has_new_messages"] is False
    
    def test_poll_with_unread_messages(self, auth_token):
        """Poll after sending message should show unread count"""
        # Send message
        client.post(
            "/api/v1/messages/send",
            json={"content": "Hey"},
            headers={"Authorization": auth_token}
        )
        
        # Poll should show unread (response message from Demi)
        response = client.get(
            "/api/v1/notifications/poll",
            headers={"Authorization": auth_token}
        )
        assert response.status_code == 200
        data = response.json()
        assert data["unread_count"] >= 1
        assert data["has_new_messages"] is True
    
    def test_poll_interval_with_unread(self, auth_token):
        """Poll with unread should suggest faster interval"""
        # Send message
        client.post(
            "/api/v1/messages/send",
            json={"content": "Hi"},
            headers={"Authorization": auth_token}
        )
        
        # Poll should suggest 15s interval
        response = client.get(
            "/api/v1/notifications/poll",
            headers={"Authorization": auth_token}
        )
        assert response.json()["next_poll_interval_seconds"] == 15
    
    def test_poll_interval_no_unread(self, auth_token):
        """Poll without unread should suggest normal interval"""
        response = client.get(
            "/api/v1/notifications/poll",
            headers={"Authorization": auth_token}
        )
        assert response.json()["next_poll_interval_seconds"] == 30
    
    def test_status_with_emotion(self, auth_token):
        """Status endpoint should include emotion state"""
        # Send message to trigger response
        client.post(
            "/api/v1/messages/send",
            json={"content": "How are you?"},
            headers={"Authorization": auth_token}
        )
        
        # Get status
        response = client.get(
            "/api/v1/notifications/status",
            headers={"Authorization": auth_token}
        )
        assert response.status_code == 200
        data = response.json()
        assert "last_emotion_state" in data
        assert "demi_is_online" in data
        assert data["demi_is_online"] is True
    
    def test_poll_unauthorized(self):
        """Poll without token should fail"""
        response = client.get("/api/v1/notifications/poll")
        assert response.status_code == 403

if __name__ == "__main__":
    pytest.main([__file__, "-v"])
```

Create `tests/test_android_load.py` for load testing:

```python
"""
Load test for Android API: Verify can handle concurrent users.
"""
import pytest
import asyncio
from fastapi.testclient import TestClient
from src.api import create_app
import time

client = TestClient(create_app())

def create_test_user(email: str) -> str:
    """Create user and return auth token"""
    response = client.post("/api/v1/auth/register", json={
        "email": email,
        "password": "LoadTest123"
    })
    if response.status_code == 200:
        return f"Bearer {response.json()['access_token']}"
    # User already exists
    login_response = client.post("/api/v1/auth/login", json={
        "email": email,
        "password": "LoadTest123"
    })
    return f"Bearer {login_response.json()['access_token']}"

class TestLoadScenario:
    def test_10_concurrent_users_polling(self):
        """Simulate 10 concurrent users polling"""
        num_users = 10
        tokens = [create_test_user(f"load-test-{i}@example.com") for i in range(num_users)]
        
        # Each user sends a message
        for token in tokens:
            response = client.post(
                "/api/v1/messages/send",
                json={"content": "Test message"},
                headers={"Authorization": token}
            )
            assert response.status_code == 200
        
        # Measure polling latency
        start = time.time()
        
        for token in tokens:
            response = client.get(
                "/api/v1/notifications/poll",
                headers={"Authorization": token}
            )
            assert response.status_code == 200
        
        elapsed = time.time() - start
        avg_latency = elapsed / num_users
        
        print(f"\n10 users polling: {elapsed:.2f}s total, {avg_latency*1000:.0f}ms per request")
        
        # Latency should be <100ms per request
        assert avg_latency < 0.1, f"Polling latency too high: {avg_latency*1000:.0f}ms"
    
    def test_message_throughput(self):
        """Verify message send/receive throughput"""
        token = create_test_user("throughput@example.com")
        
        start = time.time()
        for i in range(10):
            response = client.post(
                "/api/v1/messages/send",
                json={"content": f"Message {i}"},
                headers={"Authorization": token}
            )
            assert response.status_code == 200
        
        elapsed = time.time() - start
        throughput = 10 / elapsed
        
        print(f"\nMessage throughput: {throughput:.1f} messages/sec")
        
        # Should handle at least 5 msg/sec
        assert throughput >= 5, f"Throughput too low: {throughput:.1f} msg/sec"

if __name__ == "__main__":
    pytest.main([__file__, "-v", "-s"])  # -s shows print output
```

Run tests: `pytest tests/test_android_notifications.py tests/test_android_load.py -v`

Expect 6 notification tests + 2 load tests passing.
  </action>
  <verify>
1. Test files created: `ls tests/test_android_notifications.py tests/test_android_load.py`
2. Run notification tests: `pytest tests/test_android_notifications.py -v` (expect 6/6 passing)
3. Run load tests: `pytest tests/test_android_load.py -v -s` (expect 2/2 passing, check latency/throughput)
  </verify>
  <done>
- 6 notification tests created covering polling and status
- 2 load tests created for concurrent users and throughput
- All tests passing
- Latency <100ms per request verified
- Throughput ≥5 msg/sec verified
- Ready for Phase 06 completion
  </done>
</task>

<task type="auto">
  <name>Task 3: Document Android API usage and create deployment guide</name>
  <files>src/api/__init__.py</files>
  <action>
Create `docs/ANDROID_API.md`:

```markdown
# Demi Android API Guide

## Overview

Demi provides a REST API for Android clients to send messages and receive responses. All endpoints require JWT authentication.

## Quick Start

### 1. Register Account

```bash
curl -X POST http://localhost:8000/api/v1/auth/register \
  -H "Content-Type: application/json" \
  -d '{
    "email": "user@example.com",
    "password": "MyPassword123",
    "username": "myusername"
  }'
```

Response:
```json
{
  "access_token": "eyJhbGc...",
  "token_type": "bearer",
  "expires_in": 86400,
  "user_id": "uuid-1234",
  "email": "user@example.com"
}
```

### 2. Send Message

```bash
curl -X POST http://localhost:8000/api/v1/messages/send \
  -H "Authorization: Bearer YOUR_TOKEN" \
  -H "Content-Type: application/json" \
  -d '{"content": "Hey Demi, how are you?"}'
```

Response includes Demi's response with emotion state:
```json
{
  "message_id": "msg-5678",
  "content": "Doing good! What's on your mind?",
  "direction": "received",
  "emotion_state": {
    "excitement": 0.6,
    "affection": 0.4
  },
  "created_at": "2026-02-02T15:30:05Z"
}
```

### 3. Poll for Notifications

```bash
curl -X GET "http://localhost:8000/api/v1/notifications/poll" \
  -H "Authorization: Bearer YOUR_TOKEN"
```

Response:
```json
{
  "has_new_messages": true,
  "unread_count": 3,
  "last_message_preview": "Yeah, let's do it!",
  "last_message_time": "2026-02-02T15:30:05Z",
  "next_poll_interval_seconds": 15,
  "server_timestamp": "2026-02-02T15:30:10Z"
}
```

### 4. Receive All Messages (Polling)

```bash
curl -X GET "http://localhost:8000/api/v1/messages/receive" \
  -H "Authorization: Bearer YOUR_TOKEN"
```

Returns conversation history with unread counts.

## Polling Strategy (Recommended for v1)

Android app should:

1. **Poll every 30 seconds** (or interval returned by API)
   ```swift
   Timer.scheduledTimer(withTimeInterval: 30.0, repeats: true) { _ in
       pollNotifications()
   }
   ```

2. **If `has_new_messages = true`**, call `/messages/receive`
   ```swift
   if notification.has_new_messages {
       getMessages()
   }
   ```

3. **Adjust poll interval** based on response
   - If unread messages exist: poll every 15s (faster)
   - If no messages: poll every 30s (standard)

4. **Display last message preview** in notification area
   ```swift
   showNotification(
       title: "New message from Demi",
       body: notification.last_message_preview
   )
   ```

## Endpoints

| Endpoint | Method | Description |
|----------|--------|-------------|
| `/api/v1/auth/register` | POST | Register new user |
| `/api/v1/auth/login` | POST | Login with credentials |
| `/api/v1/messages/send` | POST | Send message to Demi |
| `/api/v1/messages/receive` | GET | Get messages (polling) |
| `/api/v1/messages/history` | GET | Get conversation history |
| `/api/v1/notifications/poll` | GET | Check notification status |
| `/api/v1/notifications/status` | GET | Get status with emotion |
| `/api/v1/status` | GET | Health check |

## Authentication

All endpoints (except `/auth/register` and `/auth/login`) require:

```
Authorization: Bearer <your_access_token>
```

Tokens expire after 24 hours. Login again to get a new token.

## Error Handling

| Code | Scenario | Action |
|------|----------|--------|
| 200 | Success | Process response |
| 400 | Bad request (validation error) | Check request format |
| 401 | Unauthorized (token invalid/expired) | Login again |
| 403 | Forbidden (missing token) | Include Authorization header |
| 409 | Conflict (email already registered) | Use different email |
| 500 | Server error | Retry with exponential backoff |

## Security Notes

1. **Never hardcode tokens** - Store in secure storage
2. **Never transmit token in URL** - Always use Authorization header
3. **Use HTTPS in production** - Not just HTTP
4. **Regenerate token** if compromised (re-login)
5. **Keep email + password secret** - They're login credentials

## Development

### Run API locally

```bash
export JWT_SECRET_KEY=$(openssl rand -base64 32)
export DATABASE_URL=sqlite:////home/user/.demi/demi.db
export ANDROID_API_HOST=0.0.0.0
export ANDROID_API_PORT=8000

python3 -m uvicorn src.api.main:app --reload
```

### Test with curl

See Quick Start section above.

### Test with Python

```python
import requests

# Register
resp = requests.post("http://localhost:8000/api/v1/auth/register", json={
    "email": "test@example.com",
    "password": "TestPass123"
})
token = resp.json()["access_token"]

# Send message
resp = requests.post(
    "http://localhost:8000/api/v1/messages/send",
    headers={"Authorization": f"Bearer {token}"},
    json={"content": "Hi Demi!"}
)
print(resp.json())
```

## Future Enhancements (Phase 2+)

1. **WebSocket support** for real-time messaging
2. **Refresh tokens** for extended sessions
3. **User profile endpoints** (get profile, update username)
4. **Message deletion** (soft delete for privacy)
5. **Conversation search** (search messages by content)
6. **Rich media** (image attachments, audio)
7. **Two-factor authentication** (2FA)
```

Also create `.env.example`:

```bash
# JWT Authentication
JWT_SECRET_KEY=generate-with-openssl-rand-base64-32

# API Server
ANDROID_API_HOST=0.0.0.0
ANDROID_API_PORT=8000

# Database
DATABASE_URL=sqlite:////home/user/.demi/demi.db

# Optional: Rate Limiting
RATE_LIMIT_MESSAGES_PER_MINUTE=10
RATE_LIMIT_REGISTER_PER_HOUR=5
```

Update main README with Android API section:

```markdown
## Android Integration (Phase 06)

Demi provides a REST API for Android clients to send and receive messages.

### Quick Start

1. **Start API server:**
   ```bash
   python3 -m uvicorn src.api.main:app --host 0.0.0.0 --port 8000
   ```

2. **Register from Android app:**
   ```swift
   let request = URLRequest(url: URL(string: "http://YOUR_IP:8000/api/v1/auth/register")!)
   // See docs/ANDROID_API.md for full implementation
   ```

3. **Send messages via polling:**
   - Poll `/api/v1/notifications/poll` every 30 seconds
   - If `has_new_messages = true`, call `/api/v1/messages/receive`
   - User can send messages via `/api/v1/messages/send`

Full documentation: [docs/ANDROID_API.md](docs/ANDROID_API.md)
```
  </action>
  <verify>
1. Documentation created: `ls docs/ANDROID_API.md`
2. .env.example created: `ls .env.example`
3. README updated with Android section
4. All code examples valid (curl, python, swift syntax correct)
  </verify>
  <done>
- Comprehensive Android API documentation created
- Quick start guide with examples
- Polling strategy documented
- Error handling guide
- Security notes
- Development setup instructions
- .env.example provided
- README updated with Android section
- Ready for Phase 06 completion
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Polling:** GET /api/v1/notifications/poll → returns notification status
2. **Adaptive Interval:** Unread messages → 15s interval, No messages → 30s interval
3. **Status Endpoint:** GET /api/v1/notifications/status → includes emotion_state
4. **Load Test:** 10 concurrent users polling → all succeed, latency <100ms
5. **Throughput Test:** 10 messages in sequence → throughput ≥5 msg/sec
6. **Documentation:** docs/ANDROID_API.md complete with all endpoints + examples
7. **Tests:** All 8 tests passing (6 notification + 2 load)

All 3 tasks must complete before Phase 06 complete.
</verification>

<success_criteria>
- GET /api/v1/notifications/poll endpoint working
- GET /api/v1/notifications/status endpoint working
- Adaptive polling interval (15s with unread, 30s without)
- Emotion state included in responses
- Message preview generation
- Load test: 10 concurrent users, latency <100ms
- Throughput test: ≥5 messages/sec
- Complete API documentation
- Security notes provided
- Examples for curl, Python, Swift
- 8 tests created, all passing
- Phase 06 Android Integration complete ✅
</success_criteria>

<output>
After completion, create `.planning/phases/06-android-integration/06-03-SUMMARY.md`

Also update `.planning/ROADMAP.md`:
- Phase 06 completion: 3/3 plans complete
- Update phase status from "Pending" to "Complete ✅"
</output>

---
