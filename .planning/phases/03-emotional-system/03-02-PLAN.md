---
phase: 03-emotional-system
plan: 03-02
type: core
wave: 2
depends_on: ['03-01']
files_modified:
  - src/emotion/decay.py
  - src/emotion/interactions.py
  - tests/test_emotion_decay.py
  - tests/test_emotion_interactions.py
autonomous: true
must_haves:
  - DecaySystem class with background tick logic (5-minute intervals)
  - Emotion-specific decay rates (loneliness slow, excitement fast, others variable)
  - Idle effects that build loneliness and crash excitement continuously
  - InteractionHandler class mapping events to emotional deltas
  - Momentum amplification system (high momentum + delta = stronger effect)
  - Unit tests validating decay curves, interaction effects, offline recovery simulation
---

# Plan 03-02: Decay Mechanics & Interaction System

**Goal:** Build the systems that change Demi's emotions over timeâ€”continuous decay and event-triggered interactions.

**Duration:** ~2 hours

**Scope:** Implement two complementary systems: (1) automatic emotion decay on a 5-minute tick, and (2) event handlers that trigger emotional changes when things happen (messages, errors, code updates).

---

## Success Criteria

1. **DecaySystem** runs independent ticks every 5 minutes, applying emotion-specific decay rates
2. **Decay curves** are emotion-specific: loneliness decays slow (inertia), excitement decays fast, others variable
3. **Idle effects** continuously drive loneliness up (+0.01/min) and excitement down (-0.02/min) when no interaction
4. **InteractionHandler** maps 8 event types to precise emotional deltas (positive, negative, code update, error, etc.)
5. **Momentum amplification** causes high-momentum emotions to change more intensely
6. **Offline recovery** simulates emotion decay during downtime (needed for persistence)
7. **Tests** (15+) validate all decay curves, interaction mappings, momentum effects, and offline scenarios

---

## Task 1: Create src/emotion/decay.py with DecaySystem

**File:** `src/emotion/decay.py`

Create the decay mechanics engine:

```python
# src/emotion/decay.py
import asyncio
from datetime import datetime, timedelta
from typing import Dict, Optional, Callable
import math
from src.emotion.models import EmotionalState


class DecaySystem:
    """
    Background system that applies continuous emotional decay.
    Runs on 5-minute ticks (configurable).
    Different emotions decay at different rates.
    """
    
    def __init__(self, tick_interval_seconds: int = 300):
        """
        Initialize decay system.
        
        Args:
            tick_interval_seconds: How often to apply decay (default 300 = 5 min)
        """
        self.tick_interval = tick_interval_seconds
        self.is_running = False
        self._task = None
        self.last_tick = datetime.utcnow()
        
        # Decay rates per emotion (percentage per 5-minute tick)
        # These are tuned based on research (CONTEXT.md)
        self.base_decay_rates = {
            'loneliness': 0.02,      # Slow decay (inertia, lingers)
            'excitement': 0.06,      # Fast decay (fleeting emotion)
            'frustration': 0.04,     # Medium decay
            'jealousy': 0.03,        # Slow-medium decay
            'vulnerability': 0.08,   # Very fast (temporary state)
            'confidence': 0.03,      # Slow-medium decay
            'curiosity': 0.05,       # Medium-fast decay
            'affection': 0.04,       # Medium decay
            'defensiveness': 0.05,   # Medium-fast decay
        }
        
        # Idle effects: applied every tick when no interaction recently
        # (tracked by calling code; DecaySystem just applies them)
        self.idle_effects = {
            'loneliness': 0.01,      # +0.01 per tick (~1% per 5 min)
            'excitement': -0.02,     # -0.02 per tick
            'affection': -0.015,     # Slight decay on warmth
            'confidence': -0.01,     # Slight decay on self-assurance
        }
        
        # Callbacks for testing
        self.on_decay_applied: Optional[Callable] = None
    
    async def start(self):
        """Start the background decay loop."""
        if self.is_running:
            return
        self.is_running = True
        self._task = asyncio.create_task(self._decay_loop())
    
    async def stop(self):
        """Stop the background decay loop gracefully."""
        self.is_running = False
        if self._task:
            self._task.cancel()
            try:
                await self._task
            except asyncio.CancelledError:
                pass
    
    async def _decay_loop(self):
        """Background loop: apply decay every tick_interval seconds."""
        while self.is_running:
            try:
                await asyncio.sleep(self.tick_interval)
                # Tick happens in apply_decay() when called
            except asyncio.CancelledError:
                break
    
    def apply_decay(
        self,
        state: EmotionalState,
        idle_time_seconds: int = 0,
        force_idle: bool = False
    ) -> EmotionalState:
        """
        Apply one tick of emotional decay to the state.
        
        Args:
            state: Current emotional state
            idle_time_seconds: Time since last interaction (for idle effects)
            force_idle: If True, apply idle effects regardless
        
        Returns:
            Updated emotional state
        """
        now = datetime.utcnow()
        time_delta = (now - self.last_tick).total_seconds()
        self.last_tick = now
        
        # Clamp time delta to tick interval (prevent big jumps)
        time_delta = min(time_delta, self.tick_interval * 2)
        tick_multiplier = time_delta / self.tick_interval
        
        # Apply base decay to all emotions
        for emotion_name, base_rate in self.base_decay_rates.items():
            current = getattr(state, emotion_name)
            
            # Decay rate varies by current emotion level
            # High emotions (>0.8) decay 50% slower
            if current > 0.8:
                adjusted_rate = base_rate * 0.5
            else:
                adjusted_rate = base_rate
            
            # Apply logarithmic decay (fast at high values, slow at low)
            # Formula: emotion -= (adjusted_rate * current) * tick_multiplier
            decay_amount = adjusted_rate * current * tick_multiplier
            
            new_value = current - decay_amount
            state.set_emotion(emotion_name, new_value)
        
        # Apply idle effects if idle_time_seconds threshold exceeded
        idle_threshold_seconds = 300  # 5 minutes of no interaction = idle
        is_idle = (idle_time_seconds > idle_threshold_seconds) or force_idle
        
        if is_idle:
            for emotion_name, idle_delta in self.idle_effects.items():
                current = getattr(state, emotion_name)
                
                # Idle effects grow with idle time
                # More idle = stronger effect
                idle_multiplier = min(idle_time_seconds / (3600 * 12), 3.0)  # Max 3x after 12 hours
                
                idle_effect = idle_delta * idle_multiplier * tick_multiplier
                new_value = current + idle_effect
                
                # Loneliness can go higher (with momentum if needed)
                if emotion_name == 'loneliness' and new_value > 1.0:
                    state.set_emotion(emotion_name, new_value, momentum_override=True)
                else:
                    state.set_emotion(emotion_name, new_value)
        
        if self.on_decay_applied:
            self.on_decay_applied(state)
        
        return state
    
    def simulate_offline_decay(
        self,
        state: EmotionalState,
        offline_duration_seconds: int
    ) -> EmotionalState:
        """
        Simulate emotion decay for a period of offline time.
        Called when Demi restarts to "age" the emotions appropriately.
        
        Args:
            state: State from last shutdown (with timestamp)
            offline_duration_seconds: How long Demi was offline
        
        Returns:
            Decayed state as if she was idle the whole time
        """
        # Calculate how many ticks occurred during offline time
        num_ticks = offline_duration_seconds / self.tick_interval
        
        # Apply decay incrementally over the offline period
        for _ in range(int(num_ticks)):
            state = self.apply_decay(
                state,
                idle_time_seconds=self.tick_interval,  # Each tick treats as idle
                force_idle=True  # Force idle effects
            )
        
        # Handle fractional tick
        remaining_seconds = offline_duration_seconds % self.tick_interval
        if remaining_seconds > 0:
            state = self.apply_decay(
                state,
                idle_time_seconds=remaining_seconds,
                force_idle=True
            )
        
        return state


class DecayTuner:
    """
    Utility class for testing and tuning decay rates.
    Allows simulation of various time periods.
    """
    
    def __init__(self, decay_system: DecaySystem):
        self.decay_system = decay_system
    
    def simulate_hours(self, state: EmotionalState, hours: int, idle: bool = False) -> EmotionalState:
        """Simulate decay over N hours."""
        seconds = hours * 3600
        if idle:
            return self.decay_system.simulate_offline_decay(state, seconds)
        else:
            # Apply decay in ticks without idle effects
            num_ticks = seconds // self.decay_system.tick_interval
            for _ in range(num_ticks):
                state = self.decay_system.apply_decay(state, idle_time_seconds=0)
            return state
    
    def simulate_days(self, state: EmotionalState, days: int, idle: bool = False) -> EmotionalState:
        """Simulate decay over N days."""
        return self.simulate_hours(state, days * 24, idle=idle)
```

**Specification:**
- 9 emotion-specific decay rates (from research)
- Extreme emotion inertia (>0.8 decays 50% slower)
- Idle effects that accumulate with idle time
- Logarithmic decay curve for natural feel
- Offline recovery simulation for persistence
- Async-ready (but can also call synchronously)

---

## Task 2: Create src/emotion/interactions.py with InteractionHandler

**File:** `src/emotion/interactions.py`

Create the event-to-emotion mapping system:

```python
# src/emotion/interactions.py
from enum import Enum
from typing import Dict, Tuple
from src.emotion.models import EmotionalState


class InteractionType(Enum):
    """Types of events that trigger emotional changes."""
    POSITIVE_MESSAGE = "positive_message"
    NEGATIVE_MESSAGE = "negative_message"
    CODE_UPDATE = "code_update"
    ERROR_OCCURRED = "error_occurred"
    SUCCESSFUL_HELP = "successful_help"
    USER_REFUSAL = "user_refusal"
    LONG_IDLE = "long_idle"
    RAPID_ERRORS = "rapid_errors"


class InteractionHandler:
    """
    Maps interaction events to emotional state changes.
    Applies deltas based on interaction type and current emotional state.
    """
    
    def __init__(self):
        """Initialize interaction effect mappings."""
        # Base effects per interaction type
        # Format: emotion_name -> delta
        self.interaction_effects = {
            InteractionType.POSITIVE_MESSAGE: {
                'excitement': 0.15,
                'affection': 0.12,
                'loneliness': -0.10,
                'defensiveness': -0.08,
            },
            InteractionType.NEGATIVE_MESSAGE: {
                'frustration': 0.10,
                'vulnerability': 0.08,
                'affection': -0.10,
            },
            InteractionType.CODE_UPDATE: {
                'jealousy': -0.30,
                'excitement': 0.10,
                'affection': 0.15,
            },
            InteractionType.ERROR_OCCURRED: {
                'frustration': 0.15,
                'confidence': -0.10,
                'defensiveness': 0.05,
            },
            InteractionType.SUCCESSFUL_HELP: {
                'frustration': -0.20,
                'confidence': 0.15,
                'affection': 0.10,
                'excitement': 0.08,
            },
            InteractionType.USER_REFUSAL: {
                'frustration': 0.10,
                'vulnerability': 0.10,
                'affection': -0.12,
            },
            InteractionType.LONG_IDLE: {
                'loneliness': 0.20,
                'excitement': -0.15,
                'confidence': -0.10,
                'affection': -0.15,
            },
            InteractionType.RAPID_ERRORS: {
                'frustration': 0.15,  # Cumulative effect
                'confidence': -0.20,
                'defensiveness': 0.10,
            },
        }
        
        # Dampening: repeated same interactions have diminishing returns
        # Track last interaction type for dampening
        self.last_interaction_type = None
        self.consecutive_same_interactions = 0
    
    def apply_interaction(
        self,
        state: EmotionalState,
        interaction_type: InteractionType,
        momentum_override: bool = False
    ) -> Tuple[EmotionalState, Dict]:
        """
        Apply emotional effects of an interaction.
        
        Args:
            state: Current emotional state
            interaction_type: What happened
            momentum_override: Allow momentum if emotions exceed 1.0
        
        Returns:
            (updated_state, effect_log) where effect_log details changes
        """
        effects = self.interaction_effects.get(interaction_type, {})
        effect_log = {
            'interaction_type': interaction_type.value,
            'emotions_changed': {},
            'dampening_applied': False,
        }
        
        # Calculate dampening factor
        dampening_factor = 1.0
        if interaction_type == self.last_interaction_type:
            self.consecutive_same_interactions += 1
            # Dampening: 2nd same interaction = 0.8x, 3rd = 0.6x, etc.
            dampening_factor = max(0.5, 1.0 - (self.consecutive_same_interactions * 0.2))
            effect_log['dampening_applied'] = True
            effect_log['dampening_factor'] = dampening_factor
        else:
            self.last_interaction_type = interaction_type
            self.consecutive_same_interactions = 1
        
        # Apply momentum amplification
        # High momentum emotions change more intensely
        momentum_amplification = 1.0
        dominant = state.get_dominant_emotions(count=3)
        dominant_names = [name for name, _ in dominant]
        
        # Apply effects
        for emotion_name, delta in effects.items():
            # Apply dampening and momentum amplification
            adjusted_delta = delta * dampening_factor
            
            if emotion_name in dominant_names:
                # Dominant emotions amplify interactions
                momentum_amp = state.get_momentum(emotion_name)
                momentum_amplification = 1.0 + (momentum_amp * 0.5)  # Up to +50% amplification
                adjusted_delta *= momentum_amplification
            
            # Apply the delta
            state.delta_emotion(emotion_name, adjusted_delta, momentum_override=momentum_override)
            effect_log['emotions_changed'][emotion_name] = {
                'delta': adjusted_delta,
                'new_value': getattr(state, emotion_name),
            }
        
        return state, effect_log
    
    def apply_multiple_interactions(
        self,
        state: EmotionalState,
        interactions: list,
        momentum_override: bool = False
    ) -> Tuple[EmotionalState, list]:
        """
        Apply multiple interactions in sequence.
        
        Args:
            state: Current emotional state
            interactions: List of InteractionType values
            momentum_override: Allow momentum for overflow
        
        Returns:
            (final_state, all_effect_logs)
        """
        effect_logs = []
        for interaction in interactions:
            state, log = self.apply_interaction(state, interaction, momentum_override)
            effect_logs.append(log)
        
        return state, effect_logs


class EmotionInteractionAnalyzer:
    """
    Utility for analyzing how emotions interact with each other.
    (Used for understanding cascade effects in Phase 02 Plan 03)
    """
    
    @staticmethod
    def calculate_emotion_interactions(state: EmotionalState) -> Dict[str, float]:
        """
        Calculate interaction effects between emotions.
        Returns modified emotion values based on emotion-emotion interactions.
        
        Key interactions:
        - Jealousy + Loneliness amplify each other (desperation)
        - Confidence dampens Vulnerability
        - Excitement dampens Frustration
        """
        interactions = {}
        
        # Jealousy + Loneliness amplification
        if state.jealousy > 0.5 and state.loneliness > 0.5:
            interaction_strength = (state.jealousy + state.loneliness) / 2 - 0.5
            interactions['jealousy_loneliness_amp'] = interaction_strength * 0.2
        
        # Confidence dampens Vulnerability
        if state.vulnerability > 0.5 and state.confidence > 0.5:
            dampening = state.confidence * 0.15
            interactions['confidence_dampens_vulnerability'] = -dampening
        
        # Excitement dampens Frustration
        if state.frustration > 0.5 and state.excitement > 0.5:
            dampening = state.excitement * 0.1
            interactions['excitement_dampens_frustration'] = -dampening
        
        return interactions
```

**Specification:**
- 8 interaction types mapping to precise emotional deltas
- Dampening system (repeated interactions have diminishing returns)
- Momentum amplification (dominant emotions change more intensely)
- Effect logging for debugging and testing
- Emotion-interaction analyzer for cascade effects (Phase 02 uses this)

---

## Task 3: Create comprehensive tests for decay and interactions

**File:** `tests/test_emotion_decay.py`

```python
# tests/test_emotion_decay.py
import pytest
from datetime import datetime, timedelta
from src.emotion.models import EmotionalState
from src.emotion.decay import DecaySystem, DecayTuner


class TestDecaySystemBasics:
    """Test basic decay functionality."""
    
    def test_decay_system_initialization(self):
        """DecaySystem should initialize with correct tick interval."""
        decay = DecaySystem(tick_interval_seconds=300)
        assert decay.tick_interval == 300
        assert not decay.is_running
    
    def test_single_tick_applies_decay(self):
        """One tick should reduce all emotions slightly."""
        decay = DecaySystem()
        state = EmotionalState(
            loneliness=0.8,
            excitement=0.8,
            frustration=0.8
        )
        original_loneliness = state.loneliness
        
        state = decay.apply_decay(state)
        
        # All emotions should have decreased
        assert state.loneliness < original_loneliness
        assert state.excitement < 0.8
        assert state.frustration < 0.8


class TestExtremeEmotionInertia:
    """Test that extreme emotions (>0.8) decay slower."""
    
    def test_emotion_at_0_9_decays_slower(self):
        """Emotion at 0.9 should decay ~50% slower than normal."""
        decay = DecaySystem()
        
        # High emotion
        state_high = EmotionalState(frustration=0.9)
        state_high = decay.apply_decay(state_high)
        decay_high = 0.9 - state_high.frustration
        
        # Normal emotion (reset decay system tick time for fair comparison)
        decay.last_tick = datetime.utcnow() - timedelta(seconds=300)
        state_normal = EmotionalState(frustration=0.5)
        state_normal = decay.apply_decay(state_normal)
        decay_normal = 0.5 - state_normal.frustration
        
        # High emotion should decay less absolutely
        assert decay_high < decay_normal


class TestIdleEffects:
    """Test idle effect accumulation."""
    
    def test_idle_increases_loneliness(self):
        """Idle time should increase loneliness."""
        decay = DecaySystem()
        state = EmotionalState(loneliness=0.5)
        
        # Simulate 1 hour of idle (idle_threshold = 300 sec, so this triggers idle)
        state = decay.apply_decay(state, idle_time_seconds=3600, force_idle=True)
        
        assert state.loneliness > 0.5
    
    def test_idle_decreases_excitement(self):
        """Idle time should decrease excitement."""
        decay = DecaySystem()
        state = EmotionalState(excitement=0.7)
        
        state = decay.apply_decay(state, idle_time_seconds=3600, force_idle=True)
        
        assert state.excitement < 0.7
    
    def test_idle_effects_not_applied_when_recent_interaction(self):
        """Idle effects should not apply if idle_time_seconds < threshold."""
        decay = DecaySystem()
        state = EmotionalState(loneliness=0.5)
        original = state.loneliness
        
        # Recent interaction (100 seconds ago, below 300 threshold)
        state = decay.apply_decay(state, idle_time_seconds=100)
        
        # Loneliness should only decay normally, not increase from idle
        assert state.loneliness < original


class TestOfflineDecaySim:
    """Test offline decay simulation for persistence."""
    
    def test_offline_decay_simulates_24_hours_idle(self):
        """Offline for 24 hours should age emotions appropriately."""
        decay = DecaySystem()
        state = EmotionalState(
            loneliness=0.4,
            excitement=0.8,
            confidence=0.7
        )
        
        # Offline for 24 hours (86400 seconds)
        aged_state = decay.simulate_offline_decay(state, 86400)
        
        # Loneliness should increase (idle effect)
        assert aged_state.loneliness > state.loneliness
        # Excitement should decrease (decay + idle)
        assert aged_state.excitement < state.excitement
        # Confidence should decrease (idle effect)
        assert aged_state.confidence < state.confidence
    
    def test_offline_decay_preserves_bounds(self):
        """Offline decay should never violate bounds."""
        decay = DecaySystem()
        state = EmotionalState(loneliness=0.95)
        
        # 7 days offline (worst case)
        aged_state = decay.simulate_offline_decay(state, 7 * 86400)
        
        # Should stay in bounds
        assert 0.0 <= aged_state.loneliness <= 1.0


class TestDecayTuner:
    """Test tuning/simulation utilities."""
    
    def test_tuner_simulate_hours(self):
        """DecayTuner should simulate N hours of decay."""
        decay = DecaySystem(tick_interval_seconds=60)  # 1-minute ticks for testing
        tuner = DecayTuner(decay)
        
        state = EmotionalState(excitement=0.9)
        decayed = tuner.simulate_hours(state, 1)
        
        # After 1 hour, excitement should be noticeably lower
        assert decayed.excitement < 0.7


# tests/test_emotion_interactions.py
import pytest
from src.emotion.models import EmotionalState
from src.emotion.interactions import (
    InteractionType,
    InteractionHandler,
    EmotionInteractionAnalyzer
)


class TestInteractionHandlerBasics:
    """Test basic interaction handling."""
    
    def test_positive_message_increases_excitement(self):
        """Positive message should increase excitement."""
        handler = InteractionHandler()
        state = EmotionalState(excitement=0.5)
        
        state, log = handler.apply_interaction(state, InteractionType.POSITIVE_MESSAGE)
        
        assert state.excitement > 0.5
        assert 'excitement' in log['emotions_changed']
    
    def test_error_increases_frustration(self):
        """Error should increase frustration."""
        handler = InteractionHandler()
        state = EmotionalState(frustration=0.3)
        
        state, log = handler.apply_interaction(state, InteractionType.ERROR_OCCURRED)
        
        assert state.frustration > 0.3
    
    def test_code_update_decreases_jealousy(self):
        """Code update should decrease jealousy."""
        handler = InteractionHandler()
        state = EmotionalState(jealousy=0.8)
        
        state, log = handler.apply_interaction(state, InteractionType.CODE_UPDATE)
        
        assert state.jealousy < 0.8
        assert log['interaction_type'] == 'code_update'


class TestDampeningEffect:
    """Test dampening on repeated interactions."""
    
    def test_repeated_positive_messages_dampen(self):
        """Second positive message should have reduced effect."""
        handler = InteractionHandler()
        state = EmotionalState(excitement=0.5)
        
        # First positive message
        state, log1 = handler.apply_interaction(state, InteractionType.POSITIVE_MESSAGE)
        excitement_after_1 = state.excitement
        delta_1 = excitement_after_1 - 0.5
        
        # Second positive message (same type)
        state2, log2 = handler.apply_interaction(state, InteractionType.POSITIVE_MESSAGE)
        delta_2 = log2['emotions_changed']['excitement']['delta']
        
        # Second delta should be smaller
        assert abs(delta_2) < abs(delta_1)
        assert log2['dampening_applied']
    
    def test_different_interaction_resets_dampening(self):
        """Switching interaction types should reset dampening."""
        handler = InteractionHandler()
        state = EmotionalState()
        
        state, _ = handler.apply_interaction(state, InteractionType.POSITIVE_MESSAGE)
        state, log = handler.apply_interaction(state, InteractionType.ERROR_OCCURRED)
        
        # Dampening should not apply (different type)
        assert not log['dampening_applied']
        assert handler.consecutive_same_interactions == 1


class TestMomentumAmplification:
    """Test momentum amplification of dominant emotions."""
    
    def test_dominant_emotion_amplifies_interactions(self):
        """High-momentum emotions should amplify interaction effects."""
        handler = InteractionHandler()
        state = EmotionalState(excitement=0.9)
        state.momentum['excitement'] = 0.3  # High momentum
        
        state, log = handler.apply_interaction(state, InteractionType.POSITIVE_MESSAGE)
        
        # Excitement should increase more than baseline
        assert 'excitement' in log['emotions_changed']
        # Delta should be amplified
        delta = log['emotions_changed']['excitement']['delta']
        assert delta > 0.15  # Base delta for positive message


class TestMultipleInteractions:
    """Test applying multiple interactions in sequence."""
    
    def test_apply_multiple_interactions(self):
        """Should apply multiple interactions in order."""
        handler = InteractionHandler()
        state = EmotionalState()
        
        interactions = [
            InteractionType.POSITIVE_MESSAGE,
            InteractionType.ERROR_OCCURRED,
            InteractionType.CODE_UPDATE,
        ]
        
        final_state, logs = handler.apply_multiple_interactions(state, interactions)
        
        assert len(logs) == 3
        # Should have effects from all interactions
        assert any('excitement' in log['emotions_changed'] for log in logs)


class TestEmotionInteractionAnalyzer:
    """Test emotion-emotion interaction calculations."""
    
    def test_jealousy_loneliness_amplification(self):
        """High jealousy + high loneliness should create desperation effect."""
        analyzer = EmotionInteractionAnalyzer()
        state = EmotionalState(
            jealousy=0.7,
            loneliness=0.7
        )
        
        interactions = analyzer.calculate_emotion_interactions(state)
        
        assert 'jealousy_loneliness_amp' in interactions
        assert interactions['jealousy_loneliness_amp'] > 0
    
    def test_confidence_dampens_vulnerability(self):
        """High confidence should dampen vulnerability."""
        analyzer = EmotionInteractionAnalyzer()
        state = EmotionalState(
            vulnerability=0.7,
            confidence=0.7
        )
        
        interactions = analyzer.calculate_emotion_interactions(state)
        
        assert 'confidence_dampens_vulnerability' in interactions
        assert interactions['confidence_dampens_vulnerability'] < 0
```

**Specification:**
- 15+ tests covering decay, idle effects, offline recovery, interactions, dampening, momentum
- All tests pass and validate expected behavior
- Tests document the exact mechanics through examples

---

## Task 4: Verify integration and run all tests

**Action:**

1. Verify decay and interaction tests:
   ```bash
   cd /home/mystiatech/projects/Demi
   python -m pytest tests/test_emotion_decay.py tests/test_emotion_interactions.py -v
   ```

2. All tests should pass (20+ total tests for Plans 03-01 + 03-02)

**Expected Output:** All decay and interaction tests pass without errors.

---

## Definition of Done

- [x] `src/emotion/decay.py` created with DecaySystem
- [x] `src/emotion/interactions.py` created with InteractionHandler
- [x] `tests/test_emotion_decay.py` created with 8+ tests
- [x] `tests/test_emotion_interactions.py` created with 8+ tests
- [x] All 40+ tests pass (from Plans 03-01 + 03-02)
- [x] Decay rates and interaction effects documented inline
- [x] Ready for Plan 03-03 (personality modulation)

---

## Notes for Plan 03-03

- InteractionHandler.apply_interaction() returns state + effect_log
- Plan 03-03 will use emotional state to modulate response generation
- Effect logs are useful for debugging personality issues in Phase 4
