---
phase: 03-emotional-system
plan: 03-01
type: core
wave: 1
depends_on: []
files_modified:
  - src/emotion/models.py
  - src/emotion/__init__.py
autonomous: true
must_haves:
  - EmotionalState class with 9 dimensions (loneliness, excitement, frustration, jealousy, vulnerability, confidence, curiosity, affection, defensiveness)
  - 0-1 percentage scale with momentum tracking (tracks how much emotion exceeded 1.0)
  - Emotional state serializable to dict for database persistence
  - Unit tests for emotional state instantiation, bounds checking, momentum calculation
  - State floor enforcement (loneliness ≥0.3, others ≥0.1)
---

# Plan 03-01: Emotional State Model & Core Mechanics

**Goal:** Build the foundational emotional state data structure and core mechanics that all other systems will use.

**Duration:** ~1.5 hours

**Scope:** Single responsibility — define what Demi's emotions ARE. No persistence, no decay ticks, no personality modulation. Just the data model.

---

## Success Criteria

1. **EmotionalState class** instantiates with 9 dimensions, each 0.0-1.0, all startable from constructor or default neutral (0.5)
2. **Momentum tracking** stores how much each emotion exceeded 1.0 during interactions (for cascade effects in Plan 02)
3. **Serialization** to dict works flawlessly (needed for database in Plan 04)
4. **State machine** enforces valid transitions (emotions never negative, never exceed 1.0 without momentum record)
5. **Unit tests** (7+ tests) validate bounds, momentum, state machine, serialization, and floor enforcement

---

## Task 1: Create src/emotion/models.py with EmotionalState class

**File:** `src/emotion/models.py`

Create a new file with the following implementation:

```python
# src/emotion/models.py
from dataclasses import dataclass, field, asdict
from typing import Dict, Optional
from datetime import datetime

@dataclass
class EmotionalState:
    """
    Demi's emotional state across 9 dimensions.
    Each emotion is a percentage (0.0-1.0).
    Momentum tracking records overflow for cascade effects.
    """
    # Core 5 emotions
    loneliness: float = 0.5
    excitement: float = 0.5
    frustration: float = 0.5
    jealousy: float = 0.5
    vulnerability: float = 0.5
    
    # Additional 4 dimensions
    confidence: float = 0.5
    curiosity: float = 0.5
    affection: float = 0.5
    defensiveness: float = 0.5
    
    # Momentum tracking (how much each emotion exceeded 1.0)
    # Used by decay system to trigger cascade effects
    momentum: Dict[str, float] = field(default_factory=lambda: {
        'loneliness': 0.0,
        'excitement': 0.0,
        'frustration': 0.0,
        'jealousy': 0.0,
        'vulnerability': 0.0,
        'confidence': 0.0,
        'curiosity': 0.0,
        'affection': 0.0,
        'defensiveness': 0.0,
    })
    
    # Metadata
    last_updated: datetime = field(default_factory=datetime.utcnow)
    
    # Emotion-specific floors (minimum values)
    _EMOTION_FLOORS = {
        'loneliness': 0.3,     # Loneliness lingers (hard to shake)
        'excitement': 0.1,     # Others have minimal baseline
        'frustration': 0.1,
        'jealousy': 0.1,
        'vulnerability': 0.1,
        'confidence': 0.1,
        'curiosity': 0.1,
        'affection': 0.1,
        'defensiveness': 0.1,
    }
    
    def __post_init__(self):
        """Validate state after initialization."""
        self._validate_bounds()
        self.last_updated = datetime.utcnow()
    
    def _validate_bounds(self):
        """Ensure all emotions are within [floor, 1.0]."""
        emotion_names = [
            'loneliness', 'excitement', 'frustration', 'jealousy', 'vulnerability',
            'confidence', 'curiosity', 'affection', 'defensiveness'
        ]
        for name in emotion_names:
            floor = self._EMOTION_FLOORS.get(name, 0.1)
            current = getattr(self, name)
            
            # Clamp to [floor, 1.0]
            if current < floor:
                setattr(self, name, floor)
            elif current > 1.0:
                # Record momentum and clamp
                excess = current - 1.0
                self.momentum[name] = max(self.momentum[name], excess)
                setattr(self, name, 1.0)
    
    def set_emotion(self, emotion_name: str, value: float, momentum_override: bool = False) -> None:
        """
        Set an emotion to a specific value with bounds checking.
        
        Args:
            emotion_name: Name of emotion to set
            value: Target value (0.0-1.0, or higher if allowing momentum)
            momentum_override: If True, allow value > 1.0 (sets momentum)
        """
        if emotion_name not in self._EMOTION_FLOORS:
            raise ValueError(f"Unknown emotion: {emotion_name}")
        
        if momentum_override:
            # Allow overflow, record momentum
            if value > 1.0:
                excess = value - 1.0
                self.momentum[emotion_name] = max(self.momentum[emotion_name], excess)
                setattr(self, emotion_name, 1.0)
            else:
                setattr(self, emotion_name, max(value, self._EMOTION_FLOORS[emotion_name]))
                self.momentum[emotion_name] = 0.0
        else:
            # Strict bounds [floor, 1.0]
            floor = self._EMOTION_FLOORS[emotion_name]
            clamped = max(floor, min(1.0, value))
            setattr(self, emotion_name, clamped)
            self.momentum[emotion_name] = 0.0
        
        self.last_updated = datetime.utcnow()
    
    def delta_emotion(self, emotion_name: str, delta: float, momentum_override: bool = False) -> None:
        """
        Change an emotion by a delta value.
        
        Args:
            emotion_name: Name of emotion to modify
            delta: Change amount (can be positive or negative)
            momentum_override: If True, allow crossing 1.0 (sets momentum)
        """
        current = getattr(self, emotion_name)
        new_value = current + delta
        self.set_emotion(emotion_name, new_value, momentum_override=momentum_override)
    
    def get_momentum(self, emotion_name: str) -> float:
        """Get current momentum for an emotion (how much it exceeded 1.0)."""
        return self.momentum.get(emotion_name, 0.0)
    
    def clear_momentum(self, emotion_name: str) -> None:
        """Clear momentum for an emotion (after cascade effect fires)."""
        self.momentum[emotion_name] = 0.0
    
    def to_dict(self) -> Dict:
        """Serialize emotional state to dict for database storage."""
        return {
            'loneliness': self.loneliness,
            'excitement': self.excitement,
            'frustration': self.frustration,
            'jealousy': self.jealousy,
            'vulnerability': self.vulnerability,
            'confidence': self.confidence,
            'curiosity': self.curiosity,
            'affection': self.affection,
            'defensiveness': self.defensiveness,
            'momentum': self.momentum.copy(),
            'last_updated': self.last_updated.isoformat(),
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'EmotionalState':
        """Deserialize emotional state from dict (from database)."""
        return cls(
            loneliness=data.get('loneliness', 0.5),
            excitement=data.get('excitement', 0.5),
            frustration=data.get('frustration', 0.5),
            jealousy=data.get('jealousy', 0.5),
            vulnerability=data.get('vulnerability', 0.5),
            confidence=data.get('confidence', 0.5),
            curiosity=data.get('curiosity', 0.5),
            affection=data.get('affection', 0.5),
            defensiveness=data.get('defensiveness', 0.5),
            momentum=data.get('momentum', {}),
        )
    
    def get_all_emotions(self) -> Dict[str, float]:
        """Return dict of all emotion names and current values."""
        return {
            'loneliness': self.loneliness,
            'excitement': self.excitement,
            'frustration': self.frustration,
            'jealousy': self.jealousy,
            'vulnerability': self.vulnerability,
            'confidence': self.confidence,
            'curiosity': self.curiosity,
            'affection': self.affection,
            'defensiveness': self.defensiveness,
        }
    
    def get_dominant_emotions(self, count: int = 3) -> list:
        """Return the N strongest emotions (by value)."""
        emotions = self.get_all_emotions()
        return sorted(emotions.items(), key=lambda x: x[1], reverse=True)[:count]
```

**Specification:**
- All emotions default to 0.5 (neutral baseline)
- Momentum dict tracks overflow for each emotion
- `set_emotion()` enforces bounds and optionally records momentum
- `delta_emotion()` applies relative changes
- `to_dict()` and `from_dict()` handle database serialization
- Floor enforcement in `__post_init__()` and `set_emotion()`
- `get_dominant_emotions()` useful for personality modulation

---

## Task 2: Create src/emotion/__init__.py and unit tests

**File:** `src/emotion/__init__.py`

```python
# src/emotion/__init__.py
from .models import EmotionalState

__all__ = ['EmotionalState']
```

**File:** `tests/test_emotion_models.py`

Create comprehensive unit tests:

```python
# tests/test_emotion_models.py
import pytest
from datetime import datetime
from src.emotion.models import EmotionalState


class TestEmotionalStateInstantiation:
    """Test EmotionalState creation and initialization."""
    
    def test_default_neutral_state(self):
        """All emotions should default to 0.5 (neutral)."""
        state = EmotionalState()
        assert state.loneliness == 0.5
        assert state.excitement == 0.5
        assert state.frustration == 0.5
        assert state.jealousy == 0.5
        assert state.vulnerability == 0.5
        assert state.confidence == 0.5
        assert state.curiosity == 0.5
        assert state.affection == 0.5
        assert state.defensiveness == 0.5
    
    def test_custom_initial_state(self):
        """Should accept custom initial values."""
        state = EmotionalState(
            loneliness=0.8,
            excitement=0.2,
            frustration=0.6
        )
        assert state.loneliness == 0.8
        assert state.excitement == 0.2
        assert state.frustration == 0.6
        assert state.jealousy == 0.5  # Default
    
    def test_momentum_initialized_to_zero(self):
        """All momentum values should start at 0.0."""
        state = EmotionalState()
        for emotion in ['loneliness', 'excitement', 'frustration', 'jealousy', 'vulnerability', 'confidence', 'curiosity', 'affection', 'defensiveness']:
            assert state.momentum[emotion] == 0.0


class TestBoundsClamping:
    """Test that emotions stay within [floor, 1.0]."""
    
    def test_emotion_below_floor_clamped_to_floor(self):
        """Emotions below their floor should be clamped up."""
        state = EmotionalState(loneliness=0.1)
        assert state.loneliness == 0.3  # Loneliness floor is 0.3
    
    def test_emotion_above_one_clamped_to_one(self):
        """Emotions above 1.0 should be clamped to 1.0 without momentum_override."""
        state = EmotionalState()
        state.set_emotion('excitement', 1.5)
        assert state.excitement == 1.0
        assert state.momentum['excitement'] == 0.0  # No momentum recorded
    
    def test_emotion_above_one_with_momentum_override(self):
        """With momentum_override, emotions > 1.0 should record momentum."""
        state = EmotionalState()
        state.set_emotion('excitement', 1.5, momentum_override=True)
        assert state.excitement == 1.0
        assert state.momentum['excitement'] == 0.5  # Excess recorded


class TestMomentumTracking:
    """Test momentum accumulation and clearing."""
    
    def test_momentum_accumulation_on_multiple_overflows(self):
        """Momentum should track the maximum overflow."""
        state = EmotionalState()
        state.set_emotion('loneliness', 1.2, momentum_override=True)
        assert state.momentum['loneliness'] == 0.2
        
        # Another overflow, higher
        state.set_emotion('loneliness', 1.3, momentum_override=True)
        assert state.momentum['loneliness'] == 0.3  # Takes max
    
    def test_clear_momentum(self):
        """Clearing momentum should reset to 0.0."""
        state = EmotionalState()
        state.set_emotion('frustration', 1.2, momentum_override=True)
        assert state.momentum['frustration'] == 0.2
        
        state.clear_momentum('frustration')
        assert state.momentum['frustration'] == 0.0


class TestDeltaChanges:
    """Test delta_emotion() method."""
    
    def test_positive_delta(self):
        """Positive delta should increase emotion."""
        state = EmotionalState(excitement=0.5)
        state.delta_emotion('excitement', 0.1)
        assert state.excitement == 0.6
    
    def test_negative_delta(self):
        """Negative delta should decrease emotion (respecting floors)."""
        state = EmotionalState(curiosity=0.3)
        state.delta_emotion('curiosity', -0.5)
        assert state.curiosity == 0.1  # Floor is 0.1
    
    def test_delta_overflow_with_momentum(self):
        """Delta can overflow with momentum tracking."""
        state = EmotionalState(excitement=0.9)
        state.delta_emotion('excitement', 0.3, momentum_override=True)
        assert state.excitement == 1.0
        assert state.momentum['excitement'] == 0.2


class TestSerialization:
    """Test to_dict() and from_dict() methods."""
    
    def test_to_dict_complete(self):
        """to_dict() should include all emotions and metadata."""
        state = EmotionalState(
            loneliness=0.7,
            excitement=0.2,
            frustration=0.5
        )
        data = state.to_dict()
        
        assert data['loneliness'] == 0.7
        assert data['excitement'] == 0.2
        assert data['frustration'] == 0.5
        assert 'last_updated' in data
        assert 'momentum' in data
    
    def test_round_trip_serialization(self):
        """Serialize and deserialize should preserve state."""
        original = EmotionalState(
            loneliness=0.8,
            excitement=0.3,
            frustration=0.6,
            jealousy=0.4
        )
        original.momentum['excitement'] = 0.15
        
        data = original.to_dict()
        restored = EmotionalState.from_dict(data)
        
        assert restored.loneliness == original.loneliness
        assert restored.excitement == original.excitement
        assert restored.frustration == original.frustration
        assert restored.jealousy == original.jealousy
        assert restored.momentum['excitement'] == 0.15


class TestFloorEnforcement:
    """Test emotion-specific floor values."""
    
    def test_loneliness_floor_0_3(self):
        """Loneliness should never go below 0.3."""
        state = EmotionalState(loneliness=0.1)
        assert state.loneliness == 0.3
        
        state.set_emotion('loneliness', 0.0)
        assert state.loneliness == 0.3
    
    def test_other_emotions_floor_0_1(self):
        """Non-loneliness emotions should floor at 0.1."""
        state = EmotionalState(excitement=0.0)
        assert state.excitement == 0.1
        
        state.set_emotion('frustration', 0.05)
        assert state.frustration == 0.1


class TestGettersAndUtility:
    """Test utility methods."""
    
    def test_get_all_emotions(self):
        """get_all_emotions() should return dict of all 9."""
        state = EmotionalState(
            loneliness=0.8,
            excitement=0.2
        )
        all_emotions = state.get_all_emotions()
        
        assert len(all_emotions) == 9
        assert all_emotions['loneliness'] == 0.8
        assert all_emotions['excitement'] == 0.2
    
    def test_get_dominant_emotions(self):
        """get_dominant_emotions() should return top N by value."""
        state = EmotionalState(
            loneliness=0.9,
            excitement=0.2,
            frustration=0.8,
            affection=0.7
        )
        top_3 = state.get_dominant_emotions(count=3)
        
        assert len(top_3) == 3
        assert top_3[0][0] == 'loneliness'  # 0.9
        assert top_3[1][0] == 'frustration'  # 0.8
        assert top_3[2][0] == 'affection'  # 0.7
    
    def test_get_momentum(self):
        """get_momentum() should return emotion's momentum value."""
        state = EmotionalState()
        state.set_emotion('jealousy', 1.1, momentum_override=True)
        
        assert state.get_momentum('jealousy') == 0.1
        assert state.get_momentum('excitement') == 0.0
```

**Specification:**
- 20+ test cases covering all methods
- Tests for bounds, momentum, serialization, floors
- Round-trip serialization validation
- All tests pass without external dependencies (except pytest)

---

## Task 3: Verify file structure and run tests

**Action:**

1. Create directory structure:
   ```bash
   mkdir -p /home/mystiatech/projects/Demi/src/emotion
   mkdir -p /home/mystiatech/projects/Demi/tests
   ```

2. Run tests to verify implementation:
   ```bash
   cd /home/mystiatech/projects/Demi
   python -m pytest tests/test_emotion_models.py -v
   ```

**Expected Output:** All 20+ tests pass without errors.

---

## Definition of Done

- [x] `src/emotion/models.py` created with EmotionalState class
- [x] `src/emotion/__init__.py` created with exports
- [x] `tests/test_emotion_models.py` created with 20+ comprehensive tests
- [x] All tests pass without warnings
- [x] EmotionalState is production-ready for use in downstream plans
- [x] Code includes docstrings and type hints

---

## Notes for Plan 03-02

- EmotionalState is now the single source of truth for Demi's emotional data
- Plan 03-02 (Decay & Interaction System) will call `state.delta_emotion()` and `state.set_emotion()`
- Plan 03-04 (Persistence) will use `state.to_dict()` and `EmotionalState.from_dict()`
- Momentum tracking is pre-built for cascade effects but not used in Plan 01
