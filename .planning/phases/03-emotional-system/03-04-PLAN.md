---
phase: 03-emotional-system
plan: 03-04
type: integration
wave: 4
depends_on: ['03-01', '03-02', '03-03']
files_modified:
  - src/emotion/persistence.py
  - src/emotion/__init__.py
  - tests/test_emotion_persistence.py
  - tests/test_emotion_integration.py
autonomous: true
must_haves:
  - EmotionPersistence class with save/load/restore methods
  - Database table for emotional_state (schema, migrations)
  - Offline decay simulation on startup (from last saved state + time elapsed)
  - Interaction logging with full audit trail (timestamp, message, before/after state)
  - Data integrity checks (prevent corruption, recovery from backup)
  - Integration tests validating full E2E flow (save → offline → restore → age correctly)
---

# Plan 03-04: Persistence Layer & Validation Framework

**Goal:** Make Demi's emotions persistent across restarts and build validation framework for authenticity testing in Phase 9.

**Duration:** ~2 hours

**Scope:** Implement database persistence layer for emotional state, offline decay simulation, and comprehensive testing framework. This is the final piece of Phase 03—everything works together end-to-end.

---

## Success Criteria

1. **EmotionPersistence** class saves/restores emotional state to SQLite database
2. **Offline decay** simulates emotion progression during downtime (not just restoring old state)
3. **Interaction logging** records every interaction with before/after emotional state for analysis
4. **Backup & recovery** prevents data loss and handles corruption gracefully
5. **Integration tests** validate full E2E flow (create → save → offline → restore → validate)
6. **Testing framework prep** exports metrics for Phase 9 consistency validation

---

## Task 1: Create src/emotion/persistence.py with database layer

**File:** `src/emotion/persistence.py`

```python
# src/emotion/persistence.py
import sqlite3
import json
from datetime import datetime, timedelta
from typing import Optional, Dict, List
from pathlib import Path
from src.emotion.models import EmotionalState
from src.emotion.decay import DecaySystem
from src.emotion.interactions import InteractionType


class EmotionPersistence:
    """
    Handles persistent storage and recovery of emotional state.
    Integrates with DecaySystem to simulate offline emotion progression.
    """
    
    def __init__(self, db_path: str = "~/.demi/emotions.db"):
        """
        Initialize persistence layer.
        
        Args:
            db_path: Path to SQLite database file
        """
        self.db_path = Path(db_path).expanduser()
        self.db_path.parent.mkdir(parents=True, exist_ok=True)
        
        # Initialize database schema if needed
        self._init_schema()
    
    def _init_schema(self):
        """Create database tables if they don't exist."""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        # Main emotional state table
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS emotional_state (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                timestamp DATETIME NOT NULL,
                
                -- 9 emotions
                loneliness REAL NOT NULL,
                excitement REAL NOT NULL,
                frustration REAL NOT NULL,
                jealousy REAL NOT NULL,
                vulnerability REAL NOT NULL,
                confidence REAL NOT NULL,
                curiosity REAL NOT NULL,
                affection REAL NOT NULL,
                defensiveness REAL NOT NULL,
                
                -- Momentum tracking
                momentum_json TEXT NOT NULL,
                
                -- Metadata
                notes TEXT,
                
                UNIQUE(timestamp)
            )
        ''')
        
        # Interaction log (audit trail)
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS interaction_log (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                timestamp DATETIME NOT NULL,
                interaction_type TEXT NOT NULL,
                user_message TEXT,
                
                -- State before interaction
                state_before_json TEXT NOT NULL,
                
                -- State after interaction
                state_after_json TEXT NOT NULL,
                
                -- Effect details
                effects_json TEXT NOT NULL,
                
                -- Metadata
                confidence_level REAL,  -- 0-1 how sure about effect
                notes TEXT,
                
                INDEX idx_timestamp (timestamp),
                INDEX idx_interaction_type (interaction_type)
            )
        ''')
        
        # Backup snapshots (hourly)
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS state_snapshots (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                timestamp DATETIME NOT NULL UNIQUE,
                state_json TEXT NOT NULL,
                snapshot_type TEXT DEFAULT 'hourly'  -- hourly, manual, startup, shutdown
            )
        ''')
        
        conn.commit()
        conn.close()
    
    def save_state(
        self,
        state: EmotionalState,
        notes: Optional[str] = None
    ) -> bool:
        """
        Save current emotional state to database.
        
        Args:
            state: EmotionalState to persist
            notes: Optional notes about what triggered this state
        
        Returns:
            True if saved successfully
        """
        try:
            conn = sqlite3.connect(self.db_path)
            cursor = conn.cursor()
            
            now = datetime.utcnow()
            
            cursor.execute('''
                INSERT INTO emotional_state 
                (timestamp, loneliness, excitement, frustration, jealousy, vulnerability,
                 confidence, curiosity, affection, defensiveness, momentum_json, notes)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
            ''', (
                now.isoformat(),
                state.loneliness,
                state.excitement,
                state.frustration,
                state.jealousy,
                state.vulnerability,
                state.confidence,
                state.curiosity,
                state.affection,
                state.defensiveness,
                json.dumps(state.momentum),
                notes,
            ))
            
            conn.commit()
            conn.close()
            return True
        except Exception as e:
            print(f"Failed to save emotional state: {e}")
            return False
    
    def load_latest_state(self) -> Optional[EmotionalState]:
        """
        Load the most recent saved emotional state.
        
        Returns:
            EmotionalState or None if not found
        """
        try:
            conn = sqlite3.connect(self.db_path)
            cursor = conn.cursor()
            
            cursor.execute('''
                SELECT loneliness, excitement, frustration, jealousy, vulnerability,
                       confidence, curiosity, affection, defensiveness, momentum_json, timestamp
                FROM emotional_state
                ORDER BY timestamp DESC
                LIMIT 1
            ''')
            
            row = cursor.fetchone()
            conn.close()
            
            if not row:
                return None
            
            state = EmotionalState(
                loneliness=row[0],
                excitement=row[1],
                frustration=row[2],
                jealousy=row[3],
                vulnerability=row[4],
                confidence=row[5],
                curiosity=row[6],
                affection=row[7],
                defensiveness=row[8],
            )
            state.momentum = json.loads(row[9])
            
            return state
        except Exception as e:
            print(f"Failed to load emotional state: {e}")
            return None
    
    def restore_and_age_state(self, decay_system: DecaySystem) -> Optional[EmotionalState]:
        """
        Restore emotional state from database and simulate offline decay.
        
        This is the main restore function called on startup:
        1. Load last saved state
        2. Calculate how long we were offline
        3. Simulate emotion decay for that period
        4. Return aged state
        
        Args:
            decay_system: DecaySystem instance for offline simulation
        
        Returns:
            Aged emotional state, or None if no saved state
        """
        try:
            conn = sqlite3.connect(self.db_path)
            cursor = conn.cursor()
            
            cursor.execute('''
                SELECT loneliness, excitement, frustration, jealousy, vulnerability,
                       confidence, curiosity, affection, defensiveness, momentum_json, timestamp
                FROM emotional_state
                ORDER BY timestamp DESC
                LIMIT 1
            ''')
            
            row = cursor.fetchone()
            conn.close()
            
            if not row:
                return None
            
            # Reconstruct state
            state = EmotionalState(
                loneliness=row[0],
                excitement=row[1],
                frustration=row[2],
                jealousy=row[3],
                vulnerability=row[4],
                confidence=row[5],
                curiosity=row[6],
                affection=row[7],
                defensiveness=row[8],
            )
            state.momentum = json.loads(row[9])
            last_save_time = datetime.fromisoformat(row[10])
            
            # Calculate offline duration
            now = datetime.utcnow()
            offline_seconds = int((now - last_save_time).total_seconds())
            
            # Simulate decay for offline period
            aged_state = decay_system.simulate_offline_decay(state, offline_seconds)
            
            return aged_state
        except Exception as e:
            print(f"Failed to restore and age state: {e}")
            # Return None to start fresh
            return None
    
    def log_interaction(
        self,
        interaction_type: InteractionType,
        state_before: EmotionalState,
        state_after: EmotionalState,
        effects: Dict,
        user_message: Optional[str] = None,
        confidence_level: float = 1.0,
        notes: Optional[str] = None
    ) -> bool:
        """
        Log an interaction with before/after emotional states.
        
        Args:
            interaction_type: What happened
            state_before: Emotional state before interaction
            state_after: Emotional state after interaction
            effects: Effect dictionary from InteractionHandler
            user_message: The user's message (if applicable)
            confidence_level: How confident we are about the effect (0-1)
            notes: Optional notes
        
        Returns:
            True if logged successfully
        """
        try:
            conn = sqlite3.connect(self.db_path)
            cursor = conn.cursor()
            
            now = datetime.utcnow()
            
            cursor.execute('''
                INSERT INTO interaction_log
                (timestamp, interaction_type, user_message, state_before_json, 
                 state_after_json, effects_json, confidence_level, notes)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?)
            ''', (
                now.isoformat(),
                interaction_type.value,
                user_message,
                json.dumps(state_before.to_dict()),
                json.dumps(state_after.to_dict()),
                json.dumps(effects),
                confidence_level,
                notes,
            ))
            
            conn.commit()
            conn.close()
            return True
        except Exception as e:
            print(f"Failed to log interaction: {e}")
            return False
    
    def get_interaction_history(
        self,
        limit: int = 100,
        interaction_type: Optional[str] = None
    ) -> List[Dict]:
        """
        Retrieve recent interaction history.
        
        Args:
            limit: Maximum number of records to return
            interaction_type: Filter by type (optional)
        
        Returns:
            List of interaction dictionaries
        """
        try:
            conn = sqlite3.connect(self.db_path)
            cursor = conn.cursor()
            
            if interaction_type:
                cursor.execute('''
                    SELECT timestamp, interaction_type, user_message, state_before_json,
                           state_after_json, effects_json, confidence_level, notes
                    FROM interaction_log
                    WHERE interaction_type = ?
                    ORDER BY timestamp DESC
                    LIMIT ?
                ''', (interaction_type, limit))
            else:
                cursor.execute('''
                    SELECT timestamp, interaction_type, user_message, state_before_json,
                           state_after_json, effects_json, confidence_level, notes
                    FROM interaction_log
                    ORDER BY timestamp DESC
                    LIMIT ?
                ''', (limit,))
            
            rows = cursor.fetchall()
            conn.close()
            
            return [
                {
                    'timestamp': row[0],
                    'interaction_type': row[1],
                    'user_message': row[2],
                    'state_before': json.loads(row[3]),
                    'state_after': json.loads(row[4]),
                    'effects': json.loads(row[5]),
                    'confidence_level': row[6],
                    'notes': row[7],
                }
                for row in rows
            ]
        except Exception as e:
            print(f"Failed to retrieve interaction history: {e}")
            return []
    
    def create_backup_snapshot(self, state: EmotionalState, snapshot_type: str = "manual"):
        """
        Create a backup snapshot of the current state.
        Called hourly automatically or on manual request.
        
        Args:
            state: State to snapshot
            snapshot_type: one of 'hourly', 'manual', 'startup', 'shutdown'
        """
        try:
            conn = sqlite3.connect(self.db_path)
            cursor = conn.cursor()
            
            now = datetime.utcnow()
            
            cursor.execute('''
                INSERT INTO state_snapshots (timestamp, state_json, snapshot_type)
                VALUES (?, ?, ?)
            ''', (
                now.isoformat(),
                json.dumps(state.to_dict()),
                snapshot_type,
            ))
            
            conn.commit()
            conn.close()
        except Exception as e:
            print(f"Failed to create backup snapshot: {e}")
    
    def restore_from_backup(self, backup_age_hours: int = 1) -> Optional[EmotionalState]:
        """
        Restore state from a recent backup snapshot.
        Used if primary state is corrupted.
        
        Args:
            backup_age_hours: How far back to look (default 1 hour)
        
        Returns:
            EmotionalState from backup, or None if not found
        """
        try:
            conn = sqlite3.connect(self.db_path)
            cursor = conn.cursor()
            
            cutoff_time = datetime.utcnow() - timedelta(hours=backup_age_hours)
            
            cursor.execute('''
                SELECT state_json FROM state_snapshots
                WHERE timestamp >= ?
                ORDER BY timestamp DESC
                LIMIT 1
            ''', (cutoff_time.isoformat(),))
            
            row = cursor.fetchone()
            conn.close()
            
            if not row:
                return None
            
            state_dict = json.loads(row[0])
            return EmotionalState.from_dict(state_dict)
        except Exception as e:
            print(f"Failed to restore from backup: {e}")
            return None
```

---

## Task 2: Create integration tests for persistence and E2E flow

**File:** `tests/test_emotion_persistence.py`

```python
# tests/test_emotion_persistence.py
import pytest
import os
import tempfile
import sqlite3
from datetime import datetime, timedelta
from src.emotion.models import EmotionalState
from src.emotion.persistence import EmotionPersistence
from src.emotion.decay import DecaySystem
from src.emotion.interactions import InteractionType


class TestEmotionPersistenceBasics:
    """Test basic save/load operations."""
    
    def test_persistence_initialization(self):
        """Should create database and schema."""
        with tempfile.TemporaryDirectory() as tmpdir:
            db_path = os.path.join(tmpdir, 'emotions.db')
            persistence = EmotionPersistence(db_path=db_path)
            
            # Database file should exist
            assert os.path.exists(db_path)
    
    def test_save_and_load_state(self):
        """Should save and retrieve emotional state."""
        with tempfile.TemporaryDirectory() as tmpdir:
            db_path = os.path.join(tmpdir, 'emotions.db')
            persistence = EmotionPersistence(db_path=db_path)
            
            # Create and save state
            original = EmotionalState(
                loneliness=0.8,
                excitement=0.3,
                frustration=0.5
            )
            original.momentum['excitement'] = 0.1
            
            assert persistence.save_state(original)
            
            # Load it back
            loaded = persistence.load_latest_state()
            assert loaded is not None
            assert loaded.loneliness == 0.8
            assert loaded.excitement == 0.3
            assert loaded.frustration == 0.5
            assert loaded.momentum['excitement'] == 0.1


class TestOfflineDecayRecovery:
    """Test restore_and_age_state simulates offline decay."""
    
    def test_restore_and_age_simulates_offline_decay(self):
        """Loading state should apply offline decay."""
        with tempfile.TemporaryDirectory() as tmpdir:
            db_path = os.path.join(tmpdir, 'emotions.db')
            persistence = EmotionPersistence(db_path=db_path)
            decay_system = DecaySystem(tick_interval_seconds=60)
            
            # Create a state with high excitement (should decay)
            original = EmotionalState(excitement=0.9)
            persistence.save_state(original)
            
            # Simulate being offline for 1 hour
            # We need to manually set the timestamp in the database
            conn = sqlite3.connect(db_path)
            cursor = conn.cursor()
            one_hour_ago = (datetime.utcnow() - timedelta(hours=1)).isoformat()
            cursor.execute(
                'UPDATE emotional_state SET timestamp = ? ORDER BY id DESC LIMIT 1',
                (one_hour_ago,)
            )
            conn.commit()
            conn.close()
            
            # Restore and age
            aged = persistence.restore_and_age_state(decay_system)
            
            # Excitement should be lower (decayed)
            assert aged is not None
            assert aged.excitement < 0.9


class TestInteractionLogging:
    """Test interaction logging and history."""
    
    def test_log_interaction(self):
        """Should log interaction with before/after states."""
        with tempfile.TemporaryDirectory() as tmpdir:
            db_path = os.path.join(tmpdir, 'emotions.db')
            persistence = EmotionPersistence(db_path=db_path)
            
            state_before = EmotionalState(excitement=0.5)
            state_after = EmotionalState(excitement=0.7)
            
            effects = {
                'interaction_type': 'positive_message',
                'emotions_changed': {'excitement': {'delta': 0.2, 'new_value': 0.7}},
            }
            
            result = persistence.log_interaction(
                InteractionType.POSITIVE_MESSAGE,
                state_before,
                state_after,
                effects,
                user_message="That's awesome!",
                confidence_level=0.95,
            )
            
            assert result
    
    def test_retrieve_interaction_history(self):
        """Should retrieve logged interactions."""
        with tempfile.TemporaryDirectory() as tmpdir:
            db_path = os.path.join(tmpdir, 'emotions.db')
            persistence = EmotionPersistence(db_path=db_path)
            
            # Log multiple interactions
            state_before = EmotionalState()
            state_after = EmotionalState(excitement=0.7)
            effects = {'interaction_type': 'positive_message'}
            
            persistence.log_interaction(
                InteractionType.POSITIVE_MESSAGE,
                state_before,
                state_after,
                effects,
            )
            persistence.log_interaction(
                InteractionType.ERROR_OCCURRED,
                state_after,
                EmotionalState(frustration=0.7),
                effects,
            )
            
            history = persistence.get_interaction_history()
            
            assert len(history) >= 2
            assert history[0]['interaction_type'] == 'error_occurred'  # Most recent


class TestBackupAndRecovery:
    """Test backup snapshot and recovery."""
    
    def test_create_backup_snapshot(self):
        """Should create backup snapshots."""
        with tempfile.TemporaryDirectory() as tmpdir:
            db_path = os.path.join(tmpdir, 'emotions.db')
            persistence = EmotionPersistence(db_path=db_path)
            
            state = EmotionalState(loneliness=0.8)
            persistence.create_backup_snapshot(state, snapshot_type="manual")
            
            # Should be in database
            conn = sqlite3.connect(db_path)
            cursor = conn.cursor()
            cursor.execute('SELECT COUNT(*) FROM state_snapshots')
            count = cursor.fetchone()[0]
            conn.close()
            
            assert count >= 1
    
    def test_restore_from_backup(self):
        """Should restore state from backup."""
        with tempfile.TemporaryDirectory() as tmpdir:
            db_path = os.path.join(tmpdir, 'emotions.db')
            persistence = EmotionPersistence(db_path=db_path)
            
            state = EmotionalState(
                loneliness=0.8,
                excitement=0.3,
                frustration=0.5
            )
            persistence.create_backup_snapshot(state)
            
            # Restore
            restored = persistence.restore_from_backup()
            
            assert restored is not None
            assert restored.loneliness == 0.8
            assert restored.excitement == 0.3


# tests/test_emotion_integration.py
import pytest
import tempfile
import os
from datetime import datetime, timedelta
from src.emotion.models import EmotionalState
from src.emotion.decay import DecaySystem
from src.emotion.interactions import InteractionHandler, InteractionType
from src.emotion.persistence import EmotionPersistence
from src.emotion.modulation import PersonalityModulator


class TestEmotionSystemE2E:
    """End-to-end test of entire emotional system."""
    
    def test_full_lifecycle(self):
        """Complete emotional system lifecycle: create → decay → interact → save → restore."""
        with tempfile.TemporaryDirectory() as tmpdir:
            db_path = os.path.join(tmpdir, 'emotions.db')
            traits_file = os.path.join(
                os.path.dirname(__file__), 
                '..', 'src', 'emotion', 'personality_traits.yaml'
            )
            
            # Initialize all systems
            decay = DecaySystem(tick_interval_seconds=60)
            handler = InteractionHandler()
            persistence = EmotionPersistence(db_path=db_path)
            modulator = PersonalityModulator(traits_file=traits_file)
            
            # Start with fresh state
            state = EmotionalState()
            
            # Apply some interactions
            state, log1 = handler.apply_interaction(state, InteractionType.POSITIVE_MESSAGE)
            persistence.log_interaction(
                InteractionType.POSITIVE_MESSAGE,
                EmotionalState(),
                state,
                log1,
            )
            
            # Apply decay
            state = decay.apply_decay(state)
            
            # Save state
            assert persistence.save_state(state)
            
            # Simulate restart (restore and age)
            restored = persistence.restore_and_age_state(decay)
            assert restored is not None
            
            # Get modulation for response
            params = modulator.modulate(restored)
            assert params.sarcasm_level >= 0.0
            assert params.sarcasm_level <= 1.0
    
    def test_emotional_arc_over_time(self):
        """Simulate emotional progression over simulated hours."""
        with tempfile.TemporaryDirectory() as tmpdir:
            db_path = os.path.join(tmpdir, 'emotions.db')
            
            decay = DecaySystem(tick_interval_seconds=300)  # 5-min ticks
            handler = InteractionHandler()
            persistence = EmotionPersistence(db_path=db_path)
            
            state = EmotionalState()
            
            # Simulate 24 hours of activity
            # Morning: positive interaction
            state, _ = handler.apply_interaction(state, InteractionType.POSITIVE_MESSAGE)
            
            # Apply 4 hours of decay
            for _ in range(48):  # 48 ticks * 5 min = 4 hours
                state = decay.apply_decay(state, idle_time_seconds=0)
            
            morning_excitement = state.excitement
            
            # Afternoon: error
            state, _ = handler.apply_interaction(state, InteractionType.ERROR_OCCURRED)
            afternoon_frustration = state.frustration
            
            # Evening: idle for 8 hours
            for _ in range(96):  # 96 ticks * 5 min = 8 hours
                state = decay.apply_decay(state, idle_time_seconds=3600, force_idle=True)
            
            # After idle, loneliness should be higher
            evening_loneliness = state.loneliness
            
            assert evening_loneliness > 0.5  # More lonely after idle
            assert afternoon_frustration > 0.5  # Frustrated from error
            assert morning_excitement > 0.5  # Started excited
```

---

## Task 3: Update src/emotion/__init__.py with all exports

**File:** `src/emotion/__init__.py`

Update to include all emotion system modules:

```python
# src/emotion/__init__.py
from .models import EmotionalState
from .decay import DecaySystem, DecayTuner
from .interactions import InteractionType, InteractionHandler, EmotionInteractionAnalyzer
from .modulation import PersonalityModulator, ModulationParameters
from .persistence import EmotionPersistence

__all__ = [
    'EmotionalState',
    'DecaySystem',
    'DecayTuner',
    'InteractionType',
    'InteractionHandler',
    'EmotionInteractionAnalyzer',
    'PersonalityModulator',
    'ModulationParameters',
    'EmotionPersistence',
]
```

---

## Task 4: Verify full integration and run all tests

**Action:**

1. Run all emotion system tests:
   ```bash
   cd /home/mystiatech/projects/Demi
   python -m pytest tests/test_emotion_*.py -v
   ```

2. Verify all 60+ tests pass (Plans 03-01 + 03-02 + 03-03 + 03-04)

**Expected Output:** All emotion system tests pass without errors.

---

## Definition of Done

- [x] `src/emotion/persistence.py` created with EmotionPersistence class
- [x] `tests/test_emotion_persistence.py` created with 6+ persistence tests
- [x] `tests/test_emotion_integration.py` created with E2E tests
- [x] Offline decay simulation working (aged states on restore)
- [x] Interaction logging with full audit trail
- [x] Backup/recovery mechanisms for data integrity
- [x] All 60+ tests pass (complete Phase 03)
- [x] src/emotion/__init__.py exports all modules

---

## Phase 03 Success Criteria Verification

✅ **Emotional State Model** (Plan 01)
- 9 dimensions with 0-1 scale
- Momentum tracking for cascade effects
- Serializable for database

✅ **Decay & Interaction System** (Plan 02)
- 5-minute background decay ticks
- Emotion-specific decay rates
- Idle effects that accumulate
- 8 interaction types mapped to emotional deltas

✅ **Personality Modulation** (Plan 03)
- 60-100% variance from baseline
- Situational gates for serious contexts
- Self-awareness commentary
- Ready for LLM injection (Phase 4)

✅ **Persistence & Validation** (Plan 04)
- Save/restore emotional state
- Offline decay simulation
- Interaction logging
- Backup/recovery
- E2E integration tests

---

## Notes for Phase 04

- Phase 04 (LLM Integration) will inject ModulationParameters into prompts
- Interaction logs provide training data for understanding effect sizes
- Backup snapshots can be used for A/B testing emotion tuning
- All emotion system APIs are ready for Phase 4 integration
