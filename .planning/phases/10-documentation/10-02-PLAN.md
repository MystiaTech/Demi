# Phase 10.02: API Documentation

**Phase:** 10 - Documentation & Polish  
**Plan:** 10-02  
**Type:** Documentation  
**Estimated Time:** 4-6 hours  
**Depends On:** All API implementations complete

---

## Goal

Create comprehensive API documentation for developers who want to integrate with or extend Demi. Document all REST endpoints, WebSocket protocols, and Python SDK interfaces with practical examples.

**Purpose:** Enable third-party integrations and developer contributions

**Output:** Complete API reference with interactive examples

---

## Context

Demi exposes multiple APIs:
- **REST API** (FastAPI): Authentication, status, messages
- **WebSocket API**: Real-time bidirectional messaging
- **Python SDK**: Internal module interfaces

The documentation should cover authentication, rate limits, error handling, and provide working code examples.

---

## Tasks

### Task 1: Set Up API Documentation Structure

**Files:** `docs/api/`

**Structure:**
```
docs/api/
├── README.md              # API overview
├── authentication.md      # Auth flows & token management
├── rest-api.md           # REST endpoint reference
├── websocket-api.md      # WebSocket protocol
├── python-sdk.md         # Python SDK reference
├── examples/             # Code examples
│   ├── python/
│   ├── javascript/
│   └── curl/
└── schemas/              # JSON schemas
```

**Verify:** Directory structure matches actual API implementation

**Done:** API documentation structure created

---

### Task 2: Document Authentication System

**File:** `docs/api/authentication.md`

**Content Sections:**

1. **Overview**
   - JWT-based authentication
   - Access tokens vs refresh tokens
   - Session management
   - Security considerations

2. **Getting Tokens**

```bash
# Login to get access and refresh tokens
curl -X POST http://localhost:8000/api/v1/auth/login \
  -H "Content-Type: application/json" \
  -d '{
    "email": "user@example.com",
    "password": "your-password",
    "device_name": "My Device",
    "device_fingerprint": "unique-device-id"
  }'
```

**Response:**
```json
{
  "access_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
  "refresh_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
  "token_type": "bearer",
  "expires_in": 1800,
  "refresh_expires_in": 604800,
  "user_id": "uuid-1234",
  "email": "user@example.com",
  "session_id": "session-uuid-5678"
}
```

3. **Using Access Tokens**

```bash
# Include in Authorization header
curl http://localhost:8000/api/v1/status \
  -H "Authorization: Bearer eyJhbGciOiJIUzI1NiIs..."
```

4. **Refreshing Tokens**

```bash
# Get new access token using refresh token
curl -X POST http://localhost:8000/api/v1/auth/refresh \
  -H "Content-Type: application/json" \
  -d '{
    "refresh_token": "eyJhbGciOiJIUzI1NiIs..."
  }'
```

5. **Token Expiration**
   - Access tokens: 30 minutes
   - Refresh tokens: 7 days
   - Handling expiration gracefully

6. **Session Management**

```bash
# List active sessions
curl http://localhost:8000/api/v1/auth/sessions \
  -H "Authorization: Bearer <access_token>"

# Revoke a session
curl -X DELETE http://localhost:8000/api/v1/auth/sessions/<session_id> \
  -H "Authorization: Bearer <access_token>"
```

**Verify:** All authentication endpoints tested with real requests

**Done:** Complete authentication documentation

---

### Task 3: Document REST API Endpoints

**File:** `docs/api/rest-api.md`

**Endpoint Documentation Format:**

For each endpoint, document:
- HTTP method and path
- Authentication required?
- Request parameters/body
- Response format
- Error codes
- Example requests

**Endpoints to Document:**

#### Status Endpoints

```markdown
### GET /api/v1/status
Get Demi's current status and emotional state.

**Auth:** Optional (includes emotional state if authenticated)

**Response (Unauthenticated):**
```json
{
  "status": "operational",
  "version": "1.0.0",
  "uptime_seconds": 3600,
  "platforms": {
    "discord": "connected",
    "android": "connected",
    "voice": "disabled"
  }
}
```

**Response (Authenticated):**
```json
{
  "status": "operational",
  "version": "1.0.0",
  "uptime_seconds": 3600,
  "platforms": {...},
  "emotional_state": {
    "loneliness": 3.5,
    "excitement": 7.2,
    "frustration": 1.1,
    "jealousy": 2.0,
    "affection": 6.8
  },
  "current_mood": "chatty"
}
```
```

#### Authentication Endpoints

```markdown
### POST /api/v1/auth/login
Authenticate and receive tokens.

**Auth:** None

**Request Body:**
| Field | Type | Required | Description |
|-------|------|----------|-------------|
| email | string | Yes | User email |
| password | string | Yes | User password |
| device_name | string | No | Device identifier |
| device_fingerprint | string | No | Unique device ID |

**Response:** TokenResponse object

**Errors:**
- `401`: Invalid credentials
- `423`: Account locked
- `400`: Missing required fields
```

```markdown
### POST /api/v1/auth/refresh
Refresh access token.

**Auth:** None (requires refresh token)

**Request Body:**
| Field | Type | Required |
|-------|------|----------|
| refresh_token | string | Yes |

**Response:** New TokenResponse

**Errors:**
- `401`: Invalid or expired refresh token
```

```markdown
### GET /api/v1/auth/sessions
List all active sessions for the user.

**Auth:** Required

**Response:**
```json
{
  "sessions": [
    {
      "session_id": "session-1234",
      "device_name": "Pixel 7",
      "created_at": "2026-02-01T10:00:00Z",
      "last_activity": "2026-02-01T15:30:00Z",
      "expires_at": "2026-02-08T10:00:00Z",
      "is_active": true,
      "is_current": true
    }
  ],
  "total_count": 1
}
```
```

```markdown
### DELETE /api/v1/auth/sessions/{session_id}
Revoke a specific session.

**Auth:** Required

**Path Parameters:**
| Parameter | Type | Description |
|-----------|------|-------------|
| session_id | string | Session to revoke |

**Response:** `204 No Content`

**Errors:**
- `404`: Session not found
- `403`: Cannot revoke another user's session
```

#### Message Endpoints (REST Polling)

```markdown
### GET /api/v1/messages
Get conversation history (polling alternative to WebSocket).

**Auth:** Required

**Query Parameters:**
| Parameter | Type | Default | Description |
|-----------|------|---------|-------------|
| conversation_id | string | user_id | Conversation to fetch |
| days | int | 7 | Days of history |
| limit | int | 100 | Max messages |
| before | string | - | ISO timestamp for pagination |

**Response:**
```json
{
  "messages": [
    {
      "message_id": "msg-1234",
      "conversation_id": "conv-5678",
      "sender": "demi",
      "content": "How delightful that you seek my attention...",
      "emotion_state": {"loneliness": 2.5, "excitement": 6.0},
      "status": "read",
      "created_at": "2026-02-01T15:30:00Z"
    }
  ],
  "has_more": true,
  "next_cursor": "2026-01-30T10:00:00Z"
}
```
```

```markdown
### POST /api/v1/messages
Send a message via REST (alternative to WebSocket).

**Auth:** Required

**Request Body:**
```json
{
  "content": "Hello Demi!",
  "conversation_id": "optional-conv-id"
}
```

**Response:**
```json
{
  "user_message": {...},
  "demi_response": {...},
  "processing_time_ms": 1250
}
```

**Errors:**
- `400`: Empty message content
- `429`: Rate limited
```

#### Autonomy Endpoints

```markdown
### GET /api/v1/autonomy/rambles
Get ramble history and configuration.

**Auth:** Required

**Response:**
```json
{
  "enabled": true,
  "last_ramble": "2026-02-01T14:00:00Z",
  "recent_rambles": [...],
  "triggers": {
    "loneliness_threshold": 7.0,
    "excitement_threshold": 8.0
  }
}
```
```

**Verify:** All endpoints tested with actual API

**Done:** Complete REST API reference

---

### Task 4: Document WebSocket API

**File:** `docs/api/websocket-api.md`

**Content Sections:**

1. **Overview**
   - Real-time bidirectional messaging
   - Connection lifecycle
   - Reconnection handling
   - Authentication via query parameter

2. **Connection**

```javascript
// Connect to WebSocket
const token = 'your-jwt-access-token';
const ws = new WebSocket(`ws://localhost:8000/api/v1/chat/ws?token=${token}`);

ws.onopen = () => {
  console.log('Connected to Demi');
};

ws.onmessage = (event) => {
  const data = JSON.parse(event.data);
  console.log('Received:', data);
};

ws.onclose = () => {
  console.log('Disconnected');
};
```

3. **Client-to-Server Events**

```markdown
### message
Send a message to Demi.

```json
{
  "event": "message",
  "data": {
    "content": "Hello Demi!"
  }
}
```

### read_receipt
Mark a message as read.

```json
{
  "event": "read_receipt",
  "data": {
    "message_id": "msg-uuid-1234"
  }
}
```

### ping
Keepalive ping.

```json
{
  "event": "ping"
}
```
```

4. **Server-to-Client Events**

```markdown
### history
Sent immediately after connection with conversation history.

```json
{
  "event": "history",
  "data": {
    "messages": [...],
    "count": 50
  }
}
```

### message
Demi's response to user message.

```json
{
  "event": "message",
  "data": {
    "message_id": "msg-uuid-5678",
    "conversation_id": "conv-uuid",
    "sender": "demi",
    "content": "How delightful...",
    "emotion_state": {"loneliness": 2.0, "excitement": 5.5},
    "status": "sent",
    "created_at": "2026-02-01T15:30:00Z"
  },
  "timestamp": "2026-02-01T15:30:00Z"
}
```

### typing
Typing indicator from Demi.

```json
{
  "event": "typing",
  "data": {
    "is_typing": true
  }
}
```

### delivered
Message delivered confirmation.

```json
{
  "event": "delivered",
  "data": {
    "message_id": "msg-uuid-1234"
  }
}
```

### pong
Keepalive response.

```json
{
  "event": "pong"
}
```

### error
Error message.

```json
{
  "event": "error",
  "data": {
    "message": "Error generating response",
    "code": "inference_error"
  }
}
```
```

5. **Complete Example: Chat Client**

```javascript
class DemiClient {
  constructor(baseUrl, token) {
    this.baseUrl = baseUrl;
    this.token = token;
    this.ws = null;
    this.reconnectAttempts = 0;
    this.maxReconnectAttempts = 5;
  }

  connect() {
    this.ws = new WebSocket(
      `${this.baseUrl}/api/v1/chat/ws?token=${this.token}`
    );

    this.ws.onopen = () => {
      console.log('Connected to Demi');
      this.reconnectAttempts = 0;
    };

    this.ws.onmessage = (event) => {
      const msg = JSON.parse(event.data);
      this.handleMessage(msg);
    };

    this.ws.onclose = () => {
      this.attemptReconnect();
    };
  }

  sendMessage(content) {
    if (this.ws?.readyState === WebSocket.OPEN) {
      this.ws.send(JSON.stringify({
        event: 'message',
        data: { content }
      }));
    }
  }

  markAsRead(messageId) {
    this.ws.send(JSON.stringify({
      event: 'read_receipt',
      data: { message_id: messageId }
    }));
  }

  attemptReconnect() {
    if (this.reconnectAttempts < this.maxReconnectAttempts) {
      this.reconnectAttempts++;
      setTimeout(() => this.connect(), 5000);
    }
  }

  handleMessage(msg) {
    switch (msg.event) {
      case 'message':
        console.log('Demi:', msg.data.content);
        break;
      case 'typing':
        console.log('Demi is typing...');
        break;
      case 'history':
        console.log('Loaded history:', msg.data.count, 'messages');
        break;
    }
  }
}

// Usage
const client = new DemiClient('ws://localhost:8000', 'your-token');
client.connect();
client.sendMessage('Hello Demi!');
```

6. **Error Handling**
   - Connection failures
   - Authentication errors
   - Reconnection strategy
   - Rate limiting

**Verify:** WebSocket examples tested with actual implementation

**Done:** Complete WebSocket API documentation

---

### Task 5: Document Python SDK

**File:** `docs/api/python-sdk.md`

**Content Sections:**

1. **Overview**
   - SDK for extending Demi
   - Module structure
   - Async/await patterns
   - Error handling

2. **Core Modules**

```markdown
### Configuration (`src.core.config`)

```python
from src.core.config import DemiConfig

# Load configuration
config = DemiConfig.load('path/to/config.yaml')

# Access settings
print(config.system['log_level'])
print(config.platforms['discord']['enabled'])

# Runtime updates
config.update('system', 'debug', True)
```

### Logger (`src.core.logger`)

```python
from src.core.logger import get_logger

logger = get_logger()
logger.info("Application started")
logger.debug("Debug information")
```

### Conductor (`src.conductor`)

```python
from src.conductor import get_conductor

conductor = get_conductor(config)
await conductor.startup()

# Request inference
response = await conductor.request_inference_for_platform(
    platform='custom_integration',
    user_id='user-123',
    content='Hello!',
    context={'source': 'custom'}
)
```

### Emotional System (`src.emotional`)

```python
from src.emotional.state import EmotionEngine

engine = EmotionEngine()

# Get current state
state = engine.get_current_state()
print(f"Loneliness: {state.loneliness}")

# Trigger emotional updates
engine.on_interaction(positive=True)
engine.on_error_occurred()

# Save/load state
engine.persist_state()
engine.load_state()
```
```

3. **Building Custom Integrations**

```markdown
### Creating a Platform Integration

```python
from src.platforms.base import PlatformIntegration

class CustomIntegration(PlatformIntegration):
    def __init__(self, config):
        super().__init__(config)
        self.name = 'custom'
    
    async def startup(self):
        # Initialize connection
        await self.connect()
        return True
    
    async def shutdown(self):
        # Cleanup
        await self.disconnect()
    
    async def send_message(self, user_id, content):
        # Send message to platform
        pass
    
    async def handle_incoming(self, message):
        # Process incoming message
        response = await self.conductor.request_inference_for_platform(
            platform=self.name,
            user_id=message.user_id,
            content=message.content,
            context={'source': self.name}
        )
        await self.send_message(message.user_id, response['content'])
```
```

4. **Database Access**

```markdown
### SQLite Database

```python
from src.database.connection import get_db

async with get_db() as db:
    # Query emotional state
    state = await db.get_emotional_state()
    
    # Log interaction
    await db.log_interaction(
        platform='discord',
        user_id='user-123',
        content='Hello',
        emotion_snapshot=state.to_dict()
    )
```
```

5. **LLM Integration**

```markdown
### Direct LLM Access

```python
from src.llm.client import LLMClient

client = LLMClient(config.llm)

# Generate response
response = await client.generate(
    prompt="Tell me a joke",
    system_prompt="You are a helpful assistant",
    temperature=0.7
)

# Streaming (if supported)
async for chunk in client.generate_stream(prompt="Tell me a story"):
    print(chunk, end='')
```
```

**Verify:** All SDK examples tested and functional

**Done:** Complete Python SDK reference

---

### Task 6: Create Code Examples

**Files:** `docs/api/examples/`

**Examples to Create:**

1. **Python Examples**
   - Basic bot integration
   - Custom platform connector
   - Automated message sender
   - Emotion monitoring tool

2. **JavaScript Examples**
   - WebSocket chat client
   - React component for chat
   - Node.js bot integration

3. **cURL Examples**
   - Authentication flow
   - Sending messages
   - Session management

**Verify:** All examples tested and working

**Done:** Example code library for all major use cases

---

## Verification

1. **Completeness:**
   - [ ] Every endpoint documented
   - [ ] All parameters explained
   - [ ] All error codes listed
   - [ ] Authentication flow clear

2. **Accuracy:**
   - [ ] All examples tested
   - [ ] Response schemas match implementation
   - [ ] Error scenarios verified

3. **Usability:**
   - [ ] Examples are copy-paste ready
   - [ ] Multiple language examples provided
   - [ ] Clear progression from simple to complex

---

## Success Criteria

1. **Complete Coverage:**
   - ✅ All REST endpoints documented with examples
   - ✅ WebSocket protocol fully specified
   - ✅ Python SDK reference complete
   - ✅ Authentication flows explained

2. **Practical Examples:**
   - ✅ Working code for every major operation
   - ✅ Examples in multiple languages (Python, JS, cURL)
   - ✅ Complete chat client implementation

3. **Developer-Friendly:**
   - ✅ Clear parameter descriptions
   - ✅ Error handling documented
   - ✅ Rate limits specified
   - ✅ Copy-paste ready examples

4. **Maintainability:**
   - ✅ Easy to update when API changes
   - ✅ Links to source code where appropriate
   - ✅ Versioned documentation

---

## Output

Create `docs/api/` directory with:
- README.md (API overview)
- authentication.md (auth flows)
- rest-api.md (REST reference)
- websocket-api.md (WebSocket protocol)
- python-sdk.md (SDK reference)
- examples/ (working code samples)

---

**Note:** API documentation should enable developers to build integrations without reading source code. Include OpenAPI/Swagger spec generation if possible.
