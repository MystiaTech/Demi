---
phase: 02-conductor-orchestrator-integration-manager
plan: 04
type: execute
wave: 3
depends_on: [02-01, 02-02]
files_modified: [src/conductor/router.py, src/conductor/isolation.py]
autonomous: true
must_haves:
  truths:
    - "Request router routes requests to appropriate platform integrations"
    -Load balancing distributes requests across multiple platform instances"
    - "Dead letter queue handles failed requests with retry logic"
    - "Process isolation prevents platform failures from affecting system"
  artifacts:
    - path: "src/conductor/router.py"
      provides: "Request routing and load balancing system"
      contains: "class RequestRouter"
      min_lines: 60
    - path: "src/conductor/isolation.py"
      provides: "Process isolation for platform integrations"
      contains: "class IsolatedPluginRunner"
      min_lines: 50
  key_links:
    - from: "src/conductor/router.py"
      to: "src/plugins/manager.py"
      via: "plugin manager providing platform instances for routing"
      pattern: "plugin_manager\\.get_plugin"
    - from: "src/conductor/router.py"
      to: "src/conductor/isolation.py"
      via: "isolated execution for platform requests"
      pattern: "isolated_runner\\.execute"
    - from: "src/conductor/isolation.py"
      to: "src/conductor/metrics.py"
      via: "isolation metrics recording"
      pattern: "isolation_metrics\\.record"
---

<objective>
Implement the request routing and isolation system for Demi's conductor. This handles request distribution across platform integrations with load balancing, provides process isolation to prevent failures from cascading, and includes a dead letter queue for failed requests with retry logic.

Purpose: Ensure reliable request processing with isolation, load balancing, and failure recovery mechanisms.
Output: Working request router with isolation and dead letter queue functionality.
</objective>

<execution_context>
@~/.opencode/get-shit-done/workflows/execute-plan.md
@~/.opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md
@src/core/config.py
@src/conductor/metrics.py
@src/plugins/manager.py
@src/platforms/base.py
</context>

<tasks>

<task type="auto">
  <name>Create process isolation system</name>
  <files>src/conductor/isolation.py</files>
  <action>
    Create process isolation for platform plugins:
    - IsolatedPluginRunner class with asyncio subprocess management
    - Resource limits: 512MB memory, 30-second timeout per request
    - execute_request() method running plugins in isolated subprocess
    - Resource monitoring during execution with psutil
    - kill_on_timeout() for runaway processes
    - Security constraints: no network access, limited filesystem
    - Stdout/stderr capture for logging
    - Process cleanup and resource reclamation
    - Metrics integration for isolation performance
    - Error handling with detailed error messages
    - Configurable resource limits via config system
  </action>
  <verify>python -c "
import asyncio
from src.conductor.isolation import IsolatedPluginRunner
async def test():
    runner = IsolatedPluginRunner()
    result = await runner.execute_request('print(\"Hello from isolation\")', {})
    print(f'Isolation test result: {result}')
asyncio.run(test())
"</verify>
  <done>Process isolation system safely executes platform requests with resource limits</done>
</task>

<task type="auto">
  <name>Build request routing system</name>
  <files>src/conductor/router.py</files>
  <action>
    Create comprehensive request routing:
    - RequestRouter class with pattern-based routing
    - route_request() method analyzing request content and metadata
    - Load balancing across multiple plugin instances (round-robin)
    - Content-based routing (Discord commands vs Android API calls)
    - Request validation and sanitization
    - DeadLetterQueue for failed requests with exponential backoff
    - Circuit breaker integration per platform
    - Request timeout handling (5-second default)
    - Response aggregation and formatting
    - Metrics for routing performance and failure rates
    - Integration with plugin manager for platform discovery
    - Configurable routing rules via config system
  </action>
  <verify>python -c "
import asyncio
from src.conductor.router import RequestRouter
async def test():
    router = RequestRouter()
    # Test routing logic
    test_request = {'type': 'discord', 'content': 'hello'}
    route = router.determine_route(test_request)
    print(f'Route determined: {route}')
asyncio.run(test())
"</verify>
  <done>Request routing system distributes requests with load balancing and fallback handling</done>
</task>

</tasks>

<verification>
Overall verification steps:
1. Test process isolation with resource limit enforcement
2. Verify request routing logic for different platform types
3. Test load balancing across multiple instances
4. Validate dead letter queue retry logic
5. Test timeout handling and process cleanup
</verification>

<success_criteria>
- Process isolation enforces memory and time limits
- Request router correctly routes based on request content
- Load balancing distributes requests across instances
- Dead letter queue handles failed requests with retries
- System remains stable when platform requests fail
</success_criteria>

<output>
After completion, create `.planning/phases/02-conductor-orchestrator-integration-manager/02-04-SUMMARY.md`
</output>