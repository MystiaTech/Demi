---
phase: 02-conductor-orchestrator-integration-manager
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [src/platforms/__init__.py, src/platforms/base.py, src/plugins/__init__.py, src/plugins/manager.py, src/plugins/base.py, src/plugins/discovery.py]
autonomous: true
must_haves:
  truths:
    - "Platform base interface defines standard methods for all integrations"
    - "Plugin manager can discover and load platform plugins dynamically"
    - "Plugins can be initialized and shutdown cleanly through lifecycle hooks"
    - "Discovery system scans entry points and registers available plugins"
  artifacts:
    - path: "src/platforms/base.py"
      provides: "Abstract base class for platform integrations"
      contains: "class BasePlatform"
      min_lines: 30
    - path: "src/plugins/manager.py"
      provides: "Plugin lifecycle management"
      contains: "class PluginManager"
      min_lines: 50
    - path: "src/plugins/discovery.py"
      provides: "Plugin discovery via entry points"
      contains: "def discover_plugins"
      min_lines: 30
  key_links:
    - from: "src/plugins/manager.py"
      to: "src/platforms/base.py"
      via: "inheritance and interface compliance"
      pattern: "class.*BasePlatform"
    - from: "src/plugins/discovery.py"
      to: "src/plugins/manager.py"
      via: "discovery results feeding manager registry"
      pattern: "importlib\\.metadata"
---

<objective>
Create the plugin architecture foundation for Demi's conductor system. This establishes the base platform interface that all integrations will implement, along with a dynamic plugin management system that can discover, load, and manage platform integrations autonomously.

Purpose: Enable hot-swappable platform integrations with proper lifecycle management and discovery mechanisms.
Output: Working plugin system that can load platform modules through Python entry points.
</objective>

<execution_context>
@~/.opencode/get-shit-done/workflows/execute-plan.md
@~/.opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md
@src/core/config.py
@src/core/logger.py
</context>

<tasks>

<task type="auto">
  <name>Create platform base interface</name>
  <files>src/platforms/__init__.py, src/platforms/base.py</files>
  <action>
    Create src/platforms/ directory with:
    - __init__.py exporting BasePlatform
    - base.py with abstract BasePlatform class defining:
      * initialize(config: dict) -> bool
      * health_check() -> PluginHealth
      * handle_request(request: dict) -> dict
      * shutdown() -> None
      * name: str property
      * status: str property
    - Use abc.ABC for abstract methods
    - Include PluginHealth dataclass with status, response_time_ms, last_check, error_message
    - Add proper type hints throughout
  </action>
  <verify>python -c "from src.platforms.base import BasePlatform; print('Base interface loaded successfully')"</verify>
  <done>Platform base interface defined with all required methods and health data structure</done>
</task>

<task type="auto">
  <name>Implement plugin discovery system</name>
  <files>src/plugins/__init__.py, src/plugins/discovery.py</files>
  <action>
    Create plugin discovery system:
    - __init__.py exports discover_plugins function
    - discovery.py with discover_plugins() function using importlib.metadata
    - Scan for 'demi.platforms' entry points
    - Return dict of {plugin_name: plugin_class}
    - Handle discovery errors gracefully with try/catch
    - Log discovered plugins using existing logger from src.core.logger
    - Include validate_plugin_class to ensure class inherits from BasePlatform
  </action>
  <verify>python -c "from src.plugins.discovery import discover_plugins; plugins = discover_plugins(); print(f'Found {len(plugins)} plugins')"</verify>
  <done>Plugin discovery system can find and validate platform plugins through entry points</done>
</task>

<task type="auto">
  <name>Build plugin lifecycle manager</name>
  <files>src/plugins/manager.py, src/plugins/base.py</files>
  <action>
    Create comprehensive plugin manager:
    - base.py with PluginState enum and PluginMetadata dataclass
    - manager.py with PluginManager class containing:
      * __init__ with registry for loaded plugins
      * discover_and_register() method
      * load_plugin(name, config) -> plugin instance
      * unload_plugin(name) with proper cleanup
      * get_plugin(name) for access
      * list_plugins() returning metadata
      * health_check_all() running health checks on all loaded plugins
    - Use asyncio for async methods where appropriate
    - Integrate with config system for plugin configurations
    - Include proper error handling and state management
  </action>
  <verify>python -c "
import asyncio
from src.plugins.manager import PluginManager
async def test():
    pm = PluginManager()
    await pm.discover_and_register()
    print(f'Plugin manager ready with {len(pm.registry)} plugins')
asyncio.run(test())
"</verify>
  <done>Plugin manager can discover, load, unload, and monitor platform plugins with proper lifecycle management</done>
</task>

</tasks>

<verification>
Overall verification steps:
1. Create test plugin in entry_points to verify discovery
2. Load plugin through manager and check lifecycle methods
3. Verify health check integration
4. Test plugin unload and cleanup
5. Confirm error handling for invalid plugins
</verification>

<success_criteria>
- Plugin discovery finds platform plugins via entry points
- Plugin manager can load/unload plugins with proper state tracking
- Base platform interface is consistently implemented
- Health checks work through plugin manager
- Error handling prevents crashes from invalid plugins
</success_criteria>

<output>
After completion, create `.planning/phases/02-conductor-orchestrator-integration-manager/02-01-SUMMARY.md`
</output>