---
phase: 02-conductor-orchestrator-integration-manager
plan: 05
type: execute
wave: 4
depends_on: [02-01, 02-02, 02-03, 02-04]
files_modified: [src/conductor/orchestrator.py, src/conductor/__init__.py, src/__init__.py, main.py]
autonomous: true
must_haves:
  truths:
    - "Conductor orchestrator manages startup sequence and system initialization"
    - "All subsystems integrate seamlessly with proper dependency management"
    - "Health monitoring, resource scaling, and request routing work together"
    - "System can startup, run, and shutdown gracefully with all components"
  artifacts:
    - path: "src/conductor/orchestrator.py"
      provides: "Main conductor orchestrator coordinating all subsystems"
      contains: "class Conductor"
      min_lines: 80
    - path: "main.py"
      provides: "Application entry point with conductor initialization"
      contains: "async def main()"
      min_lines: 30
  key_links:
    - from: "src/conductor/orchestrator.py"
      to: "src/conductor/health.py"
      via: "health monitoring integration"
      pattern: "health_monitor\\.start"
    - from: "src/conductor/orchestrator.py"
      to: "src/conductor/scaler.py"
      via: "auto-scaling coordination"
      pattern: "predictive_scaler\\.start"
    - from: "src/conductor/orchestrator.py"
      to: "src/conductor/router.py"
      via: "request routing management"
      pattern: "request_router\\.start"
    - from: "src/conductor/orchestrator.py"
      to: "src/plugins/manager.py"
      via: "plugin lifecycle coordination"
      pattern: "plugin_manager\\.initialize"
---

<objective>
Create the main conductor orchestrator that integrates all subsystems into a cohesive system. This coordinates startup sequence, manages component lifecycle, handles graceful shutdown, and provides the central nervous system for Demi's platform integration management.

Purpose: Unify all conductor components into a working, production-ready system.
Output: Complete conductor orchestrator ready for platform integration testing.
</objective>

<execution_context>
@~/.opencode/get-shit-done/workflows/execute-plan.md
@~/.opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md
@src/core/config.py
@src/core/logger.py
@src/core/database.py
@src/conductor/health.py
@src/conductor/scaler.py
@src/conductor/router.py
@src/plugins/manager.py
</context>

<tasks>

<task type="auto">
  <name>Build main conductor orchestrator</name>
  <files>src/conductor/orchestrator.py, src/conductor/__init__.py</files>
  <action>
    Create comprehensive conductor orchestrator:
    - Conductor class coordinating all subsystems
    - __init__ initializing plugin manager, health monitor, scaler, router
    - startup() method with sequential initialization:
      1. Load configuration and initialize logging
      2. Initialize database connection
      3. Discover and register plugins
      4. Start health monitoring loop
      5. Initialize predictive scaler
      6. Start request router
      7. Enable all registered plugins
    - shutdown() method with graceful cleanup:
      1. Stop accepting new requests
      2. Disable all plugins
      3. Stop background loops (health, scaling)
      4. Close database connections
      5. Cleanup resources
    - get_status() returning overall system health
    - handle_request() main entry point for external requests
    - Component health aggregation and system-wide metrics
    - Error recovery and restart mechanisms
    - Integration with existing config and logging systems
  </action>
  <verify>python -c "
import asyncio
from src.conductor.orchestrator import Conductor
async def test():
    conductor = Conductor()
    status = await conductor.get_status()
    print(f'Conductor status: {status}')
asyncio.run(test())
"</verify>
  <done>Main conductor orchestrator coordinates all subsystems with proper lifecycle management</done>
</task>

<task type="auto">
  <name>Create application entry point</name>
  <files>main.py, src/__init__.py</files>
  <action>
    Create application entry point:
    - main.py with async main() function
    - Signal handling for SIGINT/SIGTERM (graceful shutdown)
    - Configuration validation before startup
    - Conductor initialization and startup
    - Main event loop with error handling
    - Logging configuration setup
    - Database migration/init if needed
    - Command-line argument parsing for:
      * --config file path
      * --log-level override
      * --dry-run (validation only)
      * --version
    - Exit codes for different failure scenarios
    - Startup time measurement and reporting
    - Integration with existing core systems
  </action>
  <verify>python main.py --help</verify>
  <done>Application entry point provides complete conductor lifecycle management</done>
</task>

</tasks>

<verification>
Overall verification steps:
1. Test conductor startup sequence and component initialization
2. Verify graceful shutdown with signal handling
3. Test request handling through orchestrator
4. Validate health monitoring integration
5. Test error recovery and system resilience
</verification>

<success_criteria>
- Conductor startup initializes all components in correct order
- Health monitoring, scaling, and routing work together seamlessly
- System handles requests end-to-end through orchestrator
- Graceful shutdown cleans up all resources properly
- Error handling prevents system crashes and enables recovery
</success_criteria>

<output>
After completion, create `.planning/phases/02-conductor-orchestrator-integration-manager/02-05-SUMMARY.md`
</output>