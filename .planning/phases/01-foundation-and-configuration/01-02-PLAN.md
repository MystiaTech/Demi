---
phase: 01-foundation-and-configuration
plan: 01-02
type: execute
wave: 1
depends_on: ["01-01"]
files_modified: ["src/core/logger.py"]
autonomous: true

must_haves:
  truths:
    - "Logging works with multiple severity levels"
    - "Logs are written to console and file"
    - "Exceptions are captured and logged"
  artifacts:
    - path: "src/core/logger.py"
      provides: "Advanced logging mechanism"
      min_lines: 75
  key_links:
    - from: "src/core/logger.py"
      to: "config.py"
      via: "log level configuration"
      pattern: "log_level = config\\.get_log_level"
---

<objective>
Implement a flexible, configurable logging system for Demi's core infrastructure

Purpose: Create a robust logging mechanism that supports multiple outputs, severity levels, and easy configuration

Output: Comprehensive logging module integrated with configuration system
</objective>

<execution_context>
@~/.opencode/get-shit-done/workflows/execute-plan.md
@~/.opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/core/config.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Advanced Logging Module</name>
  <files>src/core/logger.py</files>
  <action>Implement a comprehensive logging system using structlog:
    ```python
    import os
    import sys
    import logging
    import structlog
    from datetime import datetime
    from src.core.config import DemiConfig

    def configure_logger(config: DemiConfig):
        """Configure logging based on system configuration"""
        log_dir = os.path.expanduser('~/.demi/logs')
        os.makedirs(log_dir, exist_ok=True)

        # Determine log level from configuration
        log_level_map = {
            'DEBUG': logging.DEBUG,
            'INFO': logging.INFO,
            'WARNING': logging.WARNING,
            'ERROR': logging.ERROR,
            'CRITICAL': logging.CRITICAL
        }
        log_level = log_level_map.get(config.system.get('log_level', 'INFO'), logging.INFO)

        # Configure file logging with rotation by date
        log_filename = os.path.join(log_dir, f'demi_{datetime.now().strftime("%Y-%m-%d")}.log')
        file_handler = logging.FileHandler(log_filename)
        file_handler.setLevel(log_level)

        # Console handler
        console_handler = logging.StreamHandler(sys.stdout)
        console_handler.setLevel(log_level)

        # Formatter with structured information
        file_formatter = logging.Formatter(
            '%(asctime)s - %(levelname)s - %(module)s - %(message)s',
            datefmt='%Y-%m-%d %H:%M:%S'
        )
        console_formatter = logging.Formatter('%(levelname)s: %(message)s')

        file_handler.setFormatter(file_formatter)
        console_handler.setFormatter(console_formatter)

        # Root logger configuration
        logging.basicConfig(
            level=log_level,
            handlers=[file_handler, console_handler]
        )

        # Structlog configuration
        structlog.configure(
            processors=[
                structlog.stdlib.filter_by_level,  # Respect log levels
                structlog.stdlib.add_log_level,  # Add log level to event dict
                structlog.stdlib.PositionalArgumentsFormatter(),
                structlog.processors.TimeStamper(fmt='iso'),
                structlog.processors.StackInfoRenderer(),
                structlog.processors.format_exc_info,
                structlog.processors.JSONRenderer()  # JSON for machine parsing
            ],
            context_class=dict,
            logger_factory=structlog.stdlib.LoggerFactory(),
            wrapper_class=structlog.stdlib.BoundLogger,
            cache_logger_on_first_use=True,
        )

        return structlog.get_logger()

    # Global logger instance
    logger = configure_logger(DemiConfig.load())

    def log_exception(e, context=None):
        """Enhanced exception logging with optional context"""
        extra = context or {}
        logger.error(
            "Unhandled Exception",
            exc_info=sys.exc_info(),
            **extra
        )
    ```</action>
  <verify>python -c "from src.core.logger import logger; logger.info('Test logging'); logger.warning('Warning test')"</verify>
  <done>Comprehensive logging module created with file and console logging, log rotation, and structured logging support</done>
</task>

<task type="auto">
  <name>Task 2: Integrate Logging with Configuration</name>
  <files>src/core/config.py, src/core/logger.py</files>
  <action>Update configuration management to support dynamic log level changes:
    ```python
    # In src/core/config.py, add to DemiConfig class
    def update_log_level(self, new_level: str):
        """Dynamically update system log level"""
        valid_levels = ['DEBUG', 'INFO', 'WARNING', 'ERROR', 'CRITICAL']
        if new_level.upper() not in valid_levels:
            raise ValueError(f"Invalid log level: {new_level}")
        
        self.system['log_level'] = new_level.upper()
        # Trigger log reconfiguration
        from src.core.logger import configure_logger
        configure_logger(self)
    ```</action>
  <verify>python -c "from src.core.config import DemiConfig; cfg = DemiConfig.load(); cfg.update_log_level('DEBUG'); assert cfg.system['log_level'] == 'DEBUG'"</verify>
  <done>Configuration system enhanced to support dynamic log level updates and reconfiguration</done>
</task>

</tasks>

<verification>
1. Verify logging to both console and file
2. Test logging at different severity levels
3. Check log file rotation mechanism
4. Validate log message structure
5. Confirm log level can be dynamically updated
</verification>

<success_criteria>
1. Logs are written to ~/.demi/logs/ with date-based rotation
2. Console and file logging are supported
3. Log levels can be configured and changed dynamically
4. Exceptions are captured with contextual information
5. Log messages are structured and machine-parseable
</success_criteria>

<output>
Create .planning/phases/01-foundation-and-configuration/01-02-SUMMARY.md after execution
</output>