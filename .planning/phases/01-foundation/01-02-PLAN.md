---
phase: 01-foundation
plan: 02
type: execute
wave: 1
depends_on: []
files_modified: 
  - src/core/logger.py
  - src/core/config.py
autonomous: true

must_haves:
  truths:
    - "Logging works with multiple severity levels"
    - "Logs are written to console and file"
    - "Exceptions are captured and logged"
  artifacts:
    - path: src/core/logger.py
      provides: "Centralized logging mechanism"
      min_lines: 40
  key_links:
    - from: src/core/logger.py
      to: src/core/config.py
      via: "log level configuration"
      pattern: "config\\.get_log_level"
---

<objective>
Implement a robust logging system for Demi

Purpose: Create a flexible logging mechanism that supports various log levels and persistent logging
Output: Functional logging module integrated with configuration system
</objective>

<execution_context>
@~/.opencode/get-shit-done/workflows/execute-plan.md
@~/.opencode/get-shit-done/templates/python.md
</execution_context>

<context>
@.planning/01-RESEARCH.md
@.planning/phases/01-foundation/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Create Logging Module</name>
  <files>src/core/logger.py</files>
  <action>Implement a Logger class with:
- Support for log levels (DEBUG, INFO, WARNING, ERROR, CRITICAL)
- Console and file logging
- Structured log format with timestamp, level, message
- Integration with configuration system
- Contextual logging support
- Exception capture and detailed traceback

Example implementation:
```python
import logging
import sys
from logging.handlers import RotatingFileHandler

class DemiLogger:
    def __init__(self, config):
        self.logger = logging.getLogger('demi')
        self.config = config
        self._setup_logging()

    def _setup_logging(self):
        # Configure based on config
        log_level = getattr(logging, self.config.log_level.upper())
        self.logger.setLevel(log_level)
        
        # Console handler
        console_handler = logging.StreamHandler(sys.stdout)
        console_handler.setLevel(log_level)
        
        # File handler with rotation
        file_handler = RotatingFileHandler(
            'logs/demi.log', 
            maxBytes=10*1024*1024,  # 10MB
            backupCount=5
        )
        file_handler.setLevel(log_level)
        
        formatter = logging.Formatter(
            '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
        )
        console_handler.setFormatter(formatter)
        file_handler.setFormatter(formatter)
        
        self.logger.addHandler(console_handler)
        self.logger.addHandler(file_handler)

    def capture_exception(self, e):
        self.logger.exception(f"Uncaught exception: {e}")
```
  </action>
  <verify>
mkdir -p logs && python -c "
from src.core.config import ConfigManager
from src.core.logger import DemiLogger
config = ConfigManager()
logger = DemiLogger(config)
logger.logger.info('Test log')
logger.logger.error('Test error')
"
  </verify>
  <done>Logging module created with console and file logging, respecting configuration</done>
</task>

<task type="auto">
  <name>Integrate Logging with Configuration</name>
  <files>src/core/config.py</files>
  <action>Update ConfigManager to include logging configuration:
- Add log level to defaults.yaml
- Create method to dynamically adjust log levels
- Ensure log configuration can be updated at runtime

Example addition to defaults.yaml:
```yaml
logging:
  level: INFO
  file_path: ./logs/demi.log
  max_file_size_mb: 10
```

Add method to ConfigManager:
```python
def update_log_configuration(self, log_level=None):
    if log_level:
        self.config['logging']['level'] = log_level
        # Notify logger of configuration change
        self._propagate_log_config()
```
  </action>
  <verify>python -m pytest tests/test_config_logging.py</verify>
  <done>Configuration system supports dynamic log level updates</done>
</task>

<task type="checkpoint:human-verify">
  <name>Verify Logging System</name>
  <how-to-verify>
1. Check console output with different log levels
2. Verify log files are created in ./logs/
3. Test exception logging
4. Dynamically change log level and confirm behavior
  </how-to-verify>
  <resume-signal>Type "approved" or describe any issues found</resume-signal>
</task>

</tasks>

<verification>
- Logging works at multiple levels
- Logs written to console and file
- Log levels can be dynamically adjusted
- Exceptions are captured with full traceback
</verification>

<success_criteria>
1. Logging system functional
2. Multiple log levels supported
3. Logs persist to file
4. Configuration-driven log management
</success_criteria>

<output>
Create `.planning/phases/01-foundation/01-02-SUMMARY.md` after successful execution
</output>