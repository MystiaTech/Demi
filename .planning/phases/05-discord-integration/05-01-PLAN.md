---
phase: 05-discord-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/integrations/discord_bot.py
  - src/integrations/__init__.py
autonomous: true
user_setup:
  - service: discord
    why: "Discord bot integration for Demi"
    env_vars:
      - name: DISCORD_BOT_TOKEN
        source: "Discord Developer Portal → Applications → [Your App] → Bot → Copy Token"
    dashboard_config:
      - task: "Create Discord application in Discord Developer Portal"
        location: "https://discord.com/developers/applications"
      - task: "Add OAuth2 scopes (bot) and permissions (Send Messages, Embed Links, Read Message History)"
        location: "OAuth2 section → Scopes & Permissions"

must_haves:
  truths:
    - "Discord bot logs in successfully and appears online in server"
    - "Bot receives @mention in channel and routes to Conductor"
    - "Bot receives DM message and routes to Conductor"
    - "Responses from LLM pipeline are sent back via Discord message"
  artifacts:
    - path: "src/integrations/discord_bot.py"
      provides: "DiscordBot platform plugin with message handlers"
      exports: ["DiscordBot"]
    - path: "src/integrations/__init__.py"
      provides: "Discord bot registration in integrations module"
      exports: ["DiscordBot"]
  key_links:
    - from: "src/integrations/discord_bot.py"
      to: "src/conductor/orchestrator.py"
      via: "conductor.request_inference() call in on_message handler"
      pattern: "await.*conductor\\.request_inference"
    - from: "src/integrations/discord_bot.py"
      to: "discord.ext.commands"
      via: "Bot class, event handlers, intents"
      pattern: "commands\\.Bot|@bot\\.event|intents\\."

---

<objective>
Create the Discord bot integration foundation that establishes connection to Discord, sets up proper intents, and implements message routing to Conductor's LLM pipeline. This is the entry point for all Discord interactions (mentions, DMs).

Purpose: Demi needs a Discord presence that listens for messages and routes them through the emotional LLM system without blocking other integrations.

Output: DiscordBot platform plugin with async message handlers, ready for response formatting in Plan 02.
</objective>

<execution_context>
@~/.opencode/get-shit-done/workflows/execute-plan.md
@.planning/phases/05-discord-integration/05-DISCOVERY.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/PROJECT.md
@DEMI_PERSONA.md
@.planning/phases/04-llm-integration/04-04-SUMMARY.md
@src/platforms/base.py
@src/conductor/orchestrator.py
@src/core/logger.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create DiscordBot platform plugin with intents and event handlers</name>
  <files>src/integrations/discord_bot.py</files>
  <action>
Create `src/integrations/discord_bot.py` with:

**Imports:**
- `from discord.ext import commands`
- `import discord`
- `from src.platforms.base import BasePlatform`
- `from src.core.logger import get_logger`
- `import os`

**Class DiscordBot(BasePlatform):**
- `name = "discord"`
- `__init__(self)`: Initialize with logger, bot=None, token=None
- `async initialize(self, conductor)`:
  1. Load token from env var DISCORD_BOT_TOKEN (raise error if missing)
  2. Create discord intents: `intents = discord.Intents.default()`
     - Set `intents.message_content = True` (required for message.content)
     - Set `intents.guilds = True`
     - Set `intents.direct_messages = True`
  3. Create bot: `self.bot = commands.Bot(command_prefix="!", intents=intents)`
  4. Register event handlers via decorators:
     - `@self.bot.event async def on_ready()`: Log "Discord bot connected as {bot.user}"
     - `@self.bot.event async def on_message(message)`: Implement message routing (see Task 2)
  5. Store conductor reference: `self.conductor = conductor`
  6. Log successful initialization
  7. Start bot in background (do NOT block): Use `asyncio.create_task(self.bot.start(self.token))`
     - NOTE: discord.py event loop integration is complex; we'll use create_task to avoid blocking conductor

- `async shutdown(self)`:
  1. If bot is running, call `await self.bot.close()`
  2. Log shutdown complete

- `async health_check(self) -> bool`:
  1. Return `self.bot.is_ready()` if bot exists, False otherwise
  2. Log health status

**Implementation notes:**
- Do NOT call `bot.run(token)` - this blocks forever. Use `bot.start(token)` via asyncio.create_task
- Verify token is valid by checking bot connection in on_ready event
- Handle missing DISCORD_BOT_TOKEN gracefully with clear error message
- Log all state transitions (initialization, ready, shutdown)
  </action>
  <verify>
1. Import discord_bot module: `python3 -c "from src.integrations.discord_bot import DiscordBot; print('Import OK')"`
2. Run test bot initialization (will need mock Conductor):
   - Create temporary test script that instantiates DiscordBot
   - Verify no import errors
   - Verify intents are set correctly (print to confirm)
3. Check environment variable handling:
   - Run without DISCORD_BOT_TOKEN set → should raise error with message
   - Run with DISCORD_BOT_TOKEN="" → should raise error with message
  </verify>
  <done>
- DiscordBot class exists and implements BasePlatform interface
- Intents configured correctly (message_content, guilds, direct_messages)
- Event handlers registered (on_ready, on_message)
- Token loaded from DISCORD_BOT_TOKEN env var
- Bot lifecycle methods (initialize, shutdown, health_check) implemented
- No import errors, ready for Task 2
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement message routing from Discord to Conductor LLM pipeline</name>
  <files>src/integrations/discord_bot.py</files>
  <action>
In `src/integrations/discord_bot.py`, implement the `on_message` event handler:

```python
@self.bot.event
async def on_message(message):
    # Ignore bot's own messages
    if message.author == self.bot.user:
        return
    
    # Ignore other bots
    if message.author.bot:
        return
    
    # Check if message is a mention or DM
    is_mention = self.bot.user.mentioned_in(message)
    is_dm = isinstance(message.channel, discord.DMChannel)
    
    if not (is_mention or is_dm):
        return  # Ignore messages not directed at Demi
    
    # Extract context
    user_id = str(message.author.id)
    guild_id = str(message.guild.id) if message.guild else None
    channel_id = str(message.channel.id)
    
    # Extract message content (remove bot mention if present)
    content = message.content
    if is_mention:
        # Strip bot mention from content
        for mention_str in [f"<@{self.bot.user.id}>", f"<@!{self.bot.user.id}>"]:
            content = content.replace(mention_str, "").strip()
    
    # Log interaction
    self.logger.info(
        f"Discord message received",
        user_id=user_id,
        guild_id=guild_id,
        is_dm=is_dm,
        content_length=len(content)
    )
    
    # Skip empty messages after mention removal
    if not content or len(content) == 0:
        return
    
    try:
        # Show typing indicator (improves UX)
        async with message.channel.typing():
            # Route through Conductor
            response = await self.conductor.request_inference(
                platform="discord",
                user_id=user_id,
                content=content,
                context={
                    "guild_id": guild_id,
                    "channel_id": channel_id,
                    "is_dm": is_dm,
                    "author_name": str(message.author),
                    "message_timestamp": message.created_at.isoformat(),
                }
            )
        
        # Send response (Task 3 will add formatting)
        response_text = response.get("content", "Error generating response")
        await message.reply(response_text, mention_author=False)
        
        self.logger.info(
            f"Discord response sent",
            user_id=user_id,
            response_length=len(response_text)
        )
    
    except Exception as e:
        self.logger.error(
            f"Discord message handling error: {e}",
            user_id=user_id,
            error_type=type(e).__name__
        )
        # Send error message to user
        error_msg = "Oops, something went wrong. Try again in a moment."
        await message.reply(error_msg, mention_author=False)
```

**Design notes:**
- `message.channel.typing()` shows "Demi is typing..." while LLM generates response
- `mention_author=False` prevents @mentioning user in reply (cleaner)
- Context dict captures all metadata for Conductor's routing
- Exception handling prevents Discord errors from crashing bot
- Strip bot mention from content to avoid "Hey <@Demi>" being sent to LLM
  </action>
  <verify>
1. Syntax check: `python3 -m py_compile src/integrations/discord_bot.py` (should succeed)
2. Event handler structure check:
   - Grep for `async def on_message` in file
   - Verify mentions check: `is_mention = self.bot.user.mentioned_in(message)`
   - Verify DM check: `isinstance(message.channel, discord.DMChannel)`
   - Verify Conductor call: `await self.conductor.request_inference`
3. Test mock (will be done in integration tests):
   - Mock message object with mention
   - Verify on_message extracts content correctly
   - Verify Conductor is called with correct parameters
  </verify>
  <done>
- on_message event handler implemented
- Mention detection working (checks both <@id> and <@!id> formats)
- DM detection working (discord.DMChannel check)
- Bot mention stripped from content before LLM
- Conductor.request_inference() called with platform="discord" and proper context
- Error handling in place (try/except with user-facing message)
- Typing indicator shown during LLM inference
- Ready for Plan 02 (response formatting with embeds)
  </done>
</task>

<task type="auto">
  <name>Task 3: Register DiscordBot as Conductor platform plugin</name>
  <files>src/integrations/__init__.py</files>
  <action>
Update `src/integrations/__init__.py` to:

1. Import DiscordBot: `from .discord_bot import DiscordBot`
2. Add to exports: Add "DiscordBot" to __all__ list (create if doesn't exist)
3. Example:
   ```python
   from .discord_bot import DiscordBot
   
   __all__ = ["DiscordBot"]
   ```

This enables plugin discovery via entry points (Conductor will find it).

Also verify that `setup.py` or `pyproject.toml` has entry point configured:
```
[options.entry_points]
demi.integrations =
    discord = src.integrations:DiscordBot
```

If entry point not present, add it (will be verified in orchestrator integration test).
  </action>
  <verify>
1. Import check: `python3 -c "from src.integrations import DiscordBot; print('Import OK')"`
2. Entry point check: `python3 -m importlib.metadata entry_points()` should show demi.integrations group
3. Plugin discovery: Run Conductor's plugin manager to verify DiscordBot is discoverable
  </verify>
  <done>
- DiscordBot exported from integrations module
- Entry point registered (if using setup.py/pyproject.toml)
- Conductor can discover and load DiscordBot plugin
- Ready for Plan 02 (response formatting)
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Bot Connection:** Start bot with valid token → should connect and show "Discord bot connected as Demi#..."
2. **Message Routing:** Send @mention in test channel → verify log shows "Discord message received" + context
3. **DM Routing:** Send DM to Demi → verify log shows "Discord message received" + is_dm=true
4. **Conductor Integration:** Verify Conductor logs show "discord" platform in request_inference calls
5. **Error Handling:** Send mention without content after stripping → should be silently ignored (no error sent)

All 3 tasks must complete before Plan 02 starts.
</verification>

<success_criteria>
- DiscordBot class created and implements BasePlatform interface
- Discord intents configured (message_content, guilds, direct_messages)
- Message handlers (on_ready, on_message) implemented
- Mention and DM detection working correctly
- Message content cleaned (bot mention stripped)
- Conductor.request_inference() called for all messages
- Error handling prevents Discord errors from cascading
- Plugin registered in integrations module
- No import errors, all syntax valid
</success_criteria>

<output>
After completion, create `.planning/phases/05-discord-integration/05-01-SUMMARY.md`
</output>

---
