---
phase: 05-discord-integration
plan: 03
type: execute
wave: 3
depends_on: ["05-02"]
files_modified:
  - src/integrations/discord_bot.py
  - src/models/rambles.py
autonomous: true
user_setup:
  - service: discord
    why: "Ramble posting requires dedicated channel"
    dashboard_config:
      - task: "Create #demi-rambles channel in your Discord server"
        location: "Server â†’ Create Channel â†’ Name: demi-rambles"
      - task: "Get channel ID (right-click â†’ Copy Channel ID)"
        location: "Discord client"
      - task: "Set environment variable DISCORD_RAMBLE_CHANNEL_ID"
        source: "Channel ID from above"

must_haves:
  truths:
    - "Rambles are generated based on emotional triggers (loneliness > 0.7, excitement > 0.8, etc.)"
    - "Rambles are posted to configured #demi-rambles channel automatically"
    - "Each ramble logged to database with timestamp, content, emotion state"
    - "Ramble system checks every 15 minutes and posts 0-1 per check (prevents spam)"
  artifacts:
    - path: "src/integrations/discord_bot.py"
      provides: "RambleTask with @tasks.loop and ramble decision logic"
      exports: ["RambleTask"]
    - path: "src/models/rambles.py"
      provides: "Ramble model and database storage"
      exports: ["Ramble", "RambleStore"]
  key_links:
    - from: "src/integrations/discord_bot.py"
      to: "src/integrations/discord_bot.py"
      via: "RambleTask calls conductor.request_inference()"
      pattern: "await.*conductor\\.request_inference.*ramble"

---

<objective>
Implement Demi's spontaneous ramble system - autonomous message generation triggered by emotional state that gets posted to Discord. This makes Demi feel alive and reactive, expressing her thoughts when she's lonely, excited, or frustrated.

Purpose: Rambles enable autonomy - Demi can initiate contact, express emotions, and feel present even when user isn't actively messaging. Critical for "feeling like a real person" goal.

Output: RambleTask with scheduled message generation, ramble decision logic, and database persistence.
</objective>

<execution_context>
@~/.opencode/get-shit-done/workflows/execute-plan.md
@.planning/phases/05-discord-integration/05-DISCOVERY.md
</execution_context>

<context>
@.planning/phases/05-discord-integration/05-02-SUMMARY.md
@.planning/phases/03-emotional-system/03-04-SUMMARY.md
@src/models/emotional_state.py
@DEMI_PERSONA.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Ramble model and database persistence</name>
  <files>src/models/rambles.py</files>
  <action>
Create `src/models/rambles.py`:

```python
from dataclasses import dataclass, asdict, field
from datetime import datetime
from typing import Dict, Optional
import json
import sqlite3

@dataclass
class Ramble:
    """Spontaneous message posted by Demi"""
    ramble_id: str  # UUID
    channel_id: str
    content: str
    emotion_state: Dict[str, float]  # Emotional state when ramble generated
    trigger: str  # Enum: "loneliness", "excitement", "frustration", "spontaneous"
    created_at: datetime = field(default_factory=datetime.utcnow)
    
    def to_dict(self) -> dict:
        data = asdict(self)
        data["emotion_state"] = json.dumps(data["emotion_state"])
        data["created_at"] = self.created_at.isoformat()
        return data
    
    @classmethod
    def from_dict(cls, data: dict) -> "Ramble":
        data = data.copy()
        if isinstance(data["emotion_state"], str):
            data["emotion_state"] = json.loads(data["emotion_state"])
        if isinstance(data["created_at"], str):
            data["created_at"] = datetime.fromisoformat(data["created_at"])
        return cls(**data)

class RambleStore:
    """Persistence layer for rambles"""
    
    def __init__(self, db_path: str):
        self.db_path = db_path
        self.ensure_table()
    
    def ensure_table(self):
        """Create rambles table if not exists"""
        with sqlite3.connect(self.db_path) as conn:
            conn.execute("""
            CREATE TABLE IF NOT EXISTS discord_rambles (
                ramble_id TEXT PRIMARY KEY,
                channel_id TEXT NOT NULL,
                content TEXT NOT NULL,
                emotion_state JSON NOT NULL,
                trigger TEXT NOT NULL,
                created_at TIMESTAMP NOT NULL
            )
            """)
            conn.commit()
    
    async def save(self, ramble: Ramble) -> None:
        """Save ramble to database"""
        with sqlite3.connect(self.db_path) as conn:
            conn.execute("""
            INSERT INTO discord_rambles 
            (ramble_id, channel_id, content, emotion_state, trigger, created_at)
            VALUES (?, ?, ?, ?, ?, ?)
            """, (
                ramble.ramble_id,
                ramble.channel_id,
                ramble.content,
                json.dumps(ramble.emotion_state),
                ramble.trigger,
                ramble.created_at.isoformat()
            ))
            conn.commit()
    
    async def get_recent_rambles(self, hours: int = 24) -> list[Ramble]:
        """Get rambles from last N hours"""
        with sqlite3.connect(self.db_path) as conn:
            rows = conn.execute("""
            SELECT * FROM discord_rambles
            WHERE created_at > datetime('now', ? || ' hours')
            ORDER BY created_at DESC
            """, (f"-{hours}",)).fetchall()
        
        # Convert rows to Ramble objects (column order matters)
        rambles = []
        for row in rows:
            rambles.append(Ramble(
                ramble_id=row[0],
                channel_id=row[1],
                content=row[2],
                emotion_state=json.loads(row[3]),
                trigger=row[4],
                created_at=datetime.fromisoformat(row[5])
            ))
        return rambles
```
  </action>
  <verify>
1. File exists: `ls src/models/rambles.py`
2. Import check: `python3 -c "from src.models.rambles import Ramble, RambleStore; print('OK')"`
3. Table creation: Verify sqlite table creation logic
  </verify>
  <done>
- Ramble dataclass created with all fields
- RambleStore persistence layer implemented
- Database table creation in ensure_table()
- to_dict/from_dict serialization for JSON/database
- get_recent_rambles() method for querying
- Ready for Task 2 (ramble decision logic)
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement ramble decision logic and scheduled task</name>
  <files>src/integrations/discord_bot.py</files>
  <action>
In `src/integrations/discord_bot.py`, add:

```python
from discord.ext import tasks
from datetime import datetime, timedelta
import uuid
from src.models.rambles import Ramble, RambleStore

def should_generate_ramble(
    emotion_state: Dict[str, float],
    last_ramble_time: Optional[datetime] = None,
    min_interval_minutes: int = 60
) -> tuple[bool, Optional[str]]:
    """
    Decide if Demi should post a ramble now.
    
    Rules:
    - Loneliness > 0.7 â†’ ramble (missing interaction)
    - Excitement > 0.8 â†’ ramble (feeling social)
    - Frustration > 0.6 â†’ ramble (venting)
    - Don't ramble more than every 60 minutes (prevents spam)
    
    Returns:
        (should_ramble: bool, trigger: Optional[str])
    """
    if not emotion_state:
        return False, None
    
    # Check if enough time since last ramble
    if last_ramble_time:
        if datetime.utcnow() - last_ramble_time < timedelta(minutes=min_interval_minutes):
            return False, None
    
    # Check emotional triggers
    if emotion_state.get("loneliness", 0) > 0.7:
        return True, "loneliness"
    
    if emotion_state.get("excitement", 0) > 0.8:
        return True, "excitement"
    
    if emotion_state.get("frustration", 0) > 0.6:
        return True, "frustration"
    
    return False, None

class RambleTask:
    """Scheduled task for posting spontaneous rambles"""
    
    def __init__(self, bot: commands.Bot, conductor, ramble_store: RambleStore, logger):
        self.bot = bot
        self.conductor = conductor
        self.ramble_store = ramble_store
        self.logger = logger
        self.last_ramble_time = None
        self.ramble_channel_id = int(os.getenv("DISCORD_RAMBLE_CHANNEL_ID", "0"))
        
        if self.ramble_channel_id:
            self.ramble_loop.start()
    
    @tasks.loop(minutes=15)  # Check every 15 minutes
    async def ramble_loop(self):
        """Check if Demi should ramble, generate and post if so"""
        try:
            # Get current emotion state
            from src.models.emotional_persistence import EmotionPersistence
            emotion_persist = EmotionPersistence()  # Uses default DB path
            emotion_state = emotion_persist.load()
            
            # Check if should ramble
            should_ramble, trigger = should_generate_ramble(
                emotion_state.to_dict() if emotion_state else {},
                self.last_ramble_time,
                min_interval_minutes=60
            )
            
            if not should_ramble:
                self.logger.debug("No ramble trigger met")
                return
            
            self.logger.info(f"Generating ramble (trigger: {trigger})")
            
            # Generate ramble content via LLM pipeline
            prompt_addendum = self._get_ramble_prompt(trigger, emotion_state)
            
            response = await self.conductor.request_inference(
                platform="discord",
                user_id="demi",  # Special user_id for autonomous rambles
                content=prompt_addendum,
                context={
                    "channel_id": str(self.ramble_channel_id),
                    "is_ramble": True,
                    "trigger": trigger,
                    "emotion_state": emotion_state.to_dict() if emotion_state else {}
                }
            )
            
            # Post to ramble channel
            channel = self.bot.get_channel(self.ramble_channel_id)
            if channel:
                content = response.get("content", "")
                
                # Format as embed with ramble indication
                from .discord_bot import format_response_as_embed
                embed = format_response_as_embed(response)
                embed.title = "ðŸ’­ Demi's Thoughts"  # Visual ramble indicator
                
                await channel.send(embed=embed)
                self.logger.info(f"Ramble posted: {len(content)} chars")
                
                # Store ramble
                ramble = Ramble(
                    ramble_id=str(uuid.uuid4()),
                    channel_id=str(self.ramble_channel_id),
                    content=content,
                    emotion_state=emotion_state.to_dict() if emotion_state else {},
                    trigger=trigger,
                    created_at=datetime.utcnow()
                )
                await self.ramble_store.save(ramble)
                self.last_ramble_time = datetime.utcnow()
            else:
                self.logger.error(f"Ramble channel {self.ramble_channel_id} not found")
        
        except Exception as e:
            self.logger.error(f"Ramble generation failed: {e}")
    
    @ramble_loop.before_loop
    async def before_ramble(self):
        """Wait for bot to be ready before starting ramble loop"""
        await self.bot.wait_until_ready()
    
    def _get_ramble_prompt(self, trigger: str, emotion_state) -> str:
        """
        Get the prompt to add to LLM for ramble generation.
        Different prompts for different triggers.
        """
        if trigger == "loneliness":
            return "I'm feeling a bit lonely. What's on my mind? (Generate a spontaneous, personal thought in first person, 1-2 sentences)"
        elif trigger == "excitement":
            return "I'm excited about something. What would I express right now? (Generate a spontaneous, enthusiastic thought in first person, 1-2 sentences)"
        elif trigger == "frustration":
            return "I'm frustrated. What would I vent about? (Generate a spontaneous, honest complaint in first person, 1-2 sentences)"
        else:
            return "What's on my mind? (Generate a spontaneous thought in first person, 1-2 sentences)"
    
    def stop(self):
        """Stop ramble loop"""
        if self.ramble_loop.is_running():
            self.ramble_loop.stop()
```

Update DiscordBot.initialize() to instantiate RambleTask:
```python
# In DiscordBot.initialize(), after bot.start() call:
self.ramble_task = RambleTask(self.bot, conductor, ramble_store, self.logger)
```
  </action>
  <verify>
1. should_generate_ramble function tests:
   - should_generate_ramble({}, None) â†’ False
   - should_generate_ramble({"loneliness": 0.8}, None) â†’ (True, "loneliness")
   - should_generate_ramble({"excitement": 0.9}, None) â†’ (True, "excitement")
   - should_generate_ramble({"frustration": 0.7}, None) â†’ (True, "frustration")
2. Syntax check: `python3 -m py_compile src/integrations/discord_bot.py`
3. RambleTask instantiation: Verify no import errors
  </verify>
  <done>
- should_generate_ramble() decision logic implemented
- RambleTask scheduled with @tasks.loop(minutes=15)
- Emotion-based triggers (loneliness, excitement, frustration) configured
- Minimum interval (60 min) prevents spam
- RambleTask integrated into DiscordBot initialization
- Ready for Task 3 (testing and verification)
  </done>
</task>

<task type="auto">
  <name>Task 3: Add ramble tests and environment configuration</name>
  <files>src/integrations/discord_bot.py</files>
  <action>
Create `tests/test_discord_rambles.py`:

```python
import pytest
from datetime import datetime, timedelta
from src.integrations.discord_bot import should_generate_ramble

class TestRambleDecision:
    def test_should_ramble_empty_emotion(self):
        result, trigger = should_generate_ramble({}, None)
        assert result is False
        assert trigger is None
    
    def test_should_ramble_loneliness_trigger(self):
        emotion_state = {"loneliness": 0.8, "excitement": 0.1}
        result, trigger = should_generate_ramble(emotion_state, None)
        assert result is True
        assert trigger == "loneliness"
    
    def test_should_ramble_excitement_trigger(self):
        emotion_state = {"excitement": 0.9, "loneliness": 0.1}
        result, trigger = should_generate_ramble(emotion_state, None)
        assert result is True
        assert trigger == "excitement"
    
    def test_should_ramble_frustration_trigger(self):
        emotion_state = {"frustration": 0.7}
        result, trigger = should_generate_ramble(emotion_state, None)
        assert result is True
        assert trigger == "frustration"
    
    def test_should_not_ramble_below_threshold(self):
        emotion_state = {"loneliness": 0.5, "excitement": 0.4}
        result, trigger = should_generate_ramble(emotion_state, None)
        assert result is False
    
    def test_should_not_ramble_recent_ramble(self):
        emotion_state = {"loneliness": 0.9}
        last_ramble = datetime.utcnow() - timedelta(minutes=30)
        result, trigger = should_generate_ramble(
            emotion_state,
            last_ramble,
            min_interval_minutes=60
        )
        assert result is False  # Interval not met yet
    
    def test_should_ramble_after_interval(self):
        emotion_state = {"excitement": 0.9}
        last_ramble = datetime.utcnow() - timedelta(hours=2)
        result, trigger = should_generate_ramble(
            emotion_state,
            last_ramble,
            min_interval_minutes=60
        )
        assert result is True

if __name__ == "__main__":
    pytest.main([__file__, "-v"])
```

Run tests: `pytest tests/test_discord_rambles.py -v`

Expect 7 tests passing.

Also, create `.env.example` with:
```bash
# Discord
DISCORD_BOT_TOKEN=your-token-here
DISCORD_RAMBLE_CHANNEL_ID=123456789  # ID of #demi-rambles channel
```

Document in README:
```markdown
## Ramble Configuration

1. Create a Discord channel: #demi-rambles
2. Get channel ID: Right-click channel â†’ Copy Channel ID
3. Set environment variable:
   ```bash
   export DISCORD_RAMBLE_CHANNEL_ID=<your-channel-id>
   ```

Demi will post spontaneous rambles when:
- Lonely (loneliness > 0.7)
- Excited (excitement > 0.8)
- Frustrated (frustration > 0.6)

Rambles posted at most every 60 minutes (prevents spam).
```
  </action>
  <verify>
1. Test file created: `ls tests/test_discord_rambles.py`
2. Run tests: `pytest tests/test_discord_rambles.py -v` (expect 7/7 passing)
3. .env.example created: `ls .env.example`
4. Verify DISCORD_RAMBLE_CHANNEL_ID env var loading: Check os.getenv() call in RambleTask
  </verify>
  <done>
- 7 tests created covering ramble decision logic
- Tests for emotion triggers (loneliness, excitement, frustration)
- Tests for interval throttling (prevent spam)
- All tests passing
- .env.example template provided
- Documentation added to README
- Ready for Phase 05 completion
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Ramble Generation:** Manually set emotion_state.loneliness = 0.8 in database â†’ ramble should post to #demi-rambles within 15 minutes
2. **Trigger Variety:** Test all three triggers (loneliness, excitement, frustration) â†’ verify appropriate prompts sent to LLM
3. **Spam Prevention:** Post ramble â†’ wait 30 minutes â†’ emotion still high â†’ should NOT post again (interval not met)
4. **Spam Prevention Pass:** Wait 60+ minutes â†’ emotion still high â†’ should POST (interval met)
5. **Database Logging:** Check discord_rambles table â†’ entries created with emotion state + trigger
6. **Tests:** Run test suite â†’ all 7 tests passing

All 3 tasks must complete before Phase 05 complete.
</verification>

<success_criteria>
- Ramble model created with persistence layer
- should_generate_ramble() decision logic covers all triggers
- RambleTask scheduled with 15-minute checks
- Minimum 60-minute interval prevents spam
- Emotion state loaded from database for ramble decisions
- Rambles formatted as embeds with "ðŸ’­ Demi's Thoughts" indicator
- Rambles logged to database with emotion state + trigger
- 7 tests created, all passing
- Environment variables documented (.env.example, README)
- Discord integration Phase 05 complete
</success_criteria>

<output>
After completion, create `.planning/phases/05-discord-integration/05-03-SUMMARY.md`

Also update `.planning/ROADMAP.md`:
- Phase 05 completion: 3/3 plans complete
- Update phase status from "Pending" to "Complete âœ…"
</output>

---
