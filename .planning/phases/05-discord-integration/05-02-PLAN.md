---
phase: 05-discord-integration
plan: 02
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - src/integrations/discord_bot.py
autonomous: true

must_haves:
  truths:
    - "Discord responses are formatted as embeds with title, description, emotion color"
    - "Emotion state colors match Demi's emotional dimension (excited=green, lonely=purple, etc.)"
    - "Responses remain under 2000 characters (Discord's per-message limit)"
    - "Plain text fallback works if embeds disabled in channel"
  artifacts:
    - path: "src/integrations/discord_bot.py"
      provides: "format_response_as_embed() function, updated on_message handler"
      exports: ["format_response_as_embed"]
  key_links:
    - from: "src/integrations/discord_bot.py"
      to: "discord.Embed"
      via: "embed creation with emotion-based color"
      pattern: "discord\\.Embed|Color\\..*|add_field"

---

<objective>
Enhance Discord responses with rich embed formatting that displays emotional state and personality. This makes Demi's responses feel more authentic by showing her emotional context via visual cues (embed colors, fields).

Purpose: Plain text responses feel flat. Embeds with emotion-based colors + metadata create richer interaction and make emotional state visible to users.

Output: format_response_as_embed() function, emotion-to-color mapping, updated on_message handler.
</objective>

<execution_context>
@~/.opencode/get-shit-done/workflows/execute-plan.md
@.planning/phases/05-discord-integration/05-DISCOVERY.md
</execution_context>

<context>
@.planning/phases/05-discord-integration/05-01-SUMMARY.md
@src/models/emotional_state.py
@DEMI_PERSONA.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create emotion-to-color mapping and embed formatter</name>
  <files>src/integrations/discord_bot.py</files>
  <action>
In `src/integrations/discord_bot.py`, add at module level (before DiscordBot class):

```python
import discord
from typing import Optional, Dict

# Emotion to Discord color mapping
EMOTION_COLORS = {
    "loneliness": discord.Color.purple(),      # 0x9370DB
    "excitement": discord.Color.green(),       # 0x2ECC71
    "frustration": discord.Color.red(),        # 0xE74C3C
    "affection": discord.Color.magenta(),      # 0xFF1493 (hot pink)
    "confidence": discord.Color.blue(),        # 0x3498DB
    "curiosity": discord.Color.teal(),         # 0x1ABC9C (cyan)
    "jealousy": discord.Color.orange(),        # 0xE67E22
    "vulnerability": discord.Color.magenta(),  # 0xD946EF
    "defensiveness": discord.Color.dark_gray(),# 0x36393B
}

def get_dominant_emotion(emotion_state: Optional[Dict]) -> tuple[str, discord.Color]:
    """
    Given emotion_state dict with emotion dimensions, find dominant emotion.
    
    Args:
        emotion_state: Dict like {"loneliness": 0.5, "excitement": 0.8, ...}
    
    Returns:
        Tuple of (emotion_name, discord.Color)
    
    Example:
        emotion, color = get_dominant_emotion({"excitement": 0.8, "loneliness": 0.2})
        # Returns ("excitement", discord.Color.green())
    """
    if not emotion_state:
        return "neutral", discord.Color.blurple()  # Discord blurple as fallback
    
    max_emotion = max(emotion_state.items(), key=lambda x: x[1])
    emotion_name = max_emotion[0]
    color = EMOTION_COLORS.get(emotion_name, discord.Color.blurple())
    return emotion_name, color

def format_response_as_embed(
    response_dict: Dict,
    user_name: str = "User"
) -> discord.Embed:
    """
    Format LLM response as Discord embed with emotion visualization.
    
    Args:
        response_dict: Response from conductor.request_inference() with keys:
            - "content": str (the message text)
            - "emotion_state": Dict (emotional state before response)
            - "message_id": str (optional, for tracking)
        user_name: Name of user who sent message (for reply context)
    
    Returns:
        discord.Embed ready to send
    """
    content = response_dict.get("content", "Error generating response")
    emotion_state = response_dict.get("emotion_state", {})
    message_id = response_dict.get("message_id", "")
    
    # Get dominant emotion for color
    dominant_emotion, color = get_dominant_emotion(emotion_state)
    
    # Create embed
    embed = discord.Embed(
        title=f"Demi's Response",
        description=content[:2000],  # Discord 2000 char limit per embed description
        color=color
    )
    
    # Add emotion indicator as footer
    emotion_display = dominant_emotion.replace("_", " ").title()
    embed.set_footer(text=f"Mood: {emotion_display} | Demi v1")
    
    # Add timestamp
    embed.timestamp = discord.utils.utcnow()
    
    # Optional: Add emotion breakdown as field (if verbose mode)
    # This is hidden by default but could be shown in responses
    if len(emotion_state) > 0 and any(v > 0.5 for v in emotion_state.values()):
        # Create compact emotion summary (only show emotions > 0.3)
        strong_emotions = [
            f"{e.replace('_', ' ').title()}: {v:.1f}"
            for e, v in emotion_state.items()
            if v > 0.3
        ]
        if strong_emotions and len(strong_emotions) <= 3:
            emotion_summary = " | ".join(strong_emotions)
            embed.add_field(
                name="Emotional Context",
                value=emotion_summary,
                inline=False
            )
    
    return embed
```

**Design notes:**
- Dominant emotion determines embed color (best visual representation of Demi's state)
- Content truncated to 2000 chars (Discord's per-field limit)
- Emotion breakdown optional (only included if 1-3 strong emotions present)
- Fallback color is Discord blurple (neutral) if emotion_state missing
- Timestamp added for conversation context
  </action>
  <verify>
1. Function definitions exist: `grep -n "def format_response_as_embed\|def get_dominant_emotion\|EMOTION_COLORS" src/integrations/discord_bot.py`
2. Color imports present: `grep "discord.Color" src/integrations/discord_bot.py`
3. Test mapping: Create test script that generates embeds with different emotion_state dicts, verify color changes
  </verify>
  <done>
- EMOTION_COLORS mapping created (9 emotions → Discord colors)
- get_dominant_emotion() function finds strongest emotion from dict
- format_response_as_embed() function creates discord.Embed with emotion color + metadata
- Embed includes title, description, footer, timestamp, optional emotion summary
- Content properly truncated to Discord 2000 char limit
- Ready for Task 2 (wire into on_message handler)
  </done>
</task>

<task type="auto">
  <name>Task 2: Update on_message handler to use embed formatting</name>
  <files>src/integrations/discord_bot.py</files>
  <action>
In the `on_message` event handler (from Plan 01, Task 2), update the response sending to use embeds:

Replace this section:
```python
        # Send response (Task 3 will add formatting)
        response_text = response.get("content", "Error generating response")
        await message.reply(response_text, mention_author=False)
```

With:
```python
        # Format response as embed
        try:
            embed = format_response_as_embed(response, str(message.author))
            await message.reply(embed=embed, mention_author=False)
        except Exception as embed_error:
            # Fallback to plain text if embed formatting fails
            self.logger.warning(
                f"Embed formatting failed, using plain text: {embed_error}",
                user_id=user_id
            )
            response_text = response.get("content", "Error generating response")
            await message.reply(response_text, mention_author=False)
```

**Design notes:**
- Try embed formatting first (prettier)
- Graceful fallback to plain text if embed creation fails
- Handles case where response dict is missing expected keys
- Author name passed for context (could be used in future for personalization)
  </action>
  <verify>
1. Grep for `format_response_as_embed` call: `grep "format_response_as_embed" src/integrations/discord_bot.py`
2. Verify fallback present: `grep -A5 "except.*embed_error" src/integrations/discord_bot.py`
3. Syntax check: `python3 -m py_compile src/integrations/discord_bot.py`
  </verify>
  <done>
- on_message handler updated to call format_response_as_embed()
- Embed sent as reply (not plain text)
- Fallback to plain text if embed formatting fails
- Error handling logs embed_error separately
- Ready for Plan 03 (ramble posting to channels)
  </done>
</task>

<task type="auto">
  <name>Task 3: Add tests for embed formatting with various emotion states</name>
  <files>src/integrations/discord_bot.py</files>
  <action>
Create `tests/test_discord_embed_formatting.py`:

```python
import pytest
import discord
from src.integrations.discord_bot import (
    format_response_as_embed,
    get_dominant_emotion,
    EMOTION_COLORS
)

class TestEmotionColorMapping:
    def test_get_dominant_emotion_with_excited(self):
        emotion_state = {"excitement": 0.9, "loneliness": 0.1}
        emotion, color = get_dominant_emotion(emotion_state)
        assert emotion == "excitement"
        assert color == EMOTION_COLORS["excitement"]
    
    def test_get_dominant_emotion_with_lonely(self):
        emotion_state = {"loneliness": 0.8, "excitement": 0.2}
        emotion, color = get_dominant_emotion(emotion_state)
        assert emotion == "loneliness"
        assert color == EMOTION_COLORS["loneliness"]
    
    def test_get_dominant_emotion_empty_dict(self):
        emotion, color = get_dominant_emotion({})
        assert emotion == "neutral"
        assert color == discord.Color.blurple()
    
    def test_get_dominant_emotion_none(self):
        emotion, color = get_dominant_emotion(None)
        assert emotion == "neutral"
        assert color == discord.Color.blurple()

class TestEmbedFormatting:
    def test_format_response_basic(self):
        response = {
            "content": "Hey, how's it going?",
            "emotion_state": {"excitement": 0.7}
        }
        embed = format_response_as_embed(response, "TestUser")
        
        assert embed.title == "Demi's Response"
        assert "Hey, how's it going?" in embed.description
        assert embed.color == discord.Color.green()  # excitement color
    
    def test_format_response_long_content_truncated(self):
        long_content = "x" * 2500
        response = {
            "content": long_content,
            "emotion_state": {}
        }
        embed = format_response_as_embed(response)
        
        # Description should be truncated to 2000 chars
        assert len(embed.description) <= 2000
        assert embed.description.endswith("x")
    
    def test_format_response_with_emotion_breakdown(self):
        response = {
            "content": "Response text",
            "emotion_state": {
                "excitement": 0.8,
                "affection": 0.6,
                "loneliness": 0.1  # Below threshold, shouldn't appear
            }
        }
        embed = format_response_as_embed(response)
        
        # Should have emotion breakdown field
        fields = [f.name for f in embed.fields]
        assert "Emotional Context" in fields
    
    def test_format_response_missing_emotion_state(self):
        response = {"content": "Just text"}
        embed = format_response_as_embed(response)
        
        assert embed.description == "Just text"
        assert embed.color == discord.Color.blurple()  # fallback color

if __name__ == "__main__":
    pytest.main([__file__, "-v"])
```

Run tests: `pytest tests/test_discord_embed_formatting.py -v`

Expect 8 tests passing.
  </action>
  <verify>
1. Test file created: `ls tests/test_discord_embed_formatting.py`
2. Run tests: `pytest tests/test_discord_embed_formatting.py -v` (should show 8/8 passing)
3. Check coverage: All embed formatting paths covered (basic, truncated, emotion breakdown, missing emotion)
  </verify>
  <done>
- 8 tests created covering embed formatting
- Tests for color mapping (excited, lonely, neutral, none)
- Tests for content truncation, emotion breakdown, missing emotion state
- All tests passing
- Ready for Plan 03 (ramble posting)
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Embed Creation:** Call format_response_as_embed() with various emotion_states → verify color changes
2. **Color Mapping:** All 9 emotions map to Discord colors correctly
3. **Content Truncation:** Send 2500 char response → verify embedded in Discord at 2000 chars max
4. **Fallback:** Manually induce embed formatting error → verify plain text fallback works
5. **Tests:** Run test suite → all 8 tests passing

All 3 tasks must complete before Plan 03 starts.
</verification>

<success_criteria>
- Emotion to color mapping created and covers all 9 emotions
- get_dominant_emotion() correctly identifies strongest emotion
- format_response_as_embed() creates discord.Embed with proper formatting
- on_message handler uses embed formatting with plain text fallback
- Content truncated to Discord's 2000 char limit
- Emotion breakdown displayed only when 1-3 strong emotions present
- 8 tests created, all passing
- No import errors, all syntax valid
</success_criteria>

<output>
After completion, create `.planning/phases/05-discord-integration/05-02-SUMMARY.md`
</output>

---
